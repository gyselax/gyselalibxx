<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gyselalib++: EdgeTransformation&lt; Interface &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gyselalib++
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classEdgeTransformation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classEdgeTransformation-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EdgeTransformation&lt; Interface &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Transform a coordinate or an index from one edge to the one on the other edge.  
 <a href="classEdgeTransformation.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a11c84fec5577a58b0addfd13bd744117"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEdgeTransformation.html#a11c84fec5577a58b0addfd13bd744117">EdgeTransformation</a> (IdxRangeEdge1 const &amp;idx_range_patch_1, IdxRangeEdge2 const &amp;idx_range_patch_2)</td></tr>
<tr class="memdesc:a11c84fec5577a58b0addfd13bd744117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate an <a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a>.  <a href="classEdgeTransformation.html#a11c84fec5577a58b0addfd13bd744117">More...</a><br /></td></tr>
<tr class="separator:a11c84fec5577a58b0addfd13bd744117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4e3d76c60e46f6d36a8f6fc9fd8f49"><td class="memTemplParams" colspan="2">template&lt;class CurrentDim &gt; </td></tr>
<tr class="memitem:ade4e3d76c60e46f6d36a8f6fc9fd8f49"><td class="memTemplItemLeft" align="right" valign="top">Coord&lt; std::conditional_t&lt; std::is_same_v&lt; CurrentDim, EdgeDim1 &gt;, EdgeDim2, EdgeDim1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEdgeTransformation.html#ade4e3d76c60e46f6d36a8f6fc9fd8f49">operator()</a> (Coord&lt; CurrentDim &gt; const &amp;current_coord) const</td></tr>
<tr class="memdesc:ade4e3d76c60e46f6d36a8f6fc9fd8f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a coordinate on the edge in the dimension of the current patch to the analogous coordinate on the target patch.  <a href="classEdgeTransformation.html#ade4e3d76c60e46f6d36a8f6fc9fd8f49">More...</a><br /></td></tr>
<tr class="separator:ade4e3d76c60e46f6d36a8f6fc9fd8f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953cea3a043308fbce6a55438daf7376"><td class="memTemplParams" colspan="2">template&lt;class CurrentIdx &gt; </td></tr>
<tr class="memitem:a953cea3a043308fbce6a55438daf7376"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEdgeTransformation.html#a953cea3a043308fbce6a55438daf7376">operator()</a> (CurrentIdx const &amp;current_idx) const</td></tr>
<tr class="memdesc:a953cea3a043308fbce6a55438daf7376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform an index on the edge in the dimension of the current patch to the analogous index on the target patch.  <a href="classEdgeTransformation.html#a953cea3a043308fbce6a55438daf7376">More...</a><br /></td></tr>
<tr class="separator:a953cea3a043308fbce6a55438daf7376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608a25e1800da17a87d13fa7f8a5cfc7"><td class="memTemplParams" colspan="2">template&lt;class CurrentIdx &gt; </td></tr>
<tr class="memitem:a608a25e1800da17a87d13fa7f8a5cfc7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEdgeTransformation.html#a608a25e1800da17a87d13fa7f8a5cfc7">is_match_available</a> (CurrentIdx const &amp;current_idx) const</td></tr>
<tr class="memdesc:a608a25e1800da17a87d13fa7f8a5cfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given index has an equivalent index on the other patch of an interface.  <a href="classEdgeTransformation.html#a608a25e1800da17a87d13fa7f8a5cfc7">More...</a><br /></td></tr>
<tr class="separator:a608a25e1800da17a87d13fa7f8a5cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0259680760413ed6fbbdfc9ffda44fc4"><td class="memTemplParams" colspan="2">template&lt;class CurrentGrid , class TargetGrid &gt; </td></tr>
<tr class="memitem:a0259680760413ed6fbbdfc9ffda44fc4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classEdgeTransformation.html#a0259680760413ed6fbbdfc9ffda44fc4">search_for_match</a> (Idx&lt; TargetGrid &gt; &amp;target_idx, Idx&lt; CurrentGrid &gt; const &amp;current_idx) const</td></tr>
<tr class="memdesc:a0259680760413ed6fbbdfc9ffda44fc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given index has an equivalent index and transform an index on the edge in the dimension of the current patch to the analogous index on the target patch.  <a href="classEdgeTransformation.html#a0259680760413ed6fbbdfc9ffda44fc4">More...</a><br /></td></tr>
<tr class="separator:a0259680760413ed6fbbdfc9ffda44fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Interface&gt;<br />
class EdgeTransformation&lt; Interface &gt;</h3>

<p>Transform a coordinate or an index from one edge to the one on the other edge. </p>
<p>According to the orientation of the interface, we compute the equivalent coordinate</p><ul>
<li>if True, \( \\ t \mapsto min_2 + \frac{t - min_1}{max_1 - min_1}(max_2 - min_2) \)</li>
<li>if False, \( \\ t \mapsto max_2 - \frac{t - min_1}{max_1 - min_1}(max_2 - min_2) \)</li>
</ul>
<p>where \( min_i \) and \( max_i \) are the minimum and maximum coordinates of the edge \( i \).</p>
<p>For the indices, we look for an equivalent index corresponding to a coordinate equivalent to the coordinate of the initial index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a></td><td>The <a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a> type where we want to compute the transformation. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a11c84fec5577a58b0addfd13bd744117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c84fec5577a58b0addfd13bd744117">&#9670;&nbsp;</a></span>EdgeTransformation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classEdgeTransformation.html">EdgeTransformation</a>&lt; <a class="el" href="structInterface.html">Interface</a> &gt;::<a class="el" href="classEdgeTransformation.html">EdgeTransformation</a> </td>
          <td>(</td>
          <td class="paramtype">IdxRangeEdge1 const &amp;&#160;</td>
          <td class="paramname"><em>idx_range_patch_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdxRangeEdge2 const &amp;&#160;</td>
          <td class="paramname"><em>idx_range_patch_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate an <a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx_range_patch_1</td><td>1D index range on the patch 1 of the interface. </td></tr>
    <tr><td class="paramname">idx_range_patch_2</td><td>1D index range on the patch 2 of the interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade4e3d76c60e46f6d36a8f6fc9fd8f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4e3d76c60e46f6d36a8f6fc9fd8f49">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
<div class="memtemplate">
template&lt;class CurrentDim &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coord&lt;std::conditional_t&lt;std::is_same_v&lt;CurrentDim, EdgeDim1&gt;, EdgeDim2, EdgeDim1&gt; &gt; <a class="el" href="classEdgeTransformation.html">EdgeTransformation</a>&lt; <a class="el" href="structInterface.html">Interface</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">Coord&lt; CurrentDim &gt; const &amp;&#160;</td>
          <td class="paramname"><em>current_coord</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a coordinate on the edge in the dimension of the current patch to the analogous coordinate on the target patch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_coord</td><td>A coordinate on the edge of the current patch.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CurrentDim</td><td>The current continuous dimension of the given coordinate coord.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The analogous coordinate on the target patch. </dd></dl>

</div>
</div>
<a id="a953cea3a043308fbce6a55438daf7376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953cea3a043308fbce6a55438daf7376">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
<div class="memtemplate">
template&lt;class CurrentIdx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classEdgeTransformation.html">EdgeTransformation</a>&lt; <a class="el" href="structInterface.html">Interface</a> &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">CurrentIdx const &amp;&#160;</td>
          <td class="paramname"><em>current_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform an index on the edge in the dimension of the current patch to the analogous index on the target patch. </p>
<p>If the grids are uniform, we can simplify the algorithm by using modulo. Otherwise, we need to check all the indices of the target grid. We suppose the coordinate transformation bijective, so we can use a dichotomy method.</p>
<p>This method mainly calls search_for_match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_idx</td><td>A index on the edge of the current patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CurrentIdx</td><td>The current index type of the given coordinate index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The analogous index on the target patch. </dd></dl>

</div>
</div>
<a id="a608a25e1800da17a87d13fa7f8a5cfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a608a25e1800da17a87d13fa7f8a5cfc7">&#9670;&nbsp;</a></span>is_match_available()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
<div class="memtemplate">
template&lt;class CurrentIdx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEdgeTransformation.html">EdgeTransformation</a>&lt; <a class="el" href="structInterface.html">Interface</a> &gt;::is_match_available </td>
          <td>(</td>
          <td class="paramtype">CurrentIdx const &amp;&#160;</td>
          <td class="paramname"><em>current_idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given index has an equivalent index on the other patch of an interface. </p>
<p>If the grids are uniform, we can simplify the algorithm by using modulo. Otherwise, we need to check all the indices of the target grid. We suppose the coordinate transformation bijective, so we can use a dichotomy method. <br  />
</p>
<p>This method mainly calls search_for_match.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current_idx</td><td>A index on the edge of the current patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CurrentIdx</td><td>The current index type of the given coordinate index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean stating if there is an equivalent index. </dd></dl>

</div>
</div>
<a id="a0259680760413ed6fbbdfc9ffda44fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0259680760413ed6fbbdfc9ffda44fc4">&#9670;&nbsp;</a></span>search_for_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface &gt; </div>
<div class="memtemplate">
template&lt;class CurrentGrid , class TargetGrid &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classEdgeTransformation.html">EdgeTransformation</a>&lt; <a class="el" href="structInterface.html">Interface</a> &gt;::search_for_match </td>
          <td>(</td>
          <td class="paramtype">Idx&lt; TargetGrid &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Idx&lt; CurrentGrid &gt; const &amp;&#160;</td>
          <td class="paramname"><em>current_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a given index has an equivalent index and transform an index on the edge in the dimension of the current patch to the analogous index on the target patch. </p>
<p>If the grids are uniform, we can simplify the algorithm by using modulo. Otherwise, we need to check all the indices of the target grid. We suppose the coordinate transformation bijective, so we can use a dichotomy method.</p>
<dl class="section warning"><dt>Warning</dt><dd>target_idx is always replaced by the suspected index. If there is not equivalent index, the returned index is wrong but the closest that the algorithm found.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CurrentGrid</td><td>The grid where the input index is defined. </td></tr>
    <tr><td class="paramname">TargetGrid</td><td>The grid where the output index is defined.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">target_idx</td><td>A index on the edge of the target patch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">current_idx</td><td>A index on the edge of the current patch. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CurrentIdx</td><td>The current index type of the given coordinate index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boolean stating if there is an equivalent index. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/connectivity/<a class="el" href="edge__transformation_8hpp_source.html">edge_transformation.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classEdgeTransformation.html">EdgeTransformation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
