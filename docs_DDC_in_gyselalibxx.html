<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gyselalib++: Using DDC in Gyselalibxx</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gyselalib++
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('docs_DDC_in_gyselalibxx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Using DDC in Gyselalibxx</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/Maison-de-la-Simulation/ddc">DDC</a> is a library which aims to provide types which represent mathematical/physical concepts. Representing these concepts with types allows the compiler to enforce the mathematical validity of expressions.</p>
<p>The DDC library is based on templates. The template parameters are based on physical dimensions.</p>
<p>When using DDC the first step is therefore to create structures representing each of the physical dimensions, e.g. <code><a class="el" href="structX.html" title="Define non periodic real X dimension.">X</a></code>. These objects should only contain one attribute, a static constexpr boolean called <code>PERIODIC</code> which indicates whether the dimension is periodic or not. The DDC types are then parametrised by this structure. The dimension is in real space and is continuous.</p>
<p>The following sections describe some of the DDC types used in Gyselalibxx.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Contents"></a>
Contents</h1>
<ul>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Coordinates">Coordinates</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Indexing_and_associated_concepts">Indexing and associated concepts</a><ul>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Grid">Grid</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Index">Index</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Index_Step">Index Step</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Index_Range">Index Range</a></li>
</ul>
</li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Data_Storage">Data Storage</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Example">Example</a></li>
<li><a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Pitfalls">Pitfalls</a></li>
</ul>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Coordinates"></a>
Coordinates</h1>
<p>A <code>Coord</code> in Gysela is an alias to the DDC type <code>ddc::Coordinate</code>. It is one of the only DDC types which represents a continuous data type. This means that it can take any value that can be represented by a double. It represents the position of a coordinate in the vector space.</p>
<p>Coordinates can have 1 or more dimension. E.g. the coordinate of a position on a \((r,\theta)\) slice should have the type <code>Coord&lt;<a class="el" href="structR.html" title="Define non periodic real R dimension.">R</a>, <a class="el" href="structTheta.html" title="Define periodic real Theta dimension.">Theta</a>&gt;</code>, where <code><a class="el" href="structR.html" title="Define non periodic real R dimension.">R</a></code> represents the radial dimension \(r\), and <code><a class="el" href="structTheta.html" title="Define periodic real Theta dimension.">Theta</a></code> represents the poloidal dimension \(\theta\).</p>
<p>If the value of the coordinate needs to be used in a mathematical expression, the scalar (<code>double</code>) quantity stored in one of the dimensions of a coordinate can be extracted using <code>ddc::get&lt;DimOfInterest&gt;(my_coord)</code>.</p>
<p>It is also possible to extract a coordinate on a subset of the original dimensions using <code>ddc::select&lt;DimOfInterest&gt;(my_coord)</code>. For example if we want to get the position of an object on a radial slice \((r,\theta)\), but we are given the coordinate in the full vector space \((r, \theta, \varphi, v_\parallel, \mu)\) then we can do: </p><div class="fragment"><div class="line">Coord&lt;R, Theta, Phi, Vpar, Mu&gt; full_coord(...);</div>
<div class="line">Coord&lt;R, Theta&gt; slice_coord = ddc::select&lt;R, Theta&gt;(full_coord);</div>
</div><!-- fragment --><p>Coordinates can be combined using operators. For example, let us consider three vectors \(P\), \(Q\), and \(R\) defined on a cartesian space \((x,y)\):</p>
<p><img src="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/docs/images/Coordinate_operations.jpg" alt="Vector Image" class="inline"/></p>
<p>The vector \(Q\) can be written as \(Q=R-P\). Similarly in the code, we would have: </p><div class="fragment"><div class="line">Coord&lt;X, Y&gt; P(5.0, 2.0);</div>
<div class="line">Coord&lt;X, Y&gt; <a class="code hl_struct" href="structR.html">R</a>(7.0, 6.0);</div>
<div class="line">Coord&lt;X, Y&gt; Q = <a class="code hl_struct" href="structR.html">R</a> - P;</div>
<div class="ttc" id="astructR_html"><div class="ttname"><a href="structR.html">R</a></div><div class="ttdoc">Define non periodic real R dimension.</div><div class="ttdef"><b>Definition</b> geometry.hpp:31</div></div>
</div><!-- fragment --><p>The <code>Coord</code> class also provides an addition operator, comparison operators, and an output operator for easy printing using <code>cout</code>.</p>
<p>In Gyselalibxx the alias <code>CoordX</code> is usually defined in <code>geometry.hpp</code> to describe the type <code>Coord&lt;<a class="el" href="structX.html" title="Define non periodic real X dimension.">X</a>&gt;</code> more succinctly.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Indexing_and_associated_concepts"></a>
Indexing and associated concepts</h1>
<p>The physical problems that our simulations describe are defined on a domain. The domain on which the problem is defined is continuous (e.g. a radial domain \([0,1)\)). However a simulation evolves on a grid. This means that the value of the function is only known at a discrete set of points. In the case of a function \(f(x)\rightarrow y \in \mathbb{R}\) with \(x \in [0,1)\), we would usually discretise the domain \([0,1)\) as follows:  </p><p class="formulaDsp">
\[

x_0, x_1, ..., x_i, ..., x_N

\]
</p>
<p>DDC provides multiple types to represent the concepts required to index elements of arrays defined on this grid or to get the coordinates of the grid.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Grid"></a>
Grid</h1>
<p>The points \(\{x_0, ..., x_N\}\) form the grid on which the simulation evolves. This sampling can either be uniform or non-uniform. Accordingly DDC provides 2 classes for which Gysela provides the following type aliases:</p><ul>
<li><code>UniformGridBase</code> (the type alias of <code>ddc::UniformPointSampling</code>)</li>
<li><code>NonUniformGridBase</code> (the type alias of <code>NonUniformPointSampling</code>)</li>
</ul>
<p>A uniform point sampling is a collection of points which are equidistant, it is therefore defined with an origin and a step or distance between consecutive points. In contrast the points found in a non-uniform point sampling are arbitrary. This kind of sampling must therefore be initialised from a list of points.</p>
<p>It is possible to have multiple grids defined on the same dimension (e.g. the grid points used for a Gauss-Legendre quadrature, the grid points on which the simulation evolves, the grid points which split a spline into polynomials, etc). In order for each grid that is defined to have a different type DDC requires that we define structures which inherit from <code>UniformGridBase</code> and <code>NonUniformGridBase</code> (these structures are then the base structures from which we inherit). In Gyselalibxx such structures have the keyword <code>Grid</code> in the name (e.g. <code><a class="el" href="structGridX.html">GridX</a></code>) and are usually defined in <code>geometry.hpp</code>.</p>
<p>E.g.: </p><div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structGridX.html">GridX</a> : UniformGridBase&lt;X&gt;</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="ttc" id="astructGridX_html"><div class="ttname"><a href="structGridX.html">GridX</a></div><div class="ttdef"><b>Definition</b> geometry.hpp:94</div></div>
</div><!-- fragment --><p>Although this seems like a useful type, you should not directly create instances of this class in the code. Instead you should call <code>init_discrete_space</code> and access the points using an <code>Index</code>. For more details see the section about <code>Index</code>.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Index"></a>
Index</h1>
<p>In order to interact with most types in Gyselalibxx we need to use an <code>Idx</code> (a type alias for <code>ddc::DiscreteElement</code>). This type describes an index of a point in the grid. E.g. the point <code>x_i</code> in the grid <code><a class="el" href="structGridX.html">GridX</a></code> can be indexed using the object <code>Idx&lt;<a class="el" href="structGridX.html">GridX</a>&gt;(i)</code>. An <code>Idx</code> is therefore roughly equivalent to an integer. Compared to an integer, it additionally contains information about the physical direction being examined. This allows the compiler to raise errors if typos/copy-paste errors lead to the wrong dimension being used.</p>
<p>In Gyselalibxx the alias <code>IndexX</code> is usually defined in <code>geometry.hpp</code> to describe the index of the grid along the dimension <a class="el" href="structX.html" title="Define non periodic real X dimension.">X</a> on which the distribution function is discretised.</p>
<p>We can also create multi-dimensional indices. E.g. the point <code>(x_i, y_j)</code> can be indexed using the object <code>Idx&lt;<a class="el" href="structGridX.html">GridX</a>, <a class="el" href="structGridY.html">GridY</a>&gt;(i, j)</code></p>
<p>It is also possible to extract an index on a subset of the original dimensions using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_index)</code>.</p>
<p>Once a grid has been initialised using the function <code>ddc::init_discrete_space</code>, an <code>Idx</code> defined on that grid can be used to obtain the coordinates of the points in the grid. This is done using the function <code>ddc::coordinate</code>.</p>
<p>E.g: </p><div class="fragment"><div class="line">Coord&lt;R&gt; r_min(0.0);</div>
<div class="line">Coord&lt;R&gt; r_max(1.0);</div>
<div class="line">IdxStep&lt;R&gt; r_ncells(10);</div>
<div class="line">ddc::init_discrete_space&lt;GridR&gt;(r_min, r_max, r_ncells);</div>
<div class="line">Idx&lt;GridR&gt; i(0); <span class="comment">// The first point in the grid</span></div>
<div class="line">std::cout &lt;&lt; ddc::coordinate(i) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> will output: </p><div class="fragment"><div class="line">(0.0)</div>
</div><!-- fragment --><h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Index_Step"></a>
Index Step</h1>
<p>An <code>IdxStep</code> (type alias for <code>ddc::DiscreteVector</code>) describes the number of steps to get from one point in a grid to another. E.g. <code>x_3</code> and <code>x_6</code> are separated by <code>IdxStep&lt;<a class="el" href="structGridX.html">GridX</a>&gt;(3)</code>.</p>
<p>This type is useful when we have the index of a point and we need to get the next point. An <code>IdxStep</code> can be added or subtracted from an <code>Idx</code> as long as both objects are templated by the same dimension. Similarly an <code>IdxStep</code> is the result of subtracting 2 <code>Idx</code>s.</p>
<p>E.g: </p><div class="fragment"><div class="line">Idx&lt;GridX&gt; i(4);</div>
<div class="line">Idx&lt;GridX&gt; j(6);</div>
<div class="line">IdxStep&lt;GridX&gt; k = j-i;</div>
<div class="line">i += k;</div>
</div><!-- fragment --><p>In Gyselalibxx the alias <code>IdxStepX</code> is usually defined in <code>geometry.hpp</code> to describe the step from one element of a grid along the dimension <a class="el" href="structX.html" title="Define non periodic real X dimension.">X</a> to another.</p>
<p>As with <code>Idx</code>s, an <code>IdxStep</code> can be multi-dimensional and lower dimension <code>IdxStep</code> objects can be extracted using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_vector)</code>.</p>
<p>For a more concrete example of how this type is useful see <a class="el" href="docs_DDC_in_gyselalibxx.html#docs_DDC_in_gyselalibxx__Example">Example</a>.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Index_Range"></a>
Index Range</h1>
<p>The last concept necessary to define the grid on which a simulation evolves is the concept of index ranges. The class <code>IdxRange</code> is designed to describe the indices on which a field is defined. This may be all or only a subset of the indices comprising the grid.</p>
<p>Each index range is described by:</p><ul>
<li>An origin : This is the <code>Idx</code> which indicates the first point in the domain.</li>
<li>A size : This is a <code>IdxStep</code> indicating the number of elements in each dimension.</li>
</ul>
<p>For example if we consider the 2D grid: \([x_0, ..., x_N] \times [y_0, ... y_M]\), the index range would be described as: </p><div class="fragment"><div class="line">Idx&lt;GridX, GridY&gt; origin(0, 0);</div>
<div class="line">IdxStep&lt;GridX, GridY&gt; size(N, M);</div>
<div class="line">IdxRange&lt;GridX, GridY&gt; idx_range(origin, size);</div>
</div><!-- fragment --><p>Similarly the section of the grid: \([x_i, ..., x_j] \times [y_k, ... y_l]\) would be described as: </p><div class="fragment"><div class="line">Idx&lt;GridX&gt; i_index(i);</div>
<div class="line">Idx&lt;GridX&gt; j_index(j);</div>
<div class="line">Idx&lt;GridY&gt; k_index(k);</div>
<div class="line">Idx&lt;GridY&gt; l_index(l);</div>
<div class="line">Idx&lt;GridX, GridY&gt; origin(i_index, k_index);</div>
<div class="line">IdxStep&lt;GridX, GridY&gt; size((j_index-i_index), (l_index-k_index));</div>
<div class="line">IdxRange&lt;GridX, GridY&gt; idx_range(origin, size);</div>
</div><!-- fragment --><p>When working with index ranges we do not usually know if we have access to all of the grid or just a subset. It is therefore important to use the <code>get_index_range</code> function to traverse fields rather than initialising elements manually as we don't know the index of the first element of a <code>IdxRange</code> at compile time.</p>
<p>There are multiple functions available for traversing an index range. Most of the time we will traverse the entire index range. This can be done simply as <code>IdxRange</code> implements the functions <code>begin()</code> and <code>end()</code>. These functions are called automatically using the modern C++ syntax for a for element in list, or using the <code>ddc::for_each</code> function. The latter is to be preferred as it will allow us to add parallelism later. The syntax is: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (Idx&lt;GridX&gt; index : idx_range) {</div>
<div class="line">}</div>
</div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">ddc::for_each(idx_range, [&amp;](Idx&lt;GridX&gt; index) {</div>
<div class="line">});</div>
</div><!-- fragment --><p> In the case of a <code>ddc::for_each</code> the second argument is a lambda function. The <code>[&amp;]</code> ensures that any variable defined outside the loop are captured by reference so they can be used inside the lambda function.</p>
<p>It is also common to need to iterate over a subset of grid points. Such a subset can be created using the syntax described above, however <code>IdxRange</code> also contains several helper functions which are designed to facilitate the creation of these sets:</p><ul>
<li><code>take_first(IdxStep&lt;..&gt; n)</code> : Returns an index range containing only the first n indices of the original range.</li>
<li><code>take_last(IdxStep&lt;..&gt; n)</code> : Returns an index range containing only the last n indices of the original range.</li>
<li><code>remove_first(IdxStep&lt;..&gt; n)</code> : Returns an index range containing all but the first n indices of the original range.</li>
<li><code>remove_last(IdxStep&lt;..&gt; n)</code> : Returns an index range containing all but the last n indices of the original range.</li>
<li><code>remove(IdxStep&lt;..&gt; n_first, IdxStep&lt;..&gt; n_last)</code> : Returns an index range containing all indices of the original range except the first n_first indices and the last n_last indices.</li>
</ul>
<p>It is also possible to extract a lower-dimensional index range from an ND index range using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_idx_range)</code>.</p>
<p>Finally it may not be possible to express the elements you want to iterate over as an index range. This is notably the case if you want to iterate over every j-th element. In this case it is necessary to fall back on <code>IdxRangeIterator</code>. The syntax in this case is: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (IdxRangeIterator&lt;GridX&gt; it=idx_range.begin(); it &lt; idx_range.end(); it += j) {</div>
<div class="line">    Idx&lt;GridX&gt; index = *it;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to the iteration functionalities, <code>IdxRange</code> also has other useful functions. The following is a non-exhaustive list of useful functions:</p><ul>
<li><code>front()</code> : Returns the first <code>Idx</code> in the domain.</li>
<li><code>back()</code> : Returns the last <code>Idx</code> in the domain.</li>
<li><code>size()</code> : Returns the total number of points in the domain (the product of the number of points in each dimension).</li>
<li><code>extents()</code> : Returns the number of points in each dimension stored in an <code>IdxStep</code>.</li>
</ul>
<p>In Gyselalibxx the alias <code>IdxRangeX</code> is usually defined in <code>geometry.hpp</code> to describe the index range containing points from <code><a class="el" href="structGridX.html">GridX</a></code>.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Data_Storage"></a>
Data Storage</h1>
<p>Data is allocated at the instantiation of a <code>FieldMem</code> (type alias for <code>ddc::Chunk</code>). This type is parametrised by the underlying data type (e.g. <code>double</code>), and the <code>IdxRange</code> on which the values are defined. By default in Gysela memory is allocated on the device (GPU).</p>
<p>In order to initialise the data storage to the correct size, a <code>FieldMem</code> is initialised by providing the <code>IdxRange</code> on which the values are defined.</p>
<p>In Gyselalibxx the alias <code>FieldMemX</code> is usually defined in <code>geometry.hpp</code> to describe the memory block for a field defined on the all or part of <code><a class="el" href="structGridX.html">GridX</a></code>.. E.g: </p><div class="fragment"><div class="line">FieldMemXVx&lt;double&gt; distribution_function_2d_alloc(idx_range_x_vx);</div>
</div><!-- fragment --><p>In Gyselalibxx the functions are almost all defined using real numbers. The additional alias <code>DFieldMemX</code> is therefore defined to represent a real function defined on all or part of <code><a class="el" href="structGridX.html">GridX</a></code>. E.g: </p><div class="fragment"><div class="line">DFieldMemRThetaPhiVparMu distribution_function_2d_alloc(idx_range_radial_poloidal_toroidal_velocity_mu);</div>
</div><!-- fragment --><p>As instantiating a <code>FieldMem</code> leads to data allocation using this type always has an associated cost. In order to avoid accidental copying DDC is structured such that the only way to copy data from one <code>FieldMem</code> to another is using the function <code>ddc::deepcopy</code>. Using an assignment or initialising from another <code>FieldMem</code> will result in a compiler error.</p>
<p>To avoid copying data unnecessarily, DDC provides the type <code>Field</code> (type alias for <code>ddc::ChunkSpan</code>). This can be thought of as a reference to a <code>FieldMem</code>. It may at first seem surprising that a new type is required for this as a more typical approach would be to use <code>const&amp;</code>. However when code runs on a GPU a new instance of each variable must be created on the GPU. This is necessary to avoid race conditions and to ensure locality. We do not want all the data in the <code>FieldMem</code> to be copied to/from the GPU every time a kernel is started, so instead we use <code>Field</code> which only copies a pointer to the GPU memory to the new variable instance.</p>
<p>Unless you need to allocate data, you should always use <code>Field</code> rather than <code>FieldMem</code>. A <code>Field</code> can be obtained from a <code>FieldMem</code> using the constructor of <code>Field</code> or the global function <code>get_field</code>.</p>
<p>In Gyselalibxx the alias <code>FieldX</code> is usually defined in <code>geometry.hpp</code> to describe a reference to a function defined on the domain or sub-domain containing points from the point sampling <code><a class="el" href="structGridX.html">GridX</a></code>. E.g: </p><div class="fragment"><div class="line">FieldMemXVx&lt;double&gt; distribution_function_2d_alloc(idx_range_x_vx);</div>
<div class="line">FieldXVx&lt;double&gt; distribution_function_2d(distribution_function_2d_alloc);</div>
</div><!-- fragment --><p>As for <code>FieldMem</code> an additional alias <code>DFieldX</code> is defined to simplify the notation for doubles.</p>
<p>Finally we also define the aliases <code>ConstFieldX</code> and <code>DConstFieldX</code> to represent constant versions of <code>FieldX</code> and <code>DFieldX</code>. These objects are used for function arguments when the contents of the array must not be altered. As they are aliases, not new objects, all the same functions that work for <code>Field</code> can also be used for <code>ConstField</code>. A <code>ConstField</code> can be obtained from a field using the function <code>get_const_field</code>.</p>
<p>:warning: Beware a <code>DConstFieldX</code> is not equivalent to a <code>DFieldX const</code>. The latter indicates only that the field will always be associated with the same <code>FieldMem</code> object. Its contents can still be modified.</p>
<p>A <code>Field</code> is indexed using either multiple 1D <code>Idx</code>s, or one ND <code>Idx</code>. As the <code>Idx</code>s contain information about the dimension on which they act it is not necessary to pass these arguments in a specific order. Thus the following two functions are equivalent: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> get_element_1(DFieldXVx my_chunk, IdxX i, IdxY j) {</div>
<div class="line">    <span class="keywordflow">return</span> my_chunk(i, j);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> get_element_2(DFieldXVx my_chunk, IdxX i, IdxY j) {</div>
<div class="line">    <span class="keywordflow">return</span> my_chunk(j, i);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is particularly useful if we don't know the layout order of the data and will allow us to reorder this data without changing the way we interact with the chunk.</p>
<p>Finally a <code>Field</code> also implements a <code>[]</code> operator. A <code>Field</code> does not have to reference the entire memory block stored in the associated <code>FieldMem</code>. The <code>[]</code> operator can be passed an <code>IdxRange</code> to create a <code>Field</code> which only references part of the <code>FieldMem</code>. This is especially useful for accessing slices. In this case a simpler syntax exists, where we only need to pass the index of the slice. For example, if we wish to get a \((r, \theta)\) slice from a distribution function defined in \((r, \theta, \varphi, v_\parallel, \mu)\) we would do the following: </p><div class="fragment"><div class="line">DFieldMem&lt;IdxRange&lt;GridR, GridTheta, GridPhi, GridVpar, GridMu&gt;&gt; distribution_function_alloc(idx_range);</div>
<div class="line">DField&lt;IdxRange&lt;GridR, GridTheta, GridPhi, GridVpar, GridMu&gt;&gt; distribution_function(distribution_function_alloc);</div>
<div class="line">Idx&lt;GridPhi, GridVpar, GridMu&gt; index;</div>
<div class="line">DField&lt;IdxRange&lt;GridR, GridTheta&gt;&gt; distribution_function_slice = distribution_function[index];</div>
</div><!-- fragment --><h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Example"></a>
Example</h1>
<p>Let us consider the following system of equations (a simple Vlasov-Poisson system):  </p><p class="formulaDsp">
\[

\left[\partial_t + \frac{1}{\sqrt{m_s}} \left(v\partial_x - q_s \partial_x \phi(t,x)\partial_v\right)\right] f_s(t,x,v) = 0\\

\partial_x^2\phi(t,x) = - \sum_s q_s \int f_s(t,x,v) dv\\

f_s(0,x,v) = \frac{n_0}{2\pi T_0}\exp\left(-\frac{v^2}{T_0}\right)\cos(k_xx)

\]
</p>
<p>which evolves over a 2 dimensional domain defined by the dimensions \((x,v)\). The domain is \([0, 700]\times[-6,6]\). We can also consider the species s as a discrete dimension which is defined as [i, e].</p>
<p>The first thing which is necessary to define our system are types describing the continuous dimensions: </p><div class="fragment"><div class="line"><span class="comment">// Tag to represent the x-dimension</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structX.html">X</a> {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">constexpr</span> <a class="code hl_variable" href="structX.html#aa1915e83f5e8d1363cbc25d737b52a9c">PERIODIC</a> = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tag to represent the v-dimension</span></div>
<div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="structVx.html">Vx</a> {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> <span class="keyword">constexpr</span> <a class="code hl_variable" href="structVx.html#aabb61a786e12232d6e6adaf41a545a4a">PERIODIC</a> = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="ttc" id="astructVx_html"><div class="ttname"><a href="structVx.html">Vx</a></div><div class="ttdoc">Define non periodic real X velocity dimension.</div><div class="ttdef"><b>Definition</b> geometry.hpp:301</div></div>
<div class="ttc" id="astructVx_html_aabb61a786e12232d6e6adaf41a545a4a"><div class="ttname"><a href="structVx.html#aabb61a786e12232d6e6adaf41a545a4a">Vx::PERIODIC</a></div><div class="ttdeci">static bool constexpr PERIODIC</div><div class="ttdoc">Define periodicity of the dimension.</div><div class="ttdef"><b>Definition</b> geometry.hpp:306</div></div>
<div class="ttc" id="astructX_html"><div class="ttname"><a href="structX.html">X</a></div><div class="ttdoc">Define non periodic real X dimension.</div><div class="ttdef"><b>Definition</b> geometry.hpp:278</div></div>
<div class="ttc" id="astructX_html_aa1915e83f5e8d1363cbc25d737b52a9c"><div class="ttname"><a href="structX.html#aa1915e83f5e8d1363cbc25d737b52a9c">X::PERIODIC</a></div><div class="ttdeci">static bool constexpr PERIODIC</div><div class="ttdoc">Define periodicity of the dimension.</div><div class="ttdef"><b>Definition</b> geometry.hpp:283</div></div>
</div><!-- fragment --><p>We also need types to define the grid on which the simulation will evolve. The domain is discretised on the following grid: \([i, e]\times[x_0,...,x_N]\times[v_0,...,v_{N_v}]\). Grid types are required to define the positions of the grid points in each of the three dimensions:</p><ul>
<li>The object \([x_0,...,x_N]\) is defined with a grid and will be denoted \(GridX\).</li>
<li>The object \([v_0,...,v_{N_v}]\) is defined with a grid and will be denoted \(GridVx\).</li>
<li>The object \([&#39;i&#39;, &#39;e&#39;]\) is defined as a <code><a class="el" href="classSpeciesInformation.html" title="Species discrete dimension to access constant attributes related to species.">SpeciesInformation</a></code> collection and will be denoted \(Species\).</li>
</ul>
<p>With these objects defined, the index range(s) can then be created. The index range for the distribution function has the type: <code>IdxRange&lt;<a class="el" href="structSpecies.html">Species</a>, <a class="el" href="structGridX.html">GridX</a>, <a class="el" href="structGridVx.html">GridVx</a>&gt;</code> however for simplicity it is denoted <code>IdxRangeSpXVx</code>. The electric potential \(\phi\) has a smaller domain with the type <code>IdxRange&lt;<a class="el" href="structGridX.html">GridX</a>&gt;</code> denoted <code>IdxRangeX</code>.</p>
<p>Other index ranges may be useful to work on slices of data or on subdomains (e.g. if we distribute our function using MPI).</p>
<p>The data itself will be stored in <code>FieldMem</code>s and accessed with <code>Field</code>s. For example the distribution function will be stored in a <code>DFieldMem&lt;IdxRange&lt;<a class="el" href="structSpecies.html">Species</a>, <a class="el" href="structGridX.html">GridX</a>, <a class="el" href="structGridVx.html">GridVx</a>&gt;&gt;</code>. To improve readability this type is denoted <code>DFieldMemSpXVx</code>. Similarly the electric potential will be stored in a <code>DFieldMemX</code>.</p>
<p>The other types will be useful when interacting with the data. For example, in order to initialise the distribution function we need to loop over the grid using the coordinates and an <code>Idx&lt;<a class="el" href="structSpecies.html">Species</a>, <a class="el" href="structGridX.html">GridX</a>, <a class="el" href="structGridVx.html">GridVx</a>&gt;</code> (denoted <code>IdxSpXVx</code> for simplicity) to fill the array: </p><div class="fragment"><div class="line">IdxRangeSpXVx idx_range(..);</div>
<div class="line">DFieldMemSpXVx distribution_function_alloc(idx_range);</div>
<div class="line">DFieldSpXVx distribution_function(distribution_function_alloc);</div>
<div class="line"> </div>
<div class="line">ddc::for_each(idx_range, [&amp;](IdxSpXVx index) {</div>
<div class="line">    CoordXVx coord = ddc::coordinate(ddc::select&lt;GridX, GridVx&gt;(index));</div>
<div class="line">    <span class="keywordtype">double</span> v_pos = ddc::get&lt;Vx&gt;(coord);</div>
<div class="line">    <span class="keywordtype">double</span> x_pos = ddc::get&lt;X&gt;(coord);</div>
<div class="line">    distribution_function(index) = n0 / (2 * M_PI * T0) * exp(-v_pos * v_pos / T0) * cos(kx * x_pos);</div>
<div class="line">});</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md16"></a>
Continuous vs. discrete objects</h3>
<p>The majority of the DDC types represent objects in or on a discrete vector space. It may not be immediately obvious why continous objects are also needed given that simulations are necessarily discrete. Backward semi-Lagrangian advection is a good example of where this is required. In backward semi-Lagrangian advection we work on a discrete grid (accessed via an <code>IdxRange</code>), for each point of the grid we trace the characteristic to find where a particle positioned at this grid point would have been located at the previous time step. This location, known as the foot of the characteristic can be located anywhere in the vector space, unlike the grid points, the foot of the characteristic is not restricted to a subset of valid positions. It must therefore be represented with a continuous object. In this case a <code>Coord</code> perfectly describes the position of the foot of the characteristic while also providing all pertinent information about the dimensions.</p>
<h3><a class="anchor" id="autotoc_md17"></a>
Example use of Index Step for Finite Differences</h3>
<p>The class <code>IdxStep</code> is particularly useful in cases where we wish to express a stencil. Let us consider the case of a 2D finite differences scheme on uniform meshes expressed as follows:  </p><p class="formulaDsp">
\[

\nabla^2 f(x,y) = \frac{f(x-h_x, y) + f(x+h_x, y) + f(x, y-h_y) + f(x, y+h_y) - 4f(x,y)}{h_x h_y}

\]
</p>
<p>This code can be written simply using <code>Idx</code> and <code>IdxStep</code>: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> get_laplacian_at_position(DFieldXY function_values, IndexXY position)</div>
<div class="line">{</div>
<div class="line">    IdxStepX x_step(1);</div>
<div class="line">    IdxStepY y_step(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the uniform grid in the appropriate direction and use it to</span></div>
<div class="line">    <span class="comment">// extract the distance h.</span></div>
<div class="line">    <span class="keywordtype">double</span> h_x = ddc::discrete_space&lt;X&gt;().step();</div>
<div class="line">    <span class="keywordtype">double</span> h_y = ddc::discrete_space&lt;Y&gt;().step();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (function_values(position - x_step) + function_values(position + x_step)</div>
<div class="line">            + function_values(position - y_step) function_values(position + y_step)</div>
<div class="line">            - 4 * function_values(position))</div>
<div class="line">           / (h_x * h_y);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see DDC takes care of combining elements and vectors to ensure that the resulting <code>IdxXY</code> is in the correct position. This makes it simpler to write such stencils and easier to spot errors, especially in cases involving lots of dimensions.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Pitfalls"></a>
Pitfalls</h1>
<p>When using DDC there are some things that you should be careful about. These are listed here.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Synchronicity</h3>
<p>In DDC and Kokkos the code runs asynchronously when an execution space is provided. When no execution space is provided the code runs synchronously surrounded by fences. In order to ensure that there is no danger coming from the asynchronicity we need to follow certain rules. In Gysela the chosen conventions are:</p><ul>
<li>Always provide an execution space to <code>ddc::parallel_for_each</code> or <code>ddc::parallel_transform_reduce</code> (or similar Kokkos functions).</li>
<li>Only provide an execution space to <code>create_mirror_view_and_copy</code> when this is unavoidable (i.e. when copying to the <code>DefaultExecutionSpace</code>). The <code>DefaultHostExecutionSpace</code> should never be passed to <code>create_mirror_view_and_copy</code>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
