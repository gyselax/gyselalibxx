<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gyselalib++: Using DDC in Gyselalibxx</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gyselalib++
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('docs_DDC_in_gyselalibxx.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Using DDC in Gyselalibxx </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/Maison-de-la-Simulation/ddc">DDC</a> is a library which aims to provide types which represent mathematical/physical concepts. Representing these concepts with types allows the compiler to enforce the mathematical validity of expressions.</p>
<p>The DDC library is based on templates. The template parameters are based on physical dimensions.</p>
<p>When using DDC the first step is therefore to create structures representing each of the physical dimensions, e.g. <a class="el" href="structRDimX.html" title="Define non periodic real X dimension.">RDimX</a>. These objects should only contain one attribute, a static constexpr boolean called PERIODIC which indicates whether the dimension is periodic or not. The DDC types are then parametrised by this structure. The "R" in the name of the dimension stands for "real", it indicates that the dimension is in real space and is continuous.</p>
<p>The following sections describe some of the DDC types used in Gyselalibxx.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Contents"></a>
Contents</h1>
<ul>
<li><a href="#docs_DDC_in_gyselalibxx__Coordinate">Coordinate</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__Domain_and_associated_concepts">Domain and associated concepts</a><ul>
<li><a href="#docs_DDC_in_gyselalibxx__PointSampling">PointSampling</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__DiscreteElement">DiscreteElement</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__DiscreteVector">DiscreteVector</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__DiscreteDomain">DiscreteDomain</a></li>
</ul>
</li>
<li><a href="#docs_DDC_in_gyselalibxx__Data_Storage">Data Storage</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__Example">Example</a></li>
<li><a href="#docs_DDC_in_gyselalibxx__Pitfalls">Pitfalls</a></li>
</ul>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Coordinate"></a>
Coordinate</h1>
<p>A <code>ddc::Coordinate</code> is one of the only DDC types which represents a continuous data type. This means that it can take any value that can be represented by a double. It represents the position of a coordinate in the vector space.</p>
<p>Coordinates can have 1 or more dimension. E.g. the coordinate of a position on a \((r,\theta)\) slice should have the type <code>ddc::Coordinate&lt;<a class="el" href="structRDimR.html" title="Define non periodic real R dimension.">RDimR</a>, <a class="el" href="structRDimP.html" title="Define periodic real Theta dimension.">RDimP</a>&gt;</code>, where <code><a class="el" href="structRDimR.html" title="Define non periodic real R dimension.">RDimR</a></code> represents the radial dimension \(r\), and <code><a class="el" href="structRDimP.html" title="Define periodic real Theta dimension.">RDimP</a></code> represents the poloidal dimension \(\theta\).</p>
<p>If the value of the coordinate needs to be used in a mathematical expression, the scalar (<code>double</code>) quantity stored in one of the dimensions of a coordinate can be extracted using <code>ddc::get&lt;RDimOfInterest&gt;(my_coord)</code>.</p>
<p>It is also possible to extract a coordinate on a subset of the original dimensions using <code>ddc::select&lt;RDimOfInterest&gt;(my_coord)</code>. For example if we want to get the position of an object on a radial slice \((r,\theta)\), but we are given the coordinate in the full vector space \((r, \theta, \varphi, v_\parallel, \mu)\) then we can do: </p><div class="fragment"><div class="line">ddc::Coordinate&lt;RDimR, RDimP, RDimT, RDimV, RDimM&gt; full_coord(...);</div>
<div class="line">ddc::Coordinate&lt;RDimR, RDimP&gt; slice_coord = ddc::select&lt;RDimR, RDimP&gt;(full_coord);</div>
</div><!-- fragment --><p>Coordinates can be combined using operators. For example, let us consider three vectors \(P\), \(Q\), and \(R\) defined on a cartesian space \((x,y)\):</p>
<p><img src="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/docs/images/Coordinate_operations.jpg" alt="Vector Image" class="inline"/></p>
<p>The vector \(Q\) can be written as \(Q=R-P\). Similarly in the code, we would have: </p><div class="fragment"><div class="line">ddc::Coordinate&lt;RDimX, RDimY&gt; P(5.0, 2.0);</div>
<div class="line">ddc::Coordinate&lt;RDimX, RDimY&gt; R(7.0, 6.0);</div>
<div class="line">ddc::Coordinate&lt;RDimX, RDimY&gt; Q = R - P;</div>
</div><!-- fragment --><p>The <code>Coordinate</code> class also provides an addition operator, comparison operators, and an output operator for easy printing using <code>cout</code>.</p>
<p>In Gyselalibxx the alias <code>CoordX</code> is usually defined in <code>geometry.hpp</code> to describe the type <code>ddc::Coordinate&lt;<a class="el" href="structRDimX.html" title="Define non periodic real X dimension.">RDimX</a>&gt;</code> more succinctly.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Domain_and_associated_concepts"></a>
Domain and associated concepts</h1>
<p>The physical problems that our simulations describe are defined on a domain. The domain on which the problem is defined is continuous (e.g. a radial domain \([0,1)\)). However a simulation evolves on a discrete domain. This means that the value of the function is only known at a discrete set of points. In the case of a function \(f(x)\rightarrow y \in \mathbb{R}\) with \(x \in [0,1)\), we would usually discretise the domain \([0,1)\) as follows: </p><p class="formulaDsp">
\[ x_0, x_1, ..., x_i, ..., x_N \]
</p>
<p>DDC provides multiple types to represent the concepts required to interact with such a domain.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__PointSampling"></a>
PointSampling</h1>
<p>The points \(\{x_0, ..., x_N\}\) are a point sampling. This sampling can either be uniform or non-uniform. Accordingly DDC provides the 2 classes:</p><ul>
<li>UniformPointSampling</li>
<li>NonUniformPointSampling</li>
</ul>
<p>A uniform point sampling is a collection of points which are equidistant, it is therefore defined with an origin and a step. In contrast the points found in a non-uniform point sampling are arbitrary. This kind of sampling must therefore be initialised from a list of points.</p>
<p>In Gyselalibxx the alias <code><a class="el" href="structIDimX.html">IDimX</a></code> is usually defined in <code>geometry.hpp</code> to describe a point sampling along the dimension X. The "I" in <code><a class="el" href="structIDimX.html">IDimX</a></code> stands for "Interpolation". This is because the function is only stored at the interpolation points. The point sampling contains these interpolation points.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__DiscreteElement"></a>
DiscreteElement</h1>
<p>The simplest type to understand is <code>ddc::DiscreteElement</code>. This corresponds to the index of the point in the point sampling. E.g. the point <code>x_i</code> in the point sampling can be indexed using the object <code>ddc::DiscreteElement&lt;<a class="el" href="structIDimX.html">IDimX</a>&gt;(i)</code>. A <code>ddc::DiscreteElement</code> is therefore roughly equivalent to an integer. Compared to an integer, it additionally contains information about the physical direction being examined. This allows the compiler to raise errors if typos/copy-paste errors lead to the wrong dimension being used.</p>
<p>As a discrete concept this class does not take the continuous dimension as a template parameter, rather it takes the discrete point sampling instead.</p>
<p>In Gyselalibxx the alias <code>IndexX</code> is usually defined in <code>geometry.hpp</code> to describe the index of a point sampling along the dimension X.</p>
<p>We can also create multi-dimensional indices. E.g. the point <code>(x_i, y_j)</code> can be indexed using the object <code>ddc::DiscreteElement&lt;<a class="el" href="structIDimX.html">IDimX</a>, <a class="el" href="structIDimY.html">IDimY</a>&gt;(i, j)</code></p>
<p>It is also possible to extract an index on a subset of the original dimensions using <code>ddc::select&lt;IDimOfInterest&gt;(my_nd_index)</code>.</p>
<p>If a point sampling has been initialised using the function <code>ddc::init_discrete_space</code>, a <code>ddc::DiscreteElement</code> defined on that sampling can be used to find the coordinates of the points in the point sampling. This is done using the function <code>ddc::coordinate</code>.</p>
<p>E.g: </p><div class="fragment"><div class="line">ddc::init_discrete_space&lt;ddc::UniformPointSampling&lt;RDimR&gt;&gt;(0.0, 0.1);</div>
<div class="line">ddc::DiscreteElement&lt;IDimR&gt; i(0); <span class="comment">// The first point in the point sampling</span></div>
<div class="line">std::cout &lt;&lt; ddc::coordinate(i) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> will output: </p><div class="fragment"><div class="line">(0.0)</div>
</div><!-- fragment --><h1><a class="anchor" id="docs_DDC_in_gyselalibxx__DiscreteVector"></a>
DiscreteVector</h1>
<p>A <code>ddc::DiscreteVector</code> describes the number of grid points between points in a sampling. E.g. <code>x_3</code> and <code>x_6</code> are separated by <code>ddc::DiscreteVector&lt;<a class="el" href="structIDimX.html">IDimX</a>&gt;(3)</code>.</p>
<p>As a discrete concept this class does not take the continuous dimension as a template parameter, rather it takes the discrete point sampling instead.</p>
<p>This type is useful when we have the index of a point and we need to get the next point. A <code>ddc::DiscreteVector</code> can be added or subtracted from a <code>ddc::DiscreteElement</code> as long as both objects are templated by the same dimension. Similarly a <code>ddc::DiscreteVector</code> is the result of subtracting 2 <code>ddc::DiscreteElement</code>s.</p>
<p>E.g: </p><div class="fragment"><div class="line">ddc::DiscreteElement&lt;IDimX&gt; i(4);</div>
<div class="line">ddc::DiscreteElement&lt;IDimX&gt; j(6);</div>
<div class="line">ddc::DiscreteVector&lt;IDimX&gt; k = j-i;</div>
<div class="line">i += k;</div>
</div><!-- fragment --><p>In Gyselalibxx the alias <code>IVectX</code> is usually defined in <code>geometry.hpp</code> to describe the vector from one element of a point sampling along the dimension X to another.</p>
<p>As with <code>ddc::DiscreteElement</code>s, a <code>ddc::DiscreteVector</code> can be multi-dimensional and lower dimension <code>ddc::DiscreteVector</code> objects can be extracted using <code>ddc::select&lt;IDimOfInterest&gt;(my_nd_vector)</code>.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__DiscreteDomain"></a>
DiscreteDomain</h1>
<p>The last concept necessary to define a discrete domain is the concept of sub-domains. The class <code>ddc::DiscreteDomain</code> is designed to describe a sub-domain (although it can of course hold the whole domain). It is templated over each of the discrete point samplings used to describe the discrete domain on which the simulation evolves.</p>
<p>Each subdomain is described by:</p><ul>
<li>An origin : This is the <code>ddc::DiscreteElement</code> which indicates the first point in the domain.</li>
<li>A size : This is a <code>ddc::DiscreteVector</code> indicating the number of elements in each dimension.</li>
</ul>
<p>For example if we consider the 2D domain: \([x_0, ..., x_N] \times [y_0, ... y_M]\), the domain would be described as: </p><div class="fragment"><div class="line">ddc::DiscreteElement&lt;IDimX, IDimY&gt; origin(0, 0);</div>
<div class="line">ddc::DiscreteVector&lt;IDimX, IDimY&gt; size(N, M);</div>
<div class="line">ddc::DiscreteDomain&lt;IDimX, IDimY&gt; domain(origin, size);</div>
</div><!-- fragment --><p>Similarly the sub-domain: \([x_i, ..., x_j] \times [y_k, ... y_l]\) would be described as: </p><div class="fragment"><div class="line">ddc::DiscreteElement&lt;IDimX&gt; i_index(i);</div>
<div class="line">ddc::DiscreteElement&lt;IDimX&gt; j_index(j);</div>
<div class="line">ddc::DiscreteElement&lt;IDimY&gt; k_index(k);</div>
<div class="line">ddc::DiscreteElement&lt;IDimY&gt; l_index(l);</div>
<div class="line">ddc::DiscreteElement&lt;IDimX, IDimY&gt; origin(i_index, k_index);</div>
<div class="line">ddc::DiscreteVector&lt;IDimX, IDimY&gt; size((j_index-i_index), (l_index-k_index));</div>
<div class="line">ddc::DiscreteDomain&lt;IDimX, IDimY&gt; domain(origin, size);</div>
</div><!-- fragment --><p>When working with domains we do not usually know if we have access to all of a domain or simply a subdomain. It is therefore important to use the domain functions to traverse the domain rather than initialising elements manually as we don't know the index of the first element of a <code>ddc::DiscreteDomain</code> at compile time.</p>
<p>There are multiple functions available for traversing a domain. Most of the time we will traverse the entire domain. This can be done simply as <code>ddc::DiscreteDomain</code> implements the functions <code>begin()</code> and <code>end()</code>. These functions are called automatically using the modern C++ syntax for a for element in list, or using the <code>ddc::for_each</code> function. The latter is to be preferred as it will allow us to add parallelism later. The syntax is: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (ddc::DiscreteElement&lt;IDimX&gt; index : domain) {</div>
<div class="line">}</div>
</div><!-- fragment --><p> or: </p><div class="fragment"><div class="line">ddc::for_each(domain, [&amp;](ddc::DiscreteElement&lt;IDimX&gt; index) {</div>
<div class="line">});</div>
</div><!-- fragment --><p> In the case of a <code>ddc::for_each</code> the second argument is a lambda function. The <code>[&amp;]</code> ensures that any variable defined outside the loop are captured by reference so they can be used inside the lamda function.</p>
<p>It is also common to need to iterate over a sub-domain. Sub-domains can be created using the syntax described above, however <code>ddc::DiscreteDomain</code> also contains several helper functions which are designed to facilitate the creation of subdomains:</p><ul>
<li><code>take_first(ddc::DiscreteVector&lt;..&gt; n)</code> : Returns a sub-domain, restricted to the first n elements.</li>
<li><code>take_last(ddc::DiscreteVector&lt;..&gt; n)</code> : Returns a sub-domain, restricted to the last n elements.</li>
<li><code>remove_first(ddc::DiscreteVector&lt;..&gt; n)</code> : Returns a sub-domain, containing all elements except the first n elements.</li>
<li><code>remove_last(ddc::DiscreteVector&lt;..&gt; n)</code> : Returns a sub-domain, containing all elements except the last n elements.</li>
<li><code>remove(ddc::DiscreteVector&lt;..&gt; n_first, ddc::DiscreteVector&lt;..&gt; n_last)</code> : Returns a sub-domain, containing all elements except the first n_first elements and the last n_last elements.</li>
</ul>
<p>It is also possible to extract a sub-domain on a subset of the original dimensions using <code>ddc::select&lt;IDimOfInterest&gt;(my_nd_domain)</code>.</p>
<p>Finally it may not be possible to express the elements you want to iterate over as a domain. This is notably the case if you want to iterate over every j-th element. In this case it is necessary to fall back on <code>ddc::DiscreteDomainIterator</code>. The syntax in this case is: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (ddc::DiscreteDomainIterator&lt;IDimX&gt; it=domain.begin(); it &lt; domain.end(); it += j) {</div>
<div class="line">    ddc::DiscreteElement&lt;IDimX&gt; index = *it;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In addition to the iteration functionalities, <code>ddc::DiscreteDomain</code> also has other useful functions. The following is a non-exhaustive list of useful functions:</p><ul>
<li><code>front()</code> : Returns the first <code>ddc::DiscreteElement</code> in the domain.</li>
<li><code>back()</code> : Returns the last <code>ddc::DiscreteElement</code> in the domain.</li>
<li><code>size()</code> : Returns the total number of points in the domain (the product of the number of points in each dimension).</li>
<li><code>extents()</code> : Returns the number of points in each dimension stored in a <code>ddc::DiscreteVector</code>.</li>
</ul>
<p>In Gyselalibxx the alias <code>IDomainX</code> is usually defined in <code>geometry.hpp</code> to describe the domain or sub-domain containing points from the point sampling <code><a class="el" href="structIDimX.html">IDimX</a></code>.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Data_Storage"></a>
Data Storage</h1>
<p>DDC provides the type <code>ddc::Chunk</code> to store data. This type is parametrised by the underlying data type (e.g. <code>double</code>), and the <code>ddc::DiscreteDomain</code> on which the values are defined.</p>
<p>In order to initialise the data storage to the correct size, a <code>ddc::Chunk</code> is initailised by providing the <code>ddc::DiscreteDomain</code> on which the values are defined.</p>
<p>In Gyselalibxx the alias <code>FieldX</code> is usually defined in <code>geometry.hpp</code> to describe a function defined on the domain or sub-domain containing points from the point sampling <code><a class="el" href="structIDimX.html">IDimX</a></code>. E.g: </p><div class="fragment"><div class="line">FieldXVx&lt;double&gt; distribution_function_2d(dom_x_vx);</div>
</div><!-- fragment --><p>In Gyselalibxx the functions are almost all defined using real numbers. The additional alias <code>DFieldX</code> is therefore defined to represent a real function defined on the domain or sub-domain containing points from the point sampling <code><a class="el" href="structIDimX.html">IDimX</a></code>. E.g: </p><div class="fragment"><div class="line">DFieldRPTVM distribution_function_2d(dom_radial_poloidal_toroidal_velocity_mu);</div>
</div><!-- fragment --><p>A <code>ddc::Chunk</code> is indexed using either multiple 1D <code>ddc::DiscreteElement</code>s, or one ND <code>ddc::DiscreteElement</code>. As the <code>ddc::DiscreteElement</code>s contain information about the dimension on which they act it is not necessary to pass these arguments in a specific order. Thus the following two functions are equivalent: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> get_element_1(DFieldXVx my_chunk, IndexX i, IndexY j) {</div>
<div class="line">    <span class="keywordflow">return</span> my_chunk(i, j);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> get_element_2(DFieldXVx my_chunk, IndexX i, IndexY j) {</div>
<div class="line">    <span class="keywordflow">return</span> my_chunk(j, i);</div>
<div class="line">}</div>
</div><!-- fragment --><p> This is particularly useful if we don't know the layout order of the data and will allow us to reorder this data without changing the way we interact with the chunk.</p>
<p>Copying a <code>ddc::Chunk</code> is potentially costly. In order to avoid accidental copying DDC is structured such that the only way to copy data from one <code>ddc::Chunk</code> to another is using the function <code>ddc::deepcopy</code>. Using an assignment or initialising from another <code>ddc::Chunk</code> will result in a compiler error.</p>
<p>To avoid copying data unnecessarily, DDC provides the type <code>ddc::ChunkSpan</code>. This can be thought of as a reference to a <code>ddc::Chunk</code>. However it is slightly more complex than this as a <code>ddc::ChunkSpan</code> does not have to reference the entire domain stored in the <code>ddc::Chunk</code>. The <code>[]</code> operator can be passed a <code>ddc::DiscreteDomain</code> to create a <code>ddc::ChunkSpan</code> which only references part of the <code>ddc::Chunk</code>. This is especially useful for accessing slices. In this case a simpler syntax exists, where we only need to pass the index of the slice. For example, if we wish to get a \((r, \theta)\) slice from a distribution function defined in \((r, \theta, \varphi, v_\parallel, \mu)\) we would do the following: </p><div class="fragment"><div class="line">ddc::ChunkSpan&lt;double, ddc::DiscreteDomain&lt;IDimR, IDimP&gt;&gt; get_slice(ddc::Chunk&lt;<span class="keywordtype">double</span>, ddc::DiscreteDomain&lt;IDimR, IDimP, IDimT, IDimV, IDimM&gt;&gt;&amp; distribution_function, ddc::DiscreteElement&lt;IDimT, IDimV, IDimM&gt; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> distribution_function[index];</div>
<div class="line">}</div>
</div><!-- fragment --><p>Unless you need to allocate data, you should always use <code>ddc::ChunkSpan</code> rather than <code>ddc::Chunk</code>.</p>
<p>In Gyselalibxx the alias <code>SpanX</code> is usually defined in <code>geometry.hpp</code> to describe a reference to a function defined on the domain or sub-domain containing points from the point sampling <code><a class="el" href="structIDimX.html">IDimX</a></code>. E.g: </p><div class="fragment"><div class="line">FieldXVx&lt;double&gt; distribution_function_2d(dom_x_vx);</div>
<div class="line">SpanXVx&lt;double&gt; distribution_function_2d_ref(distribution_function_2d);</div>
</div><!-- fragment --><p>As for <code>ddc::Chunk</code> an additional alias <code>DSpanX</code> is defined to simplify the notation for doubles.</p>
<p>Finally we also define the aliases <code>ViewX</code> and <code>DViewX</code> to represent constant versions of <code>SpanX</code> and <code>DSpanX</code>. These objects are used for function arguments when the contents of the array must not be altered. As they are aliases, not new objects, all the same functions that work for <code>ddc::ChunkSpan</code> can also be used for <code>ddc::ChunkView</code>. For example, if we wish to get a \((r, \theta)\) constant slice from a distribution function defined in \((r, \theta, \varphi, v_\parallel, \mu)\) we would do the following: </p><div class="fragment"><div class="line">ddc::ChunkView&lt;double, ddc::DiscreteDomain&lt;IDimR, IDimP&gt;&gt; get_slice(ddc::Chunk&lt;<span class="keywordtype">double</span>, ddc::DiscreteDomain&lt;IDimR, IDimP, IDimT, IDimV, IDimM&gt;&gt;&amp; distribution_function, ddc::DiscreteElement&lt;IDimT, IDimV, IDimM&gt; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> distribution_function[index];</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Example"></a>
Example</h1>
<p>Let us consider the following system of equations (a simple Vlasov-Poisson system): </p><p class="formulaDsp">
\[ \left[\partial_t + \frac{1}{\sqrt{m_s}} \left(v\partial_x - q_s \partial_x \phi(t,x)\partial_v\right)\right] f_s(t,x,v) = 0\\ \partial_x^2\phi(t,x) = - \sum_s q_s \int f_s(t,x,v) dv\\ f_s(0,x,v) = \frac{n_0}{2\pi T_0}\exp\left(-\frac{v^2}{T_0}\right)\cos(k_xx) \]
</p>
<p>which evolves over a 2 dimensional domain defined by the dimensions \((x,v)\). The domain is \([0, 700]\times[-6,6]\). We can also consider the species s as a discrete dimension which is defined as [i, e].</p>
<p>The first thing which is necessary to define our system are types describing the continuous dimensions: </p><div class="fragment"><div class="line"><span class="comment">// Tag to represent the x-dimension</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structRDimX.html">RDimX</a> {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> constexpr <a class="code" href="structRDimX.html#a8cb720efb33235cee3371843279ea9ab">PERIODIC</a> = <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tag to represent the v-dimension</span></div>
<div class="line"><span class="keyword">struct </span><a class="code" href="structRDimVx.html">RDimVx</a> {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">bool</span> constexpr <a class="code" href="structRDimVx.html#a11bf97b66f066f6e9b062e8742f6cc78">PERIODIC</a> = <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="ttc" id="astructRDimVx_html"><div class="ttname"><a href="structRDimVx.html">RDimVx</a></div><div class="ttdoc">Define non periodic real X velocity dimension.</div><div class="ttdef"><b>Definition:</b> geometry.hpp:297</div></div>
<div class="ttc" id="astructRDimVx_html_a11bf97b66f066f6e9b062e8742f6cc78"><div class="ttname"><a href="structRDimVx.html#a11bf97b66f066f6e9b062e8742f6cc78">RDimVx::PERIODIC</a></div><div class="ttdeci">static constexpr bool PERIODIC</div><div class="ttdoc">Define periodicity of the dimension.</div><div class="ttdef"><b>Definition:</b> geometry.hpp:302</div></div>
<div class="ttc" id="astructRDimX_html"><div class="ttname"><a href="structRDimX.html">RDimX</a></div><div class="ttdoc">Define non periodic real X dimension.</div><div class="ttdef"><b>Definition:</b> geometry.hpp:274</div></div>
<div class="ttc" id="astructRDimX_html_a8cb720efb33235cee3371843279ea9ab"><div class="ttname"><a href="structRDimX.html#a8cb720efb33235cee3371843279ea9ab">RDimX::PERIODIC</a></div><div class="ttdeci">static constexpr bool PERIODIC</div><div class="ttdoc">Define periodicity of the dimension.</div><div class="ttdef"><b>Definition:</b> geometry.hpp:279</div></div>
</div><!-- fragment --><p>We also need types to define the discrete domain on which the simulation will evolve. The distribution function \(f_s(t,x,v)\) will evolve over the discrete domain \([i, e]\times[x_0,...,x_N]\times[v_0,...,v_{N_v}]\). Point samplings are required to define the positions of the grid points in each of the three dimensions:</p><ul>
<li>The object \([x_0,...,x_N]\) is defined with a point sampling and will be denoted \(IDimX\).</li>
<li>The object \([v_0,...,v_{N_v}]\) is defined with a point sampling and will be denoted \(IDimVx\).</li>
<li>The object \([&#39;i&#39;, &#39;e&#39;]\) is defined as a <code><a class="el" href="classSpeciesInformation.html" title="Species discrete dimension to access constant attributes related to species.">SpeciesInformation</a></code> collection and will be denoted \(IDimSp\).</li>
</ul>
<p>With these objects defined, the domain(s) can then be created. The domain for the distribution function has the type: <code>ddc::DiscreteDomain&lt;<a class="el" href="structIDimSp.html">IDimSp</a>, <a class="el" href="structIDimX.html">IDimX</a>, <a class="el" href="structIDimVx.html">IDimVx</a>&gt;</code> however for simplicity it is denoted <code>DomainSpXVx</code>. The electric potential \(\phi\) has a smaller domain with the type <code>ddc::DiscreteDomain&lt;<a class="el" href="structIDimX.html">IDimX</a>&gt;</code> denoted <code>DomainX</code>.</p>
<p>Other domains may be useful to work on slices of data or on subdomains (e.g. if we distribute our function using MPI).</p>
<p>The data itself will be stored in <code>ddc::Chunk</code>s. For example the distribution function will be stored in a <code>ddc::Chunk&lt;double, ddc::DiscreteDomain&lt;<a class="el" href="structIDimSp.html">IDimSp</a>, <a class="el" href="structIDimX.html">IDimX</a>, <a class="el" href="structIDimVx.html">IDimVx</a>&gt;&gt;</code>. To improve readability this type is denoted <code>DFieldSpXVx</code>. Similarly the electric potential will be stored in a <code>DFieldX</code>.</p>
<p>The other types will be useful when interacting with the data. For example, in order to initialise the distribution function we need to loop over the domain using the coordinates and a <code>ddc::DiscreteElement&lt;<a class="el" href="structIDimSp.html">IDimSp</a>, <a class="el" href="structIDimX.html">IDimX</a>, <a class="el" href="structIDimVx.html">IDimVx</a>&gt;</code> (denoted <code>IndexSpXVx</code> for simplicity) to fill the array: </p><div class="fragment"><div class="line">DomainSpXVx domain(..);</div>
<div class="line">DFieldSpXVx distribution_function(domain);</div>
<div class="line"> </div>
<div class="line">ddc::for_each(domain, [&amp;](IndexSpXVx index) {</div>
<div class="line">    CoordXVx coord = ddc::coordinate(ddc::select&lt;IDimX, IDimVx&gt;(index));</div>
<div class="line">    <span class="keywordtype">double</span> v_pos = ddc::get&lt;RDimVx&gt;(coord);</div>
<div class="line">    <span class="keywordtype">double</span> x_pos = ddc::get&lt;RDimX&gt;(coord);</div>
<div class="line">    distribution_function(index) = n0 / (2 * M_PI * T0) * exp(-v_pos * v_pos / T0) * cos(kx * x_pos);</div>
<div class="line">});</div>
</div><!-- fragment --><p><code>ddc::ChunkSpan</code> objects are required for function arguments. For example the prototype of the function which defines the electric potential would be: </p><div class="fragment"><div class="line">DSpanX operator()(DSpanX electric_potential, DViewSpXVx distribution_function);</div>
</div><!-- fragment --><p> where <code>DSpanX</code> is a reference to the <code>DFieldX</code> object where the electric potential is stored, and <code>DViewSpXVx</code> is a constant reference to the <code>DFieldSpXVx</code> object where the distribution function is stored.</p>
<h3><a class="anchor" id="autotoc_md12"></a>
Continuous vs. discrete objects</h3>
<p>The majority of the DDC types represent objects in or on a discrete vector space. It may not be immediately obvious why continous objects are also needed given that simulations are necessarily discrete. Backward semi-Lagrangian advection is a good example of where this is required. In backward semi-Lagrangian advection we work on a discrete grid (a <code>ddc::DiscreteDomain</code>), for each point of the grid we trace the characteristic to find where a particle positioned at this grid point would have been located at the previous time step. This location, known as the foot of the characteristic can be located anywhere in the vector space, unlike the grid points, the foot of the characteristic is not restricted to a subset of valid positions. It must therefore be represented with a continuous object. In this case a <code>ddc::Coordinate</code> perfectly describes the position of the foot of the characteristic while also providing all pertinent information about the dimensions.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Example use of DiscreteVector for Finite Differences</h3>
<p>The class <code>ddc::DiscreteVector</code> is particularly useful in cases where we wish to express a stencil. Let us consider the case of a 2D finite differences scheme on uniform meshes expressed as follows: </p><p class="formulaDsp">
\[ \nabla^2 f(x,y) = \frac{f(x-h_x, y) + f(x+h_x, y) + f(x, y-h_y) + f(x, y+h_y) - 4f(x,y)}{h_x h_y} \]
</p>
<p>This code can be written simply using <code>ddc::DiscreteElement</code> and <code>ddc::DiscreteVector</code>: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> get_laplacian_at_position(DFieldXY function_values, IndexXY position)</div>
<div class="line">{</div>
<div class="line">    VectX x_step(1);</div>
<div class="line">    VectY y_step(1);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Get the uniform point sampling in the appropriate direction and use it to</span></div>
<div class="line">    <span class="comment">// extract the step h.</span></div>
<div class="line">    <span class="keywordtype">double</span> h_x = ddc::discrete_space&lt;RDimX&gt;().step();</div>
<div class="line">    <span class="keywordtype">double</span> h_y = ddc::discrete_space&lt;RDimY&gt;().step();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> (function_values(position - x_step) + function_values(position + x_step)</div>
<div class="line">            + function_values(position - y_step) function_values(position + y_step)</div>
<div class="line">            - 4 * function_values(position))</div>
<div class="line">           / (h_x * h_y);</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you can see DDC takes care of combining elements and vectors to ensure that the resulting <code>IndexXY</code> is in the correct position. This makes it simpler to write such stencils and easier to spot errors, especially in cases involving lots of dimensions.</p>
<h1><a class="anchor" id="docs_DDC_in_gyselalibxx__Pitfalls"></a>
Pitfalls</h1>
<p>When using DDC there are some things that you should be careful about. These are listed here.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Synchronicity</h3>
<p>In DDC and Kokkos the code runs asynchronously when an execution space is provided. When no execution space is provided the code runs synchronously surrounded by fences. In order to ensure that there is no danger coming from the asynchronicity we need to follow certain rules. In Gysela the chosen conventions are:</p><ul>
<li>Always provide an execution space to <code>ddc::parallel_for_each</code> or <code>ddc::parallel_transform_reduce</code> (or similar Kokkos functions).</li>
<li>Only provide an execution space to <code>create_mirror_view_and_copy</code> when this is unavoidable (i.e. when copying to the <code>DefaultExecutionSpace</code>). The <code>DefaultHostExecutionSpace</code> should never be passed to <code>create_mirror_view_and_copy</code>. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
