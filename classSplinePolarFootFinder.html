<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gyselalib++: SplinePolarFootFinder&lt; TimeStepper, LogicalToPhysicalMapping, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gyselalib++
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classSplinePolarFootFinder.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classSplinePolarFootFinder-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SplinePolarFootFinder&lt; TimeStepper, LogicalToPhysicalMapping, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class to find the foot of the characteristics on the \( (r,\theta) \) plane.  
 <a href="classSplinePolarFootFinder.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for SplinePolarFootFinder&lt; TimeStepper, LogicalToPhysicalMapping, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSplinePolarFootFinder.png" usemap="#SplinePolarFootFinder_3C_20TimeStepper_2C_20LogicalToPhysicalMapping_2C_20LogicalToPseudoPhysicalMapping_2C_20SplineRThetaBuilder_5Fhost_2C_20SplineRThetaEvaluatorConstBound_5Fhost_20_3E_map" alt=""/>
  <map id="SplinePolarFootFinder_3C_20TimeStepper_2C_20LogicalToPhysicalMapping_2C_20LogicalToPseudoPhysicalMapping_2C_20SplineRThetaBuilder_5Fhost_2C_20SplineRThetaEvaluatorConstBound_5Fhost_20_3E_map" name="SplinePolarFootFinder_3C_20TimeStepper_2C_20LogicalToPhysicalMapping_2C_20LogicalToPseudoPhysicalMapping_2C_20SplineRThetaBuilder_5Fhost_2C_20SplineRThetaEvaluatorConstBound_5Fhost_20_3E_map">
<area href="classIPolarFootFinder.html" alt="IPolarFootFinder&lt; SplineRThetaBuilder_host::interpolation_discrete_dimension_type1, SplineRThetaBuilder_host::interpolation_discrete_dimension_type2, LogicalToPhysicalMapping::cartesian_tag_x, LogicalToPhysicalMapping::cartesian_tag_y, SplineRThetaBuilder_host::memory_space &gt;" shape="rect" coords="0,0,1641,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9935580191e75e2439f67ec7d3adbbb0" id="r_a9935580191e75e2439f67ec7d3adbbb0"><td class="memTemplParams" colspan="2"><a id="a9935580191e75e2439f67ec7d3adbbb0" name="a9935580191e75e2439f67ec7d3adbbb0"></a>
template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:a9935580191e75e2439f67ec7d3adbbb0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FieldRTheta</b> = Field&lt; ElementType, IdxRangeRTheta, memory_space &gt;</td></tr>
<tr class="memdesc:a9935580191e75e2439f67ec7d3adbbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a field on the polar plane on a compatible memory space. <br /></td></tr>
<tr class="separator:a9935580191e75e2439f67ec7d3adbbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa849e5fd2467cdd1f6f66c2f54087652" id="r_aa849e5fd2467cdd1f6f66c2f54087652"><td class="memTemplParams" colspan="2"><a id="aa849e5fd2467cdd1f6f66c2f54087652" name="aa849e5fd2467cdd1f6f66c2f54087652"></a>
template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:aa849e5fd2467cdd1f6f66c2f54087652"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstFieldRTheta</b> = ConstField&lt; ElementType, IdxRangeRTheta, memory_space &gt;</td></tr>
<tr class="memdesc:aa849e5fd2467cdd1f6f66c2f54087652"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a constant field on the polar plane on a compatible memory space. <br /></td></tr>
<tr class="separator:aa849e5fd2467cdd1f6f66c2f54087652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c30b15524539821a2f7367a7ba1770" id="r_a80c30b15524539821a2f7367a7ba1770"><td class="memTemplParams" colspan="2"><a id="a80c30b15524539821a2f7367a7ba1770" name="a80c30b15524539821a2f7367a7ba1770"></a>
template&lt;class Dim1 , class Dim2 &gt; </td></tr>
<tr class="memitem:a80c30b15524539821a2f7367a7ba1770"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DVectorFieldRTheta</b> = <a class="el" href="classVectorField.html">VectorField</a>&lt; double, IdxRangeRTheta, NDTag&lt; Dim1, Dim2 &gt;, memory_space &gt;</td></tr>
<tr class="memdesc:a80c30b15524539821a2f7367a7ba1770"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a vector (x,y) field on the polar plane on a compatible memory space. <br /></td></tr>
<tr class="separator:a80c30b15524539821a2f7367a7ba1770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5474c741a91ef184789f004915e73b" id="r_abe5474c741a91ef184789f004915e73b"><td class="memTemplParams" colspan="2"><a id="abe5474c741a91ef184789f004915e73b" name="abe5474c741a91ef184789f004915e73b"></a>
template&lt;class Dim1 , class Dim2 &gt; </td></tr>
<tr class="memitem:abe5474c741a91ef184789f004915e73b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>DVectorConstFieldRTheta</b> = <a class="el" href="classVectorField.html">VectorConstField</a>&lt; double, IdxRangeRTheta, NDTag&lt; Dim1, Dim2 &gt;, memory_space &gt;</td></tr>
<tr class="memdesc:abe5474c741a91ef184789f004915e73b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a constant vector (x,y) field on the polar plane on a compatible memory space. <br /></td></tr>
<tr class="separator:abe5474c741a91ef184789f004915e73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c90562ced83f5d247433653ec06b7f" id="r_a85c90562ced83f5d247433653ec06b7f"><td class="memTemplParams" colspan="2"><a id="a85c90562ced83f5d247433653ec06b7f" name="a85c90562ced83f5d247433653ec06b7f"></a>
template&lt;class Dim1 , class Dim2 &gt; </td></tr>
<tr class="memitem:a85c90562ced83f5d247433653ec06b7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>VectorSplineCoeffsMem2D</b> = <a class="el" href="classVectorFieldMem.html">VectorFieldMem</a>&lt; double, IdxRange&lt; <a class="el" href="structBSplinesR.html">BSplinesR</a>, <a class="el" href="structBSplinesTheta.html">BSplinesTheta</a> &gt;, NDTag&lt; Dim1, Dim2 &gt;, memory_space &gt;</td></tr>
<tr class="memdesc:a85c90562ced83f5d247433653ec06b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of 2 splines representing the x and y components of a vector on the polar plane on a compatible memory space. <br /></td></tr>
<tr class="separator:a85c90562ced83f5d247433653ec06b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a92214a07f60f5a24b1a358b65ad88706" id="r_a92214a07f60f5a24b1a358b65ad88706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSplinePolarFootFinder.html#a92214a07f60f5a24b1a358b65ad88706">SplinePolarFootFinder</a> (TimeStepper const &amp;time_stepper, <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> const &amp;logical_to_physical_mapping, LogicalToPseudoPhysicalMapping const &amp;logical_to_pseudo_physical_mapping, SplineRThetaBuilder_host const &amp;builder_advection_field, SplineRThetaEvaluatorConstBound_host const &amp;evaluator_advection_field, double epsilon=1e-12)</td></tr>
<tr class="memdesc:a92214a07f60f5a24b1a358b65ad88706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a time integration method for the advection operator.  <br /></td></tr>
<tr class="separator:a92214a07f60f5a24b1a358b65ad88706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd16196329b51e46790d8f0f259b2e6" id="r_acbd16196329b51e46790d8f0f259b2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSplinePolarFootFinder.html#acbd16196329b51e46790d8f0f259b2e6">operator()</a> (<a class="el" href="classSplinePolarFootFinder.html#a9935580191e75e2439f67ec7d3adbbb0">FieldRTheta</a>&lt; CoordRTheta &gt; feet, <a class="el" href="classSplinePolarFootFinder.html#abe5474c741a91ef184789f004915e73b">DVectorConstFieldRTheta</a>&lt; <a class="el" href="structX.html">X</a>, <a class="el" href="structY.html">Y</a> &gt; advection_field, double dt) const final</td></tr>
<tr class="memdesc:acbd16196329b51e46790d8f0f259b2e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advect the feet over \( dt \).  <br /></td></tr>
<tr class="separator:acbd16196329b51e46790d8f0f259b2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb354561c53fb385fb8979ab2af8fbd1" id="r_adb354561c53fb385fb8979ab2af8fbd1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structT.html">T</a> &gt; </td></tr>
<tr class="memitem:adb354561c53fb385fb8979ab2af8fbd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSplinePolarFootFinder.html#adb354561c53fb385fb8979ab2af8fbd1">is_unified</a> (Field&lt; <a class="el" href="structT.html">T</a>, IdxRangeRTheta, memory_space &gt; const &amp;values) const</td></tr>
<tr class="memdesc:adb354561c53fb385fb8979ab2af8fbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the values at the center point are the same.  <br /></td></tr>
<tr class="separator:adb354561c53fb385fb8979ab2af8fbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8386efbc3f8042a2804e6a79ff952770" id="r_a8386efbc3f8042a2804e6a79ff952770"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="structT.html">T</a> &gt; </td></tr>
<tr class="memitem:a8386efbc3f8042a2804e6a79ff952770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSplinePolarFootFinder.html#a8386efbc3f8042a2804e6a79ff952770">unify_value_at_center_pt</a> (Field&lt; <a class="el" href="structT.html">T</a>, IdxRangeRTheta, memory_space &gt; values) const</td></tr>
<tr class="memdesc:a8386efbc3f8042a2804e6a79ff952770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the value at \(  (r=0, \theta)\) point by the value at \( (r=0,0) \) for all \( \theta \).  <br /></td></tr>
<tr class="separator:a8386efbc3f8042a2804e6a79ff952770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classIPolarFootFinder"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classIPolarFootFinder')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classIPolarFootFinder.html">IPolarFootFinder&lt; SplineRThetaBuilder_host::interpolation_discrete_dimension_type1, SplineRThetaBuilder_host::interpolation_discrete_dimension_type2, LogicalToPhysicalMapping::cartesian_tag_x, LogicalToPhysicalMapping::cartesian_tag_y, SplineRThetaBuilder_host::memory_space &gt;</a></td></tr>
<tr class="memitem:a75b9147187aa2f0c25e498fb90eb3568 inherit pub_methods_classIPolarFootFinder" id="r_a75b9147187aa2f0c25e498fb90eb3568"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIPolarFootFinder.html#a75b9147187aa2f0c25e498fb90eb3568">operator()</a> (Field&lt; Coord&lt; <a class="el" href="classIPolarFootFinder.html#af9711742eb727888074230330e13e782">R</a>, <a class="el" href="classIPolarFootFinder.html#ae129c706b58ecf5657c02fcc9969add3">Theta</a> &gt;, <a class="el" href="classIPolarFootFinder.html#a1aa0c6d201b38fab9b2e45a73981dfb1">IdxRangeRTheta</a>, <a class="el" href="classIPolarFootFinder.html#a490b586b89c6841213df78e60e51b824">memory_space</a> &gt; feet, <a class="el" href="classVectorField.html">DVectorConstField</a>&lt; <a class="el" href="classIPolarFootFinder.html#a1aa0c6d201b38fab9b2e45a73981dfb1">IdxRangeRTheta</a>, NDTag&lt; <a class="el" href="classIPolarFootFinder.html#aad57064cce5dd59aabb33fc778f42010">X</a>, <a class="el" href="classIPolarFootFinder.html#a8950c7d66868672cff1dd4675874efb3">Y</a> &gt;, <a class="el" href="classIPolarFootFinder.html#a490b586b89c6841213df78e60e51b824">memory_space</a> &gt; advection_field, double dt) const=0</td></tr>
<tr class="memdesc:a75b9147187aa2f0c25e498fb90eb3568 inherit pub_methods_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advect the feet over \( dt \).  <br /></td></tr>
<tr class="separator:a75b9147187aa2f0c25e498fb90eb3568 inherit pub_methods_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classIPolarFootFinder"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classIPolarFootFinder')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classIPolarFootFinder.html">IPolarFootFinder&lt; SplineRThetaBuilder_host::interpolation_discrete_dimension_type1, SplineRThetaBuilder_host::interpolation_discrete_dimension_type2, LogicalToPhysicalMapping::cartesian_tag_x, LogicalToPhysicalMapping::cartesian_tag_y, SplineRThetaBuilder_host::memory_space &gt;</a></td></tr>
<tr class="memitem:a90af5e545602e06dc6d8b0fd86399bb3 inherit pro_types_classIPolarFootFinder" id="r_a90af5e545602e06dc6d8b0fd86399bb3"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>GridR</b> = SplineRThetaBuilder_host::interpolation_discrete_dimension_type1</td></tr>
<tr class="memdesc:a90af5e545602e06dc6d8b0fd86399bb3 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous radial dimension. <br /></td></tr>
<tr class="separator:a90af5e545602e06dc6d8b0fd86399bb3 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579ff11bd08281036e353000ec2e3c39 inherit pro_types_classIPolarFootFinder" id="r_a579ff11bd08281036e353000ec2e3c39"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>GridTheta</b> = SplineRThetaBuilder_host::interpolation_discrete_dimension_type2</td></tr>
<tr class="memdesc:a579ff11bd08281036e353000ec2e3c39 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous poloidal dimension. <br /></td></tr>
<tr class="separator:a579ff11bd08281036e353000ec2e3c39 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9711742eb727888074230330e13e782 inherit pro_types_classIPolarFootFinder" id="r_af9711742eb727888074230330e13e782"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>R</b> = typename GridR::continuous_dimension_type</td></tr>
<tr class="memdesc:af9711742eb727888074230330e13e782 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous radial dimension. <br /></td></tr>
<tr class="separator:af9711742eb727888074230330e13e782 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae129c706b58ecf5657c02fcc9969add3 inherit pro_types_classIPolarFootFinder" id="r_ae129c706b58ecf5657c02fcc9969add3"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>Theta</b> = typename GridTheta::continuous_dimension_type</td></tr>
<tr class="memdesc:ae129c706b58ecf5657c02fcc9969add3 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous poloidal dimension. <br /></td></tr>
<tr class="separator:ae129c706b58ecf5657c02fcc9969add3 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad57064cce5dd59aabb33fc778f42010 inherit pro_types_classIPolarFootFinder" id="r_aad57064cce5dd59aabb33fc778f42010"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>X</b> = <a class="el" href="classCircularToCartesian.html#a5da224f282c0518de1eb5f9533ef8382">LogicalToPhysicalMapping::cartesian_tag_x</a></td></tr>
<tr class="memdesc:aad57064cce5dd59aabb33fc778f42010 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous radial dimension. <br /></td></tr>
<tr class="separator:aad57064cce5dd59aabb33fc778f42010 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8950c7d66868672cff1dd4675874efb3 inherit pro_types_classIPolarFootFinder" id="r_a8950c7d66868672cff1dd4675874efb3"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b> = <a class="el" href="classCircularToCartesian.html#ac5171ea2a53d148012365e778c790726">LogicalToPhysicalMapping::cartesian_tag_y</a></td></tr>
<tr class="memdesc:a8950c7d66868672cff1dd4675874efb3 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The continuous poloidal dimension. <br /></td></tr>
<tr class="separator:a8950c7d66868672cff1dd4675874efb3 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490b586b89c6841213df78e60e51b824 inherit pro_types_classIPolarFootFinder" id="r_a490b586b89c6841213df78e60e51b824"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>memory_space</b> = SplineRThetaBuilder_host::memory_space</td></tr>
<tr class="memdesc:a490b586b89c6841213df78e60e51b824 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the memory space where the field is saved (CPU vs GPU). <br /></td></tr>
<tr class="separator:a490b586b89c6841213df78e60e51b824 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa0c6d201b38fab9b2e45a73981dfb1 inherit pro_types_classIPolarFootFinder" id="r_a1aa0c6d201b38fab9b2e45a73981dfb1"><td class="memItemLeft" align="right" valign="top">
using&#160;</td><td class="memItemRight" valign="bottom"><b>IdxRangeRTheta</b> = IdxRange&lt; <a class="el" href="classIPolarFootFinder.html#a90af5e545602e06dc6d8b0fd86399bb3">GridR</a>, <a class="el" href="classIPolarFootFinder.html#a579ff11bd08281036e353000ec2e3c39">GridTheta</a> &gt;</td></tr>
<tr class="memdesc:a1aa0c6d201b38fab9b2e45a73981dfb1 inherit pro_types_classIPolarFootFinder"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the index range over which the operator works. <br /></td></tr>
<tr class="separator:a1aa0c6d201b38fab9b2e45a73981dfb1 inherit pro_types_classIPolarFootFinder"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class TimeStepper, class <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a>, class LogicalToPseudoPhysicalMapping, class SplineRThetaBuilder_host, class SplineRThetaEvaluatorConstBound_host&gt;<br />
class SplinePolarFootFinder&lt; TimeStepper, LogicalToPhysicalMapping, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;</div><p>A class to find the foot of the characteristics on the \( (r,\theta) \) plane. </p>
<p>The natural advection domain is the physical domain, where the studied equation is given. However, not all the mappings used are analytically invertible and inverting the Jacobian matrix of the mapping could be costly and could introduce numerical errors. That is why, we also introduce a pseudo-Cartesian domain.</p>
<p>More details can be found in Edoardo Zoni's article (<a href="https://doi.org/10.1016/j.jcp.2019.108889">https://doi.org/10.1016/j.jcp.2019.108889</a>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TimeStepper</td><td>A child class of <a class="el" href="classITimeStepper.html" title="The superclass from which all timestepping methods inherit.">ITimeStepper</a> providing a time integration method. </td></tr>
    <tr><td class="paramname">LogicalToPhysicalMapping</td><td>A mapping from the logical domain to the physical domain. </td></tr>
    <tr><td class="paramname">LogicalToPseudoPhysicalMapping</td><td>A mapping from the logical domain to the domain where the advection is carried out. This may be a pseudo-physical domain or the physical domain itself. </td></tr>
    <tr><td class="paramname">SplineRThetaBuilder_host</td><td>A 2D SplineBuilder to construct a spline on a polar domain. The code is written generally to handle any builder but only a host builder has been tested for now. Use the GPU version at your own peril until this class has been officially ported. </td></tr>
    <tr><td class="paramname">SplineRThetaEvaluatorConstBound_host</td><td>A 2D SplineEvaluator to evaluate a spline on a polar domain. A boundary condition must be provided in case the foot of the characteristic is found outside the domain. The code is written generally to handle any evaluator but only a host evaluator has been tested for now. Use the GPU version at your own peril until this class has been officially ported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classBslAdvectionRTheta.html" title="Define an advection operator on 2D  index range.">BslAdvectionRTheta</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a92214a07f60f5a24b1a358b65ad88706" name="a92214a07f60f5a24b1a358b65ad88706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92214a07f60f5a24b1a358b65ad88706">&#9670;&#160;</a></span>SplinePolarFootFinder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TimeStepper , class <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> , class LogicalToPseudoPhysicalMapping , class SplineRThetaBuilder_host , class SplineRThetaEvaluatorConstBound_host &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSplinePolarFootFinder.html">SplinePolarFootFinder</a>&lt; TimeStepper, <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a>, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;<a class="el" href="classSplinePolarFootFinder.html">::SplinePolarFootFinder</a> </td>
          <td>(</td>
          <td class="paramtype">TimeStepper const &amp;&#160;</td>
          <td class="paramname"><em>time_stepper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> const &amp;&#160;</td>
          <td class="paramname"><em>logical_to_physical_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LogicalToPseudoPhysicalMapping const &amp;&#160;</td>
          <td class="paramname"><em>logical_to_pseudo_physical_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplineRThetaBuilder_host const &amp;&#160;</td>
          <td class="paramname"><em>builder_advection_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SplineRThetaEvaluatorConstBound_host const &amp;&#160;</td>
          <td class="paramname"><em>evaluator_advection_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiate a time integration method for the advection operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">time_stepper</td><td>The time integration method used to solve the characteristic equation (<a class="el" href="classITimeStepper.html" title="The superclass from which all timestepping methods inherit.">ITimeStepper</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_to_physical_mapping</td><td>The mapping from the logical domain to the physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">logical_to_pseudo_physical_mapping</td><td>The mapping from the logical domain to the pseudo-physical domain. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">builder_advection_field</td><td>The spline builder which computes the spline representation of the advection field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">evaluator_advection_field</td><td>The B-splines evaluator to evaluate the advection field. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">epsilon</td><td>\( \varepsilon \) parameter used for the linearization of the advection field around the central point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classITimeStepper.html" title="The superclass from which all timestepping methods inherit.">ITimeStepper</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acbd16196329b51e46790d8f0f259b2e6" name="acbd16196329b51e46790d8f0f259b2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd16196329b51e46790d8f0f259b2e6">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TimeStepper , class <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> , class LogicalToPseudoPhysicalMapping , class SplineRThetaBuilder_host , class SplineRThetaEvaluatorConstBound_host &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSplinePolarFootFinder.html">SplinePolarFootFinder</a>&lt; TimeStepper, <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a>, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSplinePolarFootFinder.html#a9935580191e75e2439f67ec7d3adbbb0">FieldRTheta</a>&lt; CoordRTheta &gt;&#160;</td>
          <td class="paramname"><em>feet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSplinePolarFootFinder.html#abe5474c741a91ef184789f004915e73b">DVectorConstFieldRTheta</a>&lt; <a class="el" href="structX.html">X</a>, <a class="el" href="structY.html">Y</a> &gt;&#160;</td>
          <td class="paramname"><em>advection_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advect the feet over \( dt \). </p>
<p>From the advection field in the physical index range, compute the advection field in the right index range an compute its B-splines coefficients. Then, use the given time integration method (time_stepper) to solve the characteristic equation over \( dt \).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">feet</td><td>On input: the mesh points. On output: the characteristic feet. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">advection_field</td><td>The advection field in the physical index range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>The time step. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb354561c53fb385fb8979ab2af8fbd1" name="adb354561c53fb385fb8979ab2af8fbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb354561c53fb385fb8979ab2af8fbd1">&#9670;&#160;</a></span>is_unified()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TimeStepper , class <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> , class LogicalToPseudoPhysicalMapping , class SplineRThetaBuilder_host , class SplineRThetaEvaluatorConstBound_host &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="structT.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSplinePolarFootFinder.html">SplinePolarFootFinder</a>&lt; TimeStepper, <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a>, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;::is_unified </td>
          <td>(</td>
          <td class="paramtype">Field&lt; <a class="el" href="structT.html">T</a>, IdxRangeRTheta, memory_space &gt; const &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the values at the center point are the same. </p>
<p>For polar geometry, to ensure continuity at the center point, we have to be sure that all the points for \( r = 0 \) have the same value. This function check if for \( r= 0 \), the values \( \forall \theta \) are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>A table of values we want to check if the center point has an unique value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8386efbc3f8042a2804e6a79ff952770" name="a8386efbc3f8042a2804e6a79ff952770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8386efbc3f8042a2804e6a79ff952770">&#9670;&#160;</a></span>unify_value_at_center_pt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TimeStepper , class <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a> , class LogicalToPseudoPhysicalMapping , class SplineRThetaBuilder_host , class SplineRThetaEvaluatorConstBound_host &gt; </div>
<div class="memtemplate">
template&lt;class <a class="el" href="structT.html">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSplinePolarFootFinder.html">SplinePolarFootFinder</a>&lt; TimeStepper, <a class="el" href="classCircularToCartesian.html">LogicalToPhysicalMapping</a>, LogicalToPseudoPhysicalMapping, SplineRThetaBuilder_host, SplineRThetaEvaluatorConstBound_host &gt;::unify_value_at_center_pt </td>
          <td>(</td>
          <td class="paramtype">Field&lt; <a class="el" href="structT.html">T</a>, IdxRangeRTheta, memory_space &gt;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the value at \(  (r=0, \theta)\) point by the value at \( (r=0,0) \) for all \( \theta \). </p>
<p>For polar geometry, to ensure continuity at the center point, we have to be sure that all the points for \( r = 0 \) have the same value. As the computation of the values of a table can induces machine errors, this function is useful to reset the values at the central point at the same value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">values</td><td>The table of values we want to unify at the central point. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/advection/<a class="el" href="spline__polar__foot__finder_8hpp_source.html">spline_polar_foot_finder.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classSplinePolarFootFinder.html">SplinePolarFootFinder</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
