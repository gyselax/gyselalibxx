<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gyselalib++: Multipatch connectivity</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">Gyselalib++
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('src_multipatch_connectivity.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Multipatch connectivity</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory defines structures and methods to describe patches and how they are connected to one another.</p>
<p>The following sections decribe the structures and methods implemented:</p>
<ul>
<li><a class="el" href="src_multipatch_connectivity.html#src_multipatch_connectivity__Patch">Patch</a> - Definition of <a class="el" href="structPatch.html" title="Base tag for a patch.">Patch</a> tag.</li>
<li><a class="el" href="src_multipatch_connectivity.html#src_multipatch_connectivity__Interfaces">Interfaces</a><ul>
<li>Sticking of Two Edges<ul>
<li>Multi-patch domain - Mathematical definition of multi-patch domain.</li>
<li>Edges - Mathematical defintion of edges.</li>
<li>Sticking and Coordinate Transformation - Mathematical defintion of coordinate transformation and links to the implemented class (<a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a>, <a class="el" href="structEdge.html" title="Define an edge of a given patch.">Edge</a> and <a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a>).</li>
<li>Index transformation - Algorithm of the index transformation in <a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a>.</li>
<li>Conformity of the meshes - Definition of <code>UniformGridIdxMatching</code>.</li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="src_multipatch_connectivity.html#src_multipatch_connectivity__Patch_locator">Patch locator</a> - Definition of patch locator operators to identify the patch where a given physical coordinate is.<ul>
<li>Onion shape geometry - Definition of <code><a class="el" href="classOnionPatchLocator.html" title="Patch locator specialised for &quot;onion&quot; geometry.">OnionPatchLocator</a></code>, a specialisation of <code>IPatchLocator</code> for "onion" shape geometries. <br  />
</li>
</ul>
</li>
<li><a class="el" href="src_multipatch_connectivity.html#src_multipatch_connectivity__References">References</a> - References.</li>
<li><a class="el" href="src_multipatch_connectivity.html#src_multipatch_connectivity__Contents">Contents</a> - List of files in the folder.</li>
</ul>
<h1><a class="anchor" id="src_multipatch_connectivity__Patch"></a>
Patch</h1>
<p>The tag <a class="el" href="structPatch.html" title="Base tag for a patch.">Patch</a> refers to a single 2D patch geometry. The tag contains aliases (or shortcuts) to the DDC geometry elements, such as:</p>
<ul>
<li>Grids (or points sequence along one dimension) on both dimensions (<code>Grid1</code> and <code>Grid2</code>); <br  />
</li>
<li>Associated continuous dimensions (<code>Dim1</code> and <code>Dim2</code>); <br  />
</li>
<li>Dimensions for B-splines coefficients (<code>Bsplines1</code> and <code>Bsplines2</code>); <br  />
</li>
<li>Coordinates of objects represented on the dimensions (<code>Coord1</code>, <code>Coord2</code> and <code>Coord12</code>); <br  />
</li>
<li>The type which describes the index of a grid point (e.g. <code>Idx1</code>); <br  />
</li>
<li>The type which describes a distance between grid points (e.g. <code>IdxStep1</code>);</li>
<li>The type which describes the index range of a grid (e.g. <code>IdxRange1</code>).</li>
<li>The type which describes the index range of a spline coefficients grid (e.g. <code>BSIdxRange1</code>).</li>
</ul>
<p>The domain defined on this patch is called <em>logical domain</em>.</p>
<h1><a class="anchor" id="src_multipatch_connectivity__Interfaces"></a>
Interfaces</h1>
<h3><a class="anchor" id="autotoc_md73"></a>
Sticking of Two Edges</h3>
<p>We follow the idea to represent the topology of a multipatch domain using the idea of <em>domain manifolds</em> (see [1]). This means that we have several independent tensor-product logical domains and define their sticking via coordinate transformations.</p>
<p><b>Remark:</b> In the referenced paper, the authors use affine isometries of the entire patch instead of coordinate transformations of the faces. This is equivalent to our approach in the sense that, when the scaling of the domains is removed and we consider only unit squares as logical domains, the coordinate transformations of the faces and the information about which edges are identified determine the isometries used in the paper and vice versa. This is easy to show.</p>
<h4><a class="anchor" id="autotoc_md74"></a>
Multi-patch domain</h4>
<p>For simplicity, we will constrain ourselves to the 2D case, but this approach could be generalized to arbitrary dimensions.</p>
<p>Let \(\Omega\) be the domain of interest and assume that we have patches \(\Omega^{(i)}\), \(i=1,...,K\), which are disjoint, s.t.  </p><p class="formulaDsp">
\[\Omega = \dot{\bigcup}_{i=1}^K \Omega^{(i)}.
\]
</p>
<p> For every patch \(\Omega^{(i)}\) we have a mapping  </p><p class="formulaDsp">
\[F^{(i)}: [a_x^{(i)}, b_x^{(i)}]\times[a_y^{(i)} b_y^{(i)}] \rightarrow \Omega^{(i)}, 
\]
</p>
<p> where the rectangular domain \([a_x^{(i)}, b_x^{(i)}]\times[a_y^{(i)} b_y^{(i)}]\) defines the logical coordinates for the patch. We call this logical coordinate domain the <em>logical patch</em>.</p>
<h4><a class="anchor" id="autotoc_md75"></a>
Edges</h4>
<p>So we obtain four logical edges  </p><p class="formulaDsp">
\[[a_x^{(i)}, b_x^{(i)}] \times \{ a_y^{(i)} \}, \quad
[a_x^{(i)}, b_x^{(i)}] \times \{ b_y^{(i)} \}, \quad
\{ a_x^{(i)} \} \times [a_y^{(i)}, b_y^{(i)}], \quad
\{ b_x^{(i)} \} \times [a_y^{(i)}, b_y^{(i)}] 
\]
</p>
<p> In the code, we define edges as follows. Every edge of a logical patch is identified via the patch it belongs to, the dimension and whether it is at the front or the back of the domain. So e.g.the edge \([a_x^{(i)}, b_x^{(i)}] \times \{ a_y^{(i)} \}\) would be identified with patch \(i\), dimensions <code>Yi</code> and <code>FRONT</code>. \([a_x^{(i)}, b_x^{(i)}] \times \{ b_y^{(i)} \}\) would be identified with patch \(i\), dimensions <code>Yi</code> and <code>BACK</code> and \(\{ b_x^{(i)} \} \times [a_y^{(i)}, b_y^{(i)}]\) would be identified with patch \(i\), dimensions <code>Xi</code> and <code>BACK</code>.</p>
<h4><a class="anchor" id="autotoc_md76"></a>
Sticking and Coordinate Transformation</h4>
<p>Any edge can then be associated with an edge on another patch. This corresponds to the 'sticking'. So for a different patch \(\Omega^{(j)}\), we have the logical coordinate domain \([a_x^{(j)}, b_x^{(j)}] \times [a_y^{(j)} b_y^{(j)}]\). If we want to stick patch \(i\) to patch \(j\), we have to determine the edges that are identified and how they are identified. The way that they are identified is mathematically determined via the coordinate transformation from one edge to the other. Since the transformations are supposed to be affine and bijective, there are only two options: the transformation can be order preserving or order reversing (this corresponds to the orientation of the phyiscal edge where two parametrizations coming from the two patches can have either the same or the opposite orientation respectively).</p>
<p>So for example, we want to stick the edge \(\{ a_x^{(i)} \} \times [a_y^{(i)}, b_y^{(i)}]\) on patch \(i\) to the edge \([a_x^{(j)}, b_x^{(j)}] \times \{ b_y^{(j)} \}\) on patch \(j\). If the transformation is order-preserving (i.e. the orientations of the parametrizations of the physical edge agree), then the transformation from the first edge to the second is  </p><p class="formulaDsp">
\[t \mapsto a_x^{(j)} + \frac{t - a_y^{(i)}}{b_y^{(i)} - a_y^{(i)}} \, (b_x^{(j)} - a_x^{(j)}).
\]
</p>
<p> If the transformation is order-reversing (i.e. the orientations of the parametrizations of the physical edge are opposite), then it is  </p><p class="formulaDsp">
\[t \mapsto b_x^{(j)} - \frac{t - a_y^{(i)}}{b_y^{(i)} - a_y^{(i)}} \, (b_x^{(j)} - a_x^{(j)}).
\]
</p>
<p>In the code, an edge is represented by the <code><a class="el" href="structEdge.html" title="Define an edge of a given patch.">Edge</a></code> structure. The sticking of two edges is represented by an <code><a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a></code> structure which contains tags to the first patch and the second patch as well as the boolean member <code>orientations_agree</code>. The transformation from one edge to the other is done using the <code><a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a></code> operator.</p>
<p>This operator contains an <code>operator()</code> to transform a given coordinate on a coordinate on the other patch. It has also been extended for indices.</p>
<h4><a class="anchor" id="autotoc_md77"></a>
Index transformation</h4>
<p>All the patches are discretized into a finite number of points indexed by indices. So each index refers to a coordinate on a patch. For a given index on an edge of a patch at the interface, we can find an equivalent index on the other patch. This is always true for conforming meshes but not always the case for non-conforming meshes.</p>
<p>For non-conforming meshes, the method <code>is_match_available()</code> is needed to identify if the given index has an equivalent or not. If <code>is_match_available()</code> returns true, we can then call the <code>operator()</code> to get the equivalent index on the other patch. Instead of calling both method, it is also possible to call <code>search_for_match()</code> which returns true if there is an equivalent index and updates it the given target index.</p>
<p><b>For uniform grids</b> \(\{x_i\}_{i=0, ..., N}\) (current grid) and \(\{x_j\}_{j=0, ..., M}\) (target grid), finding an equivalent index can be done with the following steps:</p>
<ul>
<li>We compute the greatest common divisor of the number of cells \(N\) and \(M\) (e.g. \(\exists \ gcd \in\mathbb{N}, gcd&gt;1; \ M \wedge N = gcd\)).</li>
<li>The current index \(k\) can have an equivalent index on the target patch.</li>
</ul>
<p>Depending on if \(k / p \in \mathbb{N}^*\) with \(p = \frac{N}{gcd} \in \mathbb{N}^*\), this equivalent is given by multiplying by \(\frac{M}{N}\) and adapt if the coordinate transformation is not order-preserving.</p>
<ul>
<li>If the greatest common divisor is \(1\), there is no equivalent index except for the first and last indices.</li>
</ul>
<p><b>For non-uniform grids</b>, we cannot use this algorithm. We check all the indices of the target patch if one of them fit with the current one. We can use dichotomy method for the search.</p>
<h4><a class="anchor" id="autotoc_md78"></a>
Conformity of the meshes</h4>
<p>When there are non-conforming meshes, some operators need to loop on the "conforming indexes" at each <a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a>, i.e. the indexes with an equivalent index on the other patch of the interface.</p>
<p>The <code>UniformIdxStepIndexMatching</code> storage class stores for a given <a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a> the "conforming indexes" in an <a class="el" href="classIdxRangeSlice.html" title="A class which describes a collection of equally spaced Idxs which form a index range.">IdxRangeSlice</a> for each patch. Currently, the <a class="el" href="classIdxRangeSlice.html" title="A class which describes a collection of equally spaced Idxs which form a index range.">IdxRangeSlice</a> stores indexes from an IdxRange with regular index steps. So the <code>UniformIdxStepIndexMatching</code> class does the same, and triggers assert when the conformity between two edges is not uniform.</p>
<p>For example, <code>UniformIdxStepIndexMatching</code> is adapted to this type of interface </p><div class="fragment"><div class="line">0   1   2   3   4   5   6   7   8       &lt;- Edge1</div>
<div class="line">|   |   |   |   |   |   |   |   |</div>
<div class="line">   -2-     -2-     -2-     -2-          &lt;- The index steps are regular. </div>
<div class="line">   -1-     -1-     -1-     -1-          &lt;- The index steps are regular. </div>
<div class="line">|       |       |       |       |</div>
<div class="line">0       1       2       3       4       &lt;- Edge2</div>
</div><!-- fragment --><p>but fails for this type of interface </p><div class="fragment"><div class="line">0   1   2   3   4   5   6   7   8       &lt;- Edge1</div>
<div class="line">|   |   |   |   |   |   |   |   |</div>
<div class="line"> -1-     -3-       -2-     -2-          &lt;- The index steps are NOT regular. </div>
<div class="line"> -1-     -1-       -1-     -1-          &lt;- The index steps are regular. </div>
<div class="line">|   |           |       |       |</div>
<div class="line">0   1           2       3       4       &lt;- Edge2</div>
</div><!-- fragment --><p>The grids can be uniform or not uniform, as long as the index steps between the conforming indices are regular.</p>
<p>If the grids are uniform, we know that the index steps between the conforming indices are regular. Moreover the index steps are given by the number of cells divided by the greatest common divisor of the two numbers of cells. (E.g. if the first example was on uniform grids: \(\gcd(8,4) = 4\). On the first edge, the index step is \(\frac{8}{4} = 2\) and on the second edge, \(\frac{4}{4} = 1\).)</p>
<h1><a class="anchor" id="src_multipatch_connectivity__Patch_locator"></a>
Patch locator</h1>
<p>The patch locator operators identify the patch where a given physical coordinate is.</p>
<h3><a class="anchor" id="autotoc_md79"></a>
Mappings</h3>
<p>On each patch, we define a mapping from the logical domain to the physical domain.  </p><p class="formulaDsp">
\[    \mathcal{F}^{(i)}: \hat{\Omega}^{(i)} \rightarrow \Omega^{(i)}
\]
</p>
<p> (The \(\hat{\Omega}^{(i)}\) refers to the above domain \([a_x^{(i)}, b_x^{(i)}]\times[a_y^{(i)}, b_y^{(i)}]\).) The domain \(\hat{\Omega}^{(i)}\) is called the <em>logical domain</em> and \(\Omega^{(i)}\) the <em>physical domain</em>.</p>
<h3><a class="anchor" id="autotoc_md80"></a>
Global analytical invertible mapping</h3>
<p>We assume that there is a global mapping analytically invertible such that  </p><p class="formulaDsp">
\[    \mathcal{F}: \hat{\Omega} \rightarrow \Omega \\
    (\mathcal{F})^{-1}: \Omega \rightarrow \hat{\Omega} \\
        \text{with } \Omega = \bigcup_{i = 0}^{K} \Omega^{(i)} \quad 
        \text{and } \hat{\Omega} = \bigcup_{i = 0}^{K} \hat{\Omega}^{(i)} .\\
\]
</p>
<p> We can easily apply \((\mathcal{F})^{-1}\) to identify the equivalent logical coordinate of a given physical coordinate \(x\in\Omega\). We check then for each patch if the logical coordinate is on a rectangular logical patch \(\hat{\Omega}^{(i)}\), i.e. if \((\mathcal{F})^{-1}(x)\in\hat{\Omega}^{(i)}\).</p>
<h4><a class="anchor" id="autotoc_md81"></a>
Onion shape geometry</h4>
<p>We call "onion" shape geometry a disk-like patch surrounded by concentric ring-like patches. The patches are defined on the same dimensions <code><a class="el" href="structR.html" title="Define non periodic real contravariant R dimension.">R</a></code> and <code><a class="el" href="structTheta.html" title="Define periodic real contravariant Theta dimension.">Theta</a></code>. The logical grid is then split into different logical grids, one for each patch. We can then define one global mapping from the (<code><a class="el" href="structR.html" title="Define non periodic real contravariant R dimension.">R</a></code>, <code><a class="el" href="structTheta.html" title="Define periodic real contravariant Theta dimension.">Theta</a></code>) domain to the (<code><a class="el" href="structX.html" title="Define non periodic real X dimension.">X</a></code>, <code><a class="el" href="structY.html" title="Define non periodic real Y dimension.">Y</a></code>) domain for all the patches. This mapping also needs to be defined from the physical domain to the logical domain.</p>
<p>We order the patches from the O-point to the outside boundary.</p>
<p>The patch grids have to be continuous (i.e. we define patches such as \(b_x^{(i)} = a_x^{(i+1)}\) for edges on \(\{a_x^{(i)}\}\times[a_y^{(i)}, b_y^{(i)}]\) and \(\{b_x^{(i+1)}\}\times[a_y^{(i+1)}, b_y^{(i+1)}]\)).</p>
<p>In the <code><a class="el" href="classOnionPatchLocator.html" title="Patch locator specialised for &quot;onion&quot; geometry.">OnionPatchLocator</a></code> operator, we use these properties to apply a dichotomy method and reduce the number of tests to identify where the physical coordinate is.</p>
<h1><a class="anchor" id="src_multipatch_connectivity__References"></a>
References</h1>
<p>[1] Buchegger, F., JÃ¼ttler, B., Mantzaflaris, A., <em>Adaptively refined multi-patch B-splines with enhanced smoothness</em>. Applied Mathematics and Computation, Volume 272, Part 1 (2016). <a href="https://www.sciencedirect.com/science/article/pii/S009630031500836X">https://www.sciencedirect.com/science/article/pii/S009630031500836X</a>.</p>
<h1><a class="anchor" id="src_multipatch_connectivity__Contents"></a>
Contents</h1>
<ul>
<li><code><a class="el" href="edge__transformation_8hpp_source.html">edge_transformation.hpp</a></code>: Define the <code><a class="el" href="classEdgeTransformation.html" title="Transform a coordinate or an index from one edge to the one on the other edge.">EdgeTransformation</a></code> operator to transform the coordinate from one edge to the other (see above).</li>
<li><code><a class="el" href="edge_8hpp_source.html">edge.hpp</a></code>: Define the <code><a class="el" href="structEdge.html" title="Define an edge of a given patch.">Edge</a></code> structure.</li>
<li><code><a class="el" href="interface_8hpp_source.html">interface.hpp</a></code>: Define the <code><a class="el" href="structInterface.html" title="Represent a simple sticking of two edges.">Interface</a></code> structure.</li>
<li><code>ipatch_locator.hpp</code>: Define the base class <code>IPatchLocator</code> for the operators identifying the patch where a physical coordinate is.<ul>
<li><code><a class="el" href="onion__patch__locator_8hpp_source.html">onion_patch_locator.hpp</a></code>: Define a child class <code><a class="el" href="classOnionPatchLocator.html" title="Patch locator specialised for &quot;onion&quot; geometry.">OnionPatchLocator</a></code> specialised for "onion" type geometries.</li>
</ul>
</li>
<li><code><a class="el" href="matching__idx__slice_8hpp_source.html">matching_idx_slice.hpp</a></code> : Define <code><a class="el" href="classMatchingIdxSlice.html" title="Store the conforming indexes of each patch of a given interface.">MatchingIdxSlice</a></code> storing the conforming indices of both patch at a given interface.</li>
<li><code><a class="el" href="patch_8hpp_source.html">patch.hpp</a></code>: Define the <code><a class="el" href="structPatch.html" title="Base tag for a patch.">Patch</a></code> tag. </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
