<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>File polarpoissonlikesolver.hpp - GyselalibX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../docs/stylesheets/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "File polarpoissonlikesolver.hpp";
        var mkdocs_page_input_path = "gyselalibxx/polarpoissonlikesolver_8hpp_source.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> GyselalibX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >First Steps</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/getting_started.html">Getting Started</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../toolchains/index.html">Installation</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/DDC_in_gyselalibxx.html">DDC in Gyselalib++</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/CONTRIBUTING.html">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tutorials</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/landau_damping_tutorial.html">1D-1V Landau Damping Simulation with Gyselalib++</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/profiling.html">Measuring Performance in Gyselalib++</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Standards</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/CODING_STANDARD.html">Coding Standard</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/mathematical_and_physical_conventions.html">Maths and Physics</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/coding_covariant_and_contravariant_tensors.html">Coding Covariant and Contravariant Tensors</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gyselalib++ Overview</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Building Blocks</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../src/index.html">Gyselalib++ contents</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/advection/index.html">Advection methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/collisions/index.html">Collisions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >coord_transformations</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/coord_transformations/index.html">Mappings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/data_types/index.html">Data Storage Types</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryRTheta/index.html">Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_field</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection_field/index.html">Advection Field finder</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/geometry/index.html">Geometry RTheta</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/initialisation/index.html">Initialisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/poisson/index.html">Polar Poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_solver</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/time_solver/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryVparMu</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryVparMu/index.html">Geometry (vpar, mu)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/collisions/index.html">CollisionConfiguration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/geometry/index.html">GeometryVparMu</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXVx/index.html">Geometry (x, v_x)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >boltzmann</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/boltzmann/index.html">Boltzmann solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/geometry/index.html">Geometry X-Vx</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >rhs</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/rhs/index.html">RHS</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/utils/index.html">Utils</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXY/index.html">Geometry (x, y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/geometry/index.html">Geometry XY</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/initialisation/index.html">Initialisation on (x,y) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/time_integration/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXYVxVy</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXYVxVy/index.html">Geometry (x, y, v_x, v_y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/geometry/index.html">Geometry X Y-Vx Vy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vlasov</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/vlasov/index.html">Vlasov solver</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >gyroaverage</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/gyroaverage/index.html">Gyroaverage operator (for circular geometry)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >interpolation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/interpolation/index.html">Interpolation Methods</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_splines</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/interpolation/polar_splines/index.html">Polar Splines</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >io</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/io/index.html">Functions used for input and output</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >math_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/math_tools/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >matrix_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/matrix_tools/index.html">Matrix tools</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mpi_parallelisation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mpi_parallelisation/index.html">Parallelisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/multipatch/index.html">Multipatch</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >connectivity</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/connectivity/index.html">Multipatch connectivity</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/data_types/index.html">Data Types for Multipatch Geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/spline/index.html">Spline on multipatch geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/utils/index.html">Multipatch utilitary functions</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >pde_solvers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/pde_solvers/index.html">PDE Solvers</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >quadrature</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/quadrature/index.html">Quadrature Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >speciesinfo</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/speciesinfo/index.html">SpeciesInfo (x, v_x)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >timestepper</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/timestepper/index.html">Time Stepping Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/utils/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Simulations</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../simulations/index.html">Gyselalib++ simulations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryRTheta/index.html">Simulations in (r, theta) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >diocotron</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/diocotron/index.html">Diocotron instability</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vortex_merger</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/vortex_merger/index.html">Vortex merger</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXVx/index.html">Simulations in (x, vx) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXY/index.html">Simulations in (x, y) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >guiding_centre</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryXY/guiding_centre/index.html">Guiding centre (X,Y) simulation</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tests</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tests/index.html">Gyselalib++ tests</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/advection/index.html">Tests on the templated advection operators</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/geometryRTheta/index.html">Tests : Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/advection_rtheta/index.html">Tests on the 2D polar advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/polar_poisson/index.html">Tests on the 2D polar poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline_interpolator_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/spline_interpolator_rtheta/index.html">Tests on spline interpolator in polar coordinates</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/multipatch/index.html">Multipatch geometry tests</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometries</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/multipatch/geometries/index.html">Multipatch geometries</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Adding_docs.html">Adding Docs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Using_git.html">Using Git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/developer_FAQ.html">Developer FAQ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Troubleshooting</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/troubleshooting/Common_compilation_problems.html">Compilation Issues</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/troubleshooting/Debugging_workflow.html">Debugging</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Gyselalib++</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Classes</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="annotated.html">Class List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="classes.html">Class Index</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="hierarchy.html">Class Hierarchy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Namespaces</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="namespaces.html">Namespace List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_members.html">Namespace Members</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_functions.html">Namespace Member Functions</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_variables.html">Namespace Member Variables</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_typedefs.html">Namespace Member Typedefs</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_enums.html">Namespace Member Enumerations</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="files.html">Files</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">GyselalibX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">File polarpoissonlikesolver.hpp</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/gyselax/gyselalibxx/edit/main/gyselalibxx/polarpoissonlikesolver_8hpp_source.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div><h1 id="file-polarpoissonlikesolverhpp">File polarpoissonlikesolver.hpp</h1>
<p><a href="files.html"><strong>File List</strong></a> <strong>&gt;</strong> <a href="dir_be2a347b8fed8e825bae8c199ecc63c1.html"><strong>pde_solvers</strong></a> <strong>&gt;</strong> <a href="polarpoissonlikesolver_8hpp.html"><strong>polarpoissonlikesolver.hpp</strong></a></p>
<p><a href="polarpoissonlikesolver_8hpp.html">Go to the documentation of this file</a></p>
<pre><code class="language-C++">// SPDX-License-Identifier: MIT
#pragma once

#include &lt;ddc/ddc.hpp&gt;

#include "coord_transformation_tools.hpp"
#include "ddc_alias_inline_functions.hpp"
#include "ddc_aliases.hpp"
#include "gauss_legendre_integration.hpp"
#include "math_tools.hpp"
#include "matrix_batch_csr.hpp"
#include "metric_tensor_evaluator.hpp"
#include "polar_spline_evaluator.hpp"
#include "quadrature_coeffs_nd.hpp"
#include "view.hpp"
#include "volume_quadrature_nd.hpp"


template &lt;
        class GridR,
        class GridTheta,
        class PolarBSplinesRTheta,
        class SplineRThetaEvaluatorNullBound,
        class IdxRangeFull = IdxRange&lt;GridR, GridTheta&gt;&gt;
class PolarSplineFEMPoissonLikeSolver
{
    // TODO: Add a batch loop to operator()
    static_assert(
            std::is_same_v&lt;IdxRangeFull, IdxRange&lt;GridR, GridTheta&gt;&gt;,
            "PolarSplineFEMPoissonLikeSolver is not yet batched");

public:
    using R = typename GridR::continuous_dimension_type;
    using Theta = typename GridTheta::continuous_dimension_type;

    static_assert(R::IS_CONTRAVARIANT);
    static_assert(Theta::IS_CONTRAVARIANT);

private:
    using R_cov = typename R::Dual;
    using Theta_cov = typename Theta::Dual;


public:
    struct QDimRMesh : NonUniformGridBase&lt;R&gt;
    {
    };
    struct QDimThetaMesh : NonUniformGridBase&lt;Theta&gt;
    {
    };

    struct InternalBatchDim
    {
    };

private:
    using CoordRTheta = Coord&lt;R, Theta&gt;;
    using BSplinesR = typename PolarBSplinesRTheta::BSplinesR_tag;
    using BSplinesTheta = typename PolarBSplinesRTheta::BSplinesTheta_tag;

    using KnotsR = ddc::knot_discrete_dimension_t&lt;BSplinesR&gt;;
    using KnotsTheta = ddc::knot_discrete_dimension_t&lt;BSplinesTheta&gt;;

    using IdxRangeRTheta = IdxRange&lt;GridR, GridTheta&gt;;
    using IdxRTheta = Idx&lt;GridR, GridTheta&gt;;

    using IdxRangeBSPolar = IdxRange&lt;PolarBSplinesRTheta&gt;;
    using IdxBSPolar = Idx&lt;PolarBSplinesRTheta&gt;;
    using IdxStepBSPolar = IdxStep&lt;PolarBSplinesRTheta&gt;;

    using IdxRangeBSR = IdxRange&lt;BSplinesR&gt;;
    using IdxRangeBSTheta = IdxRange&lt;BSplinesTheta&gt;;
    using IdxRangeBSRTheta = IdxRange&lt;BSplinesR, BSplinesTheta&gt;;

    using IdxBSR = Idx&lt;BSplinesR&gt;;
    using IdxBSTheta = Idx&lt;BSplinesTheta&gt;;
    using IdxBSRTheta = Idx&lt;BSplinesR, BSplinesTheta&gt;;

    using IdxStepBSR = IdxStep&lt;BSplinesR&gt;;
    using IdxStepBSTheta = IdxStep&lt;BSplinesTheta&gt;;
    using IdxStepBSRTheta = IdxStep&lt;BSplinesR, BSplinesTheta&gt;;

    using IdxRangeBatchedBSRTheta
            = ddc::detail::convert_type_seq_to_discrete_domain_t&lt;ddc::type_seq_replace_t&lt;
                    ddc::to_type_seq_t&lt;IdxRangeFull&gt;,
                    ddc::detail::TypeSeq&lt;GridR, GridTheta&gt;,
                    ddc::detail::TypeSeq&lt;BSplinesR, BSplinesTheta&gt;&gt;&gt;;

    using IdxRangeBatch = ddc::remove_dims_of_t&lt;IdxRangeFull, IdxRange&lt;GridR&gt;, IdxRange&lt;GridTheta&gt;&gt;;

    using IdxRangeQuadratureR = IdxRange&lt;QDimRMesh&gt;;
    using IdxRangeQuadratureTheta = IdxRange&lt;QDimThetaMesh&gt;;
    using IdxRangeQuadratureRTheta = IdxRange&lt;QDimRMesh, QDimThetaMesh&gt;;
    using IdxQuadratureR = Idx&lt;QDimRMesh&gt;;
    using IdxQuadratureTheta = Idx&lt;QDimThetaMesh&gt;;
    using IdxQuadratureRTheta = Idx&lt;QDimRMesh, QDimThetaMesh&gt;;
    using IdxStepQuadratureR = IdxStep&lt;QDimRMesh&gt;;
    using IdxStepQuadratureTheta = IdxStep&lt;QDimThetaMesh&gt;;

    using ConstSpline2D = DConstField&lt;IdxRangeBatchedBSRTheta&gt;;
    using PolarSplineMemRTheta = DFieldMem&lt;IdxRange&lt;PolarBSplinesRTheta&gt;&gt;;
    using PolarSplineRTheta = DField&lt;IdxRange&lt;PolarBSplinesRTheta&gt;&gt;;

    using CoordFieldMemRTheta = FieldMem&lt;CoordRTheta, IdxRangeRTheta&gt;;
    using CoordFieldRTheta = Field&lt;CoordRTheta, IdxRangeRTheta&gt;;
    using DFieldRTheta = DField&lt;IdxRangeRTheta&gt;;

public:
    struct EvalDeriv1DType
    {
        double value;
        double derivative;
    };

    struct EvalDeriv2DType
    {
        double value;
        DVector&lt;R_cov, Theta_cov&gt; derivative;
    };

private:
    static constexpr int s_n_gauss_legendre_r = BSplinesR::degree() + 1;
    static constexpr int s_n_gauss_legendre_theta = BSplinesTheta::degree() + 1;
    // The number of cells (in the radial direction) in which both types of basis splines can be found
    static constexpr int m_n_overlap_cells = PolarBSplinesRTheta::continuity + 1;

    // Number of cells over which a radial B-splines has its support
    // This is the case for b-splines which are not affected by the higher knot multiplicity at the boundary.
    static constexpr int m_n_non_zero_bases_r = BSplinesR::degree() + 1;

    // Number of cells over which a poloidal B-splines has its support
    static constexpr int m_n_non_zero_bases_theta = BSplinesTheta::degree() + 1;

    const int m_nbasis_r;
    const int m_nbasis_theta;

    // Matrix size is equal to the number of Polar bspline
    const int m_matrix_size;

    // Domains
    IdxRangeBSPolar m_idxrange_fem_non_singular;
    IdxRangeBSR m_idxrange_bsplines_r;
    IdxRangeBSTheta m_idxrange_bsplines_theta;

    IdxRangeQuadratureR m_idxrange_quadrature_r;
    IdxRangeQuadratureTheta m_idxrange_quadrature_theta;
    IdxRangeQuadratureRTheta m_idxrange_quadrature_singular;
    IdxRangeQuadratureRTheta m_idxrange_quadrature;

    // Gauss-Legendre points and weights
    FieldMem&lt;double, IdxRangeQuadratureR&gt; m_weights_r;
    FieldMem&lt;double, IdxRangeQuadratureTheta&gt; m_weights_theta;

    FieldMem&lt;double, IdxRangeQuadratureRTheta&gt; m_int_volume_alloc;

    PolarSplineEvaluator&lt;
            Kokkos::DefaultExecutionSpace,
            Kokkos::DefaultExecutionSpace::memory_space,
            PolarBSplinesRTheta,
            ddc::NullExtrapolationRule&gt;
            m_polar_spline_evaluator;
    std::unique_ptr&lt;MatrixBatchCsr&lt;Kokkos::DefaultExecutionSpace, MatrixBatchCsrSolver::CG&gt;&gt;
            m_gko_matrix;
    mutable PolarSplineMemRTheta m_phi_spline_coef_alloc;
    mutable DFieldMem&lt;IdxRange&lt;InternalBatchDim, PolarBSplinesRTheta&gt;&gt; m_x_init_alloc;

    const int m_batch_idx {0}; // TODO: Remove when batching is supported
public:
    template &lt;class Mapping&gt;
    PolarSplineFEMPoissonLikeSolver(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            std::optional&lt;int&gt; max_iter = std::nullopt,
            std::optional&lt;double&gt; res_tol = std::nullopt,
            std::optional&lt;bool&gt; batch_solver_logger = std::nullopt,
            std::optional&lt;int&gt; preconditioner_max_block_size = std::nullopt)
        : m_nbasis_r(ddc::discrete_space&lt;BSplinesR&gt;().nbasis() - m_n_overlap_cells - 1)
        , m_nbasis_theta(ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis())
        , m_matrix_size(ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().nbasis() - m_nbasis_theta)
        , m_idxrange_fem_non_singular(
                  ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().tensor_bspline_idx_range().remove_last(
                          IdxStepBSPolar {m_nbasis_theta}))
        , m_idxrange_bsplines_r(ddc::discrete_space&lt;BSplinesR&gt;().full_domain().remove_first(
                  IdxStepBSR {m_n_overlap_cells}))
        , m_idxrange_bsplines_theta(ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain().take_first(
                  IdxStepBSTheta {m_nbasis_theta}))
        , m_idxrange_quadrature_r(
                  Idx&lt;QDimRMesh&gt;(0),
                  IdxStep&lt;QDimRMesh&gt;(
                          s_n_gauss_legendre_r * ddc::discrete_space&lt;BSplinesR&gt;().ncells()))
        , m_idxrange_quadrature_theta(
                  Idx&lt;QDimThetaMesh&gt;(0),
                  IdxStep&lt;QDimThetaMesh&gt;(
                          s_n_gauss_legendre_theta * ddc::discrete_space&lt;BSplinesTheta&gt;().ncells()))
        , m_idxrange_quadrature_singular(
                  m_idxrange_quadrature_r.take_first(
                          IdxStep&lt;QDimRMesh&gt; {m_n_overlap_cells * s_n_gauss_legendre_r}),
                  m_idxrange_quadrature_theta)
        , m_idxrange_quadrature(m_idxrange_quadrature_r, m_idxrange_quadrature_theta)
        , m_weights_r(m_idxrange_quadrature_r)
        , m_weights_theta(m_idxrange_quadrature_theta)
        , m_polar_spline_evaluator(ddc::NullExtrapolationRule())
        , m_phi_spline_coef_alloc(ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain())
        , m_x_init_alloc(
                  "x_init",
                  IdxRange&lt;InternalBatchDim, PolarBSplinesRTheta&gt;(
                          Idx&lt;InternalBatchDim, PolarBSplinesRTheta&gt;(0, 0),
                          IdxStep&lt;InternalBatchDim, PolarBSplinesRTheta&gt;(
                                  1,
                                  ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().nbasis()
                                          - ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis())))
    {
        static_assert(has_jacobian_v&lt;Mapping&gt;);
        //initialise x_init
        ddc::parallel_fill(get_field(m_x_init_alloc), 0);
        // Get break points
        IdxRange&lt;KnotsR&gt; idxrange_r_edges = ddc::discrete_space&lt;BSplinesR&gt;().break_point_domain();
        IdxRange&lt;KnotsTheta&gt; idxrange_theta_edges
                = ddc::discrete_space&lt;BSplinesTheta&gt;().break_point_domain();
        host_t&lt;FieldMem&lt;Coord&lt;R&gt;, IdxRange&lt;KnotsR&gt;&gt;&gt; breaks_r(idxrange_r_edges);
        host_t&lt;FieldMem&lt;Coord&lt;Theta&gt;, IdxRange&lt;KnotsTheta&gt;&gt;&gt; breaks_theta(idxrange_theta_edges);

        ddcHelper::dump_coordinates(Kokkos::DefaultHostExecutionSpace(), get_field(breaks_r));
        ddcHelper::dump_coordinates(Kokkos::DefaultHostExecutionSpace(), get_field(breaks_theta));

        // Define quadrature points and weights
        GaussLegendre&lt;QDimRMesh, s_n_gauss_legendre_r&gt; gl_coeffs_r(get_const_field(breaks_r));
        GaussLegendre&lt;QDimThetaMesh, s_n_gauss_legendre_theta&gt; gl_coeffs_theta(
                get_const_field(breaks_theta));
        m_int_volume_alloc = compute_coeffs_on_mapping(
                Kokkos::DefaultExecutionSpace(),
                mapping,
                gauss_legendre_quadrature_coefficients&lt;
                        Kokkos::DefaultExecutionSpace&gt;(gl_coeffs_r, gl_coeffs_theta));

        // Number of elements in the matrix that correspond to the splines
        // that cover the singular point
        constexpr int n_elements_singular
                = PolarBSplinesRTheta::n_singular_basis() * PolarBSplinesRTheta::n_singular_basis();
        // Number of non-zero elements in the matrix corresponding to the inner product of
        // polar splines at the singular point and the other splines
        const int n_elements_overlap = 2
                                       * (PolarBSplinesRTheta::n_singular_basis()
                                          * BSplinesR::degree() * m_nbasis_theta);
        const int n_stencil_theta
                = m_nbasis_theta * std::min(int(1 + 2 * BSplinesTheta::degree()), m_nbasis_theta);
        const int n_stencil_r = m_nbasis_r * (1 + 2 * BSplinesR::degree())
                                - (1 + BSplinesR::degree()) * BSplinesR::degree();
        // Number of non-zero elements in the matrix corresponding to the inner product of
        // non-central splines. These have a tensor product structure
        const int n_elements_stencil = n_stencil_r * n_stencil_theta;

        const int batch_size = 1;

        const int n_matrix_elements = n_elements_singular + n_elements_overlap + n_elements_stencil;

        //CSR data storage
        Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                values_csr_host("values_csr", batch_size, n_matrix_elements);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                col_idx_csr_host("idx_csr", n_matrix_elements);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::DefaultExecutionSpace&gt;
                nnz_per_row_csr("nnz_per_row_csr", m_matrix_size + 1);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                nnz_per_row_csr_host("nnz_per_row_csr", m_matrix_size + 1);

        m_gko_matrix = std::make_unique&lt;
                MatrixBatchCsr&lt;Kokkos::DefaultExecutionSpace, MatrixBatchCsrSolver::CG&gt;&gt;(
                1,
                m_matrix_size,
                n_matrix_elements,
                max_iter,
                res_tol,
                batch_solver_logger,
                preconditioner_max_block_size);
        auto [values, col_idx, nnz_per_row] = m_gko_matrix-&gt;get_batch_csr();
        init_nnz_per_line(nnz_per_row);
        Kokkos::deep_copy(nnz_per_row_csr_host, nnz_per_row);

        compute_singular_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);
        compute_overlapping_singular_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);
        compute_stencil_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);

        assert(nnz_per_row_csr_host(m_matrix_size) == n_matrix_elements);
        Kokkos::deep_copy(values, values_csr_host);
        Kokkos::deep_copy(col_idx, col_idx_csr_host);
        Kokkos::deep_copy(nnz_per_row, nnz_per_row_csr_host);
        m_gko_matrix-&gt;setup_solver();
    }

    template &lt;class Mapping&gt;
    void compute_singular_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();
        IdxRangeQuadratureRTheta idx_range_quad_singular = m_idxrange_quadrature_singular;

        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume_alloc);

        Kokkos::Profiling::pushRegion("PolarPoissonFillFemMatrix");
        // Calculate the matrix elements corresponding to the B-splines which cover the singular point
        ddc::host_for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_test) {
            ddc::host_for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_trial) {
                // Calculate the weak integral
                double const element = ddc::parallel_transform_reduce(
                        Kokkos::DefaultExecutionSpace(),
                        idx_range_quad_singular,
                        0.0,
                        ddc::reducer::sum&lt;double&gt;(),
                        KOKKOS_LAMBDA(Idx&lt;QDimRMesh, QDimThetaMesh&gt; const&amp; idx_quad) {
                            return weak_integral_element(
                                    idx_test,
                                    idx_trial,
                                    idx_quad,
                                    coeff_alpha,
                                    coeff_beta,
                                    spline_evaluator,
                                    mapping,
                                    int_volume_proxy);
                        });
                const int row_idx = idx_test - idxrange_singular.front();
                const int col_idx = idx_trial - idxrange_singular.front();
                const int csr_idx_singular_area = nnz_per_row_csr_host(row_idx + 1);
                //Fill the C matrix corresponding to the splines on the singular point
                col_idx_csr_host(csr_idx_singular_area) = col_idx;
                values_csr_host(m_batch_idx, csr_idx_singular_area) = element;
                nnz_per_row_csr_host(row_idx + 1)++;
            });
        });
    }

    template &lt;class Mapping&gt;
    void compute_overlapping_singular_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        // Create index ranges associated with the 2D splines
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();
        IdxRangeBSR central_radial_bspline_idx_range(
                m_idxrange_bsplines_r.take_first(IdxStep&lt;BSplinesR&gt; {BSplinesR::degree()}));

        IdxRangeBSRTheta idxrange_non_singular_near_centre(
                central_radial_bspline_idx_range,
                m_idxrange_bsplines_theta);

        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume_alloc);
        IdxRangeQuadratureRTheta
                full_quad_idx_range(m_idxrange_quadrature_r, m_idxrange_quadrature_theta);

        // Calculate the matrix elements where bspline products overlap the B-splines which cover the singular point
        ddc::host_for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_test) {
            ddc::host_for_each(idxrange_non_singular_near_centre, [&amp;](IdxBSRTheta const idx_trial) {
                const IdxBSPolar idx_trial_polar(to_polar(idx_trial));
                const IdxBSR idx_trial_r(idx_trial);
                const IdxBSTheta idx_trial_theta(idx_trial);

                auto&amp; bspl_r = ddc::discrete_space&lt;BSplinesR&gt;();
                auto&amp; bspl_theta = ddc::discrete_space&lt;BSplinesTheta&gt;();

                // Find the index range covering the cells where both the test and trial functions are non-zero
                const Idx&lt;KnotsR&gt; start_non_zero_r(
                        std::
                                max(bspl_r.break_point_domain().front(),
                                    bspl_r.get_first_support_knot(idx_trial_r)));
                const Idx&lt;KnotsR&gt; end_non_zero_r(
                        std::
                                min(bspl_r.get_last_support_knot(
                                            IdxBSR(PolarBSplinesRTheta::continuity)),
                                    bspl_r.get_last_support_knot(idx_trial_r)));

                const Idx&lt;KnotsTheta&gt; start_non_zero_theta(
                        bspl_theta.get_first_support_knot(idx_trial_theta));
                const Idx&lt;KnotsTheta&gt; end_non_zero_theta(
                        bspl_theta.get_last_support_knot(idx_trial_theta));

                const IdxRangeQuadratureRTheta quad_range = get_quadrature_between_knots(
                        start_non_zero_r,
                        end_non_zero_r,
                        start_non_zero_theta,
                        end_non_zero_theta,
                        m_idxrange_quadrature.front());


                assert(quad_range.size() &gt; 0);
                // Calculate the weak integral
                double element = ddc::parallel_transform_reduce(
                        Kokkos::DefaultExecutionSpace(),
                        quad_range,
                        0.0,
                        ddc::reducer::sum&lt;double&gt;(),
                        KOKKOS_LAMBDA(IdxQuadratureRTheta idx_quad) {
                            // Manage periodicity
                            if (!full_quad_idx_range.contains(idx_quad)) {
                                idx_quad -= full_quad_idx_range.template extent&lt;QDimThetaMesh&gt;();
                            }

                            return weak_integral_element&lt;Mapping&gt;(
                                    idx_test,
                                    idx_trial_polar,
                                    idx_quad,
                                    coeff_alpha,
                                    coeff_beta,
                                    spline_evaluator,
                                    mapping,
                                    int_volume_proxy);
                        });

                int const row_idx = idx_test - idxrange_singular.front();
                int const col_idx = idx_trial_polar - idxrange_singular.front();
                //a_ij
                col_idx_csr_host(nnz_per_row_csr_host(row_idx + 1)) = col_idx;
                values_csr_host(m_batch_idx, nnz_per_row_csr_host(row_idx + 1)) = element;
                nnz_per_row_csr_host(row_idx + 1)++;
                //a_ji
                col_idx_csr_host(nnz_per_row_csr_host(col_idx + 1)) = row_idx;
                values_csr_host(m_batch_idx, nnz_per_row_csr_host(col_idx + 1)) = element;
                nnz_per_row_csr_host(col_idx + 1)++;
            });
        });
    }

    template &lt;class Mapping&gt;
    void compute_stencil_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();

        // Get index range for basis elements (last element removed due to homogeneous Dirichlet)
        IdxRangeBSR full_idx_range_r
                = ddc::discrete_space&lt;BSplinesR&gt;().full_domain().remove_last(IdxStepBSR(1));

        // Calculate the matrix elements following a stencil
        ddc::host_for_each(m_idxrange_fem_non_singular, [&amp;](IdxBSPolar const idx_test_polar) {
            const IdxBSRTheta idx_test(PolarBSplinesRTheta::get_2d_index(idx_test_polar));
            const IdxBSR idx_test_r(idx_test);
            const IdxBSTheta idx_test_theta(idx_test);

            // Calculate the index of the elements that are already filled
            IdxRangeBSTheta remaining_theta(
                    idx_test_theta,
                    IdxStep&lt;BSplinesTheta&gt; {BSplinesTheta::degree() + 1});
            ddc::host_for_each(remaining_theta, [&amp;](IdxBSTheta const idx_trial_theta) {
                IdxBSRTheta idx_trial(idx_test_r, idx_trial_theta);
                IdxBSPolar idx_trial_polar(to_polar(theta_mod(idx_trial)));
                double element = get_matrix_stencil_element(
                        idx_test,
                        idx_trial,
                        coeff_alpha,
                        coeff_beta,
                        spline_evaluator,
                        mapping);
                int const int_polar_idx_test = idx_test_polar - idxrange_singular.front();
                if (idx_test_polar == idx_trial_polar) {
                    const int idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;
                } else {
                    int const int_polar_idx_trial = idx_trial_polar - idxrange_singular.front();

                    const int aij_idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(aij_idx) = int_polar_idx_trial;
                    values_csr_host(m_batch_idx, aij_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;

                    const int aji_idx = nnz_per_row_csr_host(int_polar_idx_trial + 1);
                    col_idx_csr_host(aji_idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, aji_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_trial + 1)++;
                }
            });
            IdxStepBSR n_remaining_r(std::
                                             min(IdxStepBSR(BSplinesR::degree()),
                                                 full_idx_range_r.back() - idx_test_r));
            IdxRangeBSR remaining_r(idx_test_r + 1, n_remaining_r);
            IdxRangeBSTheta relevant_theta(
                    idx_test_theta + ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis()
                            - BSplinesTheta::degree(),
                    IdxStepBSTheta {2 * BSplinesTheta::degree() + 1});

            IdxRangeBSRTheta trial_idx_range(remaining_r, relevant_theta);

            ddc::host_for_each(trial_idx_range, [&amp;](IdxBSRTheta const idx_trial) {
                IdxBSPolar idx_trial_polar(to_polar(theta_mod(idx_trial)));
                double element = get_matrix_stencil_element(
                        idx_test,
                        idx_trial,
                        coeff_alpha,
                        coeff_beta,
                        spline_evaluator,
                        mapping);
                int const int_polar_idx_test = idx_test_polar - idxrange_singular.front();
                if (idx_test_polar == idx_trial_polar) {
                    const int idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;
                } else {
                    int const int_polar_idx_trial = idx_trial_polar - idxrange_singular.front();
                    const int aij_idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(aij_idx) = int_polar_idx_trial;
                    values_csr_host(m_batch_idx, aij_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;

                    const int aji_idx = nnz_per_row_csr_host(int_polar_idx_trial + 1);
                    col_idx_csr_host(aji_idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, aji_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_trial + 1)++;
                }
            });
        });

        Kokkos::Profiling::popRegion();
    }
    template &lt;class RHSFunction&gt;
    void operator()(RHSFunction const&amp; rhs, PolarSplineRTheta spline) const
    {
        Kokkos::Profiling::pushRegion("PolarPoissonRHS");

        static_assert(
                std::is_invocable_r_v&lt;double, RHSFunction, CoordRTheta&gt;,
                "RHSFunction must have an operator() which takes a coordinate and returns a "
                "double");
        assert(get_idx_range(spline) == ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain());
        IdxRange&lt;InternalBatchDim&gt; batch_idx_range(get_idx_range(m_x_init_alloc));

        assert(batch_idx_range.size() == 1);

        Idx&lt;InternalBatchDim&gt; batch_idx = batch_idx_range.front();

        // Create b for rhs
        DFieldMem&lt;IdxRange&lt;InternalBatchDim, PolarBSplinesRTheta&gt;&gt; b_alloc(
                get_idx_range(m_x_init_alloc));
        DField&lt;IdxRange&lt;InternalBatchDim, PolarBSplinesRTheta&gt;&gt; b = get_field(b_alloc);

        // Get initial guess
        DField&lt;IdxRange&lt;InternalBatchDim, PolarBSplinesRTheta&gt;&gt; x_init = get_field(m_x_init_alloc);

        DConstField&lt;IdxRangeQuadratureRTheta&gt; int_volume = get_const_field(m_int_volume_alloc);

        IdxRangeBSPolar idx_range_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();

        IdxRangeQuadratureRTheta idx_range_quad_singular = m_idxrange_quadrature_singular;

        // Fill b
        // Multi-level parallelism is needed as idx_range_singular.size() ~= 3 but b is on GPU
        Kokkos::parallel_for(
                Kokkos::TeamPolicy&lt;&gt;(
                        Kokkos::DefaultExecutionSpace(),
                        idx_range_singular.size(),
                        Kokkos::AUTO),
                KOKKOS_LAMBDA(const Kokkos::TeamPolicy&lt;&gt;::member_type&amp; team) {
                    IdxBSPolar idx
                            = idx_range_singular.front() + IdxStepBSPolar(team.league_rank());
                    double teamSum = 0;
                    Kokkos::parallel_reduce(
                            Kokkos::TeamThreadMDRange(
                                    team,
                                    idx_range_quad_singular.template extent&lt;QDimRMesh&gt;(),
                                    idx_range_quad_singular.template extent&lt;QDimThetaMesh&gt;()),
                            [&amp;](int r_thread_index, int theta_thread_index, double&amp; sum) {
                                IdxQuadratureRTheta idx_quad = idx_range_quad_singular.front()
                                                               + IdxStep&lt;QDimRMesh, QDimThetaMesh&gt;(
                                                                       r_thread_index,
                                                                       theta_thread_index);
                                const CoordRTheta coord(ddc::coordinate(idx_quad));
                                sum += rhs(coord) * get_polar_bspline_vals(coord, idx)
                                       * int_volume(idx_quad);
                            },
                            teamSum);

                    b(batch_idx, idx) = teamSum;
                });

        IdxRangeQuadratureRTheta full_quad_idx_range = m_idxrange_quadrature;
        IdxRangeQuadratureTheta full_quad_idx_range_theta(full_quad_idx_range);

        ddc::parallel_for_each(
                m_idxrange_fem_non_singular,
                KOKKOS_LAMBDA(IdxBSPolar const idx) {
                    const IdxBSRTheta idx_2d(PolarBSplinesRTheta::get_2d_index(idx));
                    const IdxBSR idx_r(idx_2d);
                    const IdxBSTheta idx_theta(idx_2d);

                    auto&amp; bspl_r = ddc::discrete_space&lt;BSplinesR&gt;();
                    auto&amp; bspl_theta = ddc::discrete_space&lt;BSplinesTheta&gt;();

                    // Find the cells on which the bspline is non-zero
                    const Idx&lt;KnotsR&gt; start_non_zero_r(
                            Kokkos::
                                    max(bspl_r.break_point_domain().front(),
                                        bspl_r.get_first_support_knot(idx_r)));
                    const Idx&lt;KnotsR&gt; end_non_zero_r(
                            Kokkos::
                                    min(bspl_r.break_point_domain().back(),
                                        bspl_r.get_last_support_knot(idx_r)));

                    const Idx&lt;KnotsTheta&gt; start_non_zero_theta(
                            bspl_theta.get_first_support_knot(idx_theta));
                    const Idx&lt;KnotsTheta&gt; end_non_zero_theta(
                            bspl_theta.get_last_support_knot(idx_theta));

                    const IdxRangeQuadratureRTheta quad_range = get_quadrature_between_knots(
                            start_non_zero_r,
                            end_non_zero_r,
                            start_non_zero_theta,
                            end_non_zero_theta,
                            full_quad_idx_range.front());

                    // Calculate the weak integral
                    b(batch_idx, idx) = 0.0;
                    for (IdxQuadratureTheta idx_quad_theta :
                         ddc::select&lt;QDimThetaMesh&gt;(quad_range)) {
                        // Manage periodicity
                        if (!full_quad_idx_range_theta.contains(idx_quad_theta)) {
                            idx_quad_theta -= full_quad_idx_range_theta.extents();
                        }
                        for (IdxQuadratureR idx_quad_r : ddc::select&lt;QDimRMesh&gt;(quad_range)) {
                            IdxQuadratureRTheta idx_quad(idx_quad_r, idx_quad_theta);
                            CoordRTheta coord(ddc::coordinate(idx_quad));
                            b(batch_idx, idx) += rhs(coord) * get_polar_bspline_vals(coord, idx)
                                                 * int_volume(idx_quad);
                        }
                    }
                });

        Kokkos::Profiling::popRegion();

        // Solve the matrix equation
        Kokkos::Profiling::pushRegion("PolarPoissonSolve");
        m_gko_matrix-&gt;solve(x_init.allocation_kokkos_view(), b.allocation_kokkos_view());
        //-----------------
        IdxStepBSPolar radial_boundary_splines(m_nbasis_theta);
        IdxRangeBSPolar polar_bspl_idx_range
                = ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain().remove_last(
                        radial_boundary_splines);
        IdxRangeBSPolar bc_polar_bspl_idx_range
                = ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain().take_last(
                        radial_boundary_splines);

        // Fill the spline
        ddc::parallel_for_each(
                polar_bspl_idx_range,
                KOKKOS_LAMBDA(IdxBSPolar const idx) { spline(idx) = x_init(batch_idx, idx); });
        ddc::parallel_fill(spline[bc_polar_bspl_idx_range], 0.0);
        Kokkos::Profiling::popRegion();
    }

    template &lt;class RHSFunction&gt;
    void operator()(RHSFunction const&amp; rhs, DFieldRTheta phi) const
    {
        static_assert(
                std::is_invocable_r_v&lt;double, RHSFunction, CoordRTheta&gt;,
                "RHSFunction must have an operator() which takes a coordinate and returns a "
                "double");

        (*this)(rhs, get_field(m_phi_spline_coef_alloc));
        CoordFieldMemRTheta coords_eval_alloc(get_idx_range(phi));
        m_polar_spline_evaluator(phi, get_const_field(m_phi_spline_coef_alloc));
    }

    template &lt;class Mapping&gt;
    static KOKKOS_FUNCTION double weak_integral_element(
            IdxBSPolar idx_test,
            IdxBSPolar idx_trial,
            IdxQuadratureRTheta idx_quad,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        // Calculate coefficients at quadrature point
        CoordRTheta coord(ddc::coordinate(idx_quad));
        const double alpha = spline_evaluator(coord, coeff_alpha);
        const double beta = spline_evaluator(coord, coeff_beta);

        // Define the value and gradient of the test and trial basis functions
        double basis_val_test_space;
        double basis_val_trial_space;
        DVector&lt;R_cov, Theta_cov&gt; basis_derivs_test_space
                = get_polar_bspline_vals_and_derivs(basis_val_test_space, coord, idx_test);
        DVector&lt;R_cov, Theta_cov&gt; basis_derivs_trial_space
                = get_polar_bspline_vals_and_derivs(basis_val_trial_space, coord, idx_trial);

        MetricTensorEvaluator&lt;Mapping, CoordRTheta&gt; get_metric_tensor(mapping);

        Tensor inv_metric_tensor = get_metric_tensor.inverse(coord);

        // Assemble the weak integral element
        return int_volume(idx_quad)
               * (alpha
                          * tensor_mul(
                                  index&lt;'i'&gt;(basis_derivs_test_space),
                                  index&lt;'i', 'j'&gt;(inv_metric_tensor),
                                  index&lt;'j'&gt;(basis_derivs_trial_space))
                  + beta * basis_val_test_space * basis_val_trial_space);
    }

    template &lt;class Mapping&gt;
    double get_matrix_stencil_element(
            IdxBSRTheta idx_test,
            IdxBSRTheta idx_trial,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping)
    {
        IdxRangeQuadratureRTheta
                full_quad_idx_range(m_idxrange_quadrature_r, m_idxrange_quadrature_theta);
        const IdxBSR idx_test_r(idx_test);
        const IdxBSR idx_trial_r(idx_trial);
        const IdxBSTheta idx_test_theta(theta_mod(IdxBSTheta(idx_test)));
        const IdxBSTheta idx_trial_theta(theta_mod(IdxBSTheta(idx_trial)));

        auto&amp; bspl_r = ddc::discrete_space&lt;BSplinesR&gt;();
        auto&amp; bspl_theta = ddc::discrete_space&lt;BSplinesTheta&gt;();

        const Idx&lt;KnotsR&gt; start_non_zero_r(
                std::
                        max(bspl_r.break_point_domain().front(),
                            std::
                                    max(bspl_r.get_first_support_knot(idx_test_r),
                                        bspl_r.get_first_support_knot(idx_trial_r))));
        const Idx&lt;KnotsR&gt; end_non_zero_r(
                std::
                        min(bspl_r.break_point_domain().back(),
                            std::
                                    min(bspl_r.get_last_support_knot(idx_test_r),
                                        bspl_r.get_last_support_knot(idx_trial_r))));

        IdxStep&lt;KnotsTheta&gt; span_theta(BSplinesTheta::degree() + 1);

        Idx&lt;KnotsTheta&gt; first_support_knot_theta_test
                = bspl_theta.get_first_support_knot(idx_test_theta);
        Idx&lt;KnotsTheta&gt; first_support_knot_theta_trial
                = bspl_theta.get_first_support_knot(idx_trial_theta);
        Idx&lt;KnotsTheta&gt; last_support_knot_theta_test = first_support_knot_theta_test + span_theta;
        Idx&lt;KnotsTheta&gt; last_support_knot_theta_trial = first_support_knot_theta_trial + span_theta;

        if (first_support_knot_theta_test &gt; last_support_knot_theta_trial) {
            first_support_knot_theta_trial += ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
            last_support_knot_theta_trial += ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        } else if (last_support_knot_theta_test &lt; first_support_knot_theta_trial) {
            first_support_knot_theta_test += ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
            last_support_knot_theta_test += ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        }
        const Idx&lt;KnotsTheta&gt; start_non_zero_theta(
                std::max(first_support_knot_theta_test, first_support_knot_theta_trial));
        const Idx&lt;KnotsTheta&gt; end_non_zero_theta(
                std::min(last_support_knot_theta_test, last_support_knot_theta_trial));

        const IdxRangeQuadratureRTheta quad_range = get_quadrature_between_knots(
                start_non_zero_r,
                end_non_zero_r,
                start_non_zero_theta,
                end_non_zero_theta,
                m_idxrange_quadrature.front());

        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume_alloc);

        const IdxBSPolar idx_test_polar(to_polar(idx_test));
        const IdxBSPolar idx_trial_polar(to_polar(idx_trial));

        return ddc::parallel_transform_reduce(
                quad_range,
                0.0,
                ddc::reducer::sum&lt;double&gt;(),
                KOKKOS_LAMBDA(IdxQuadratureRTheta idx_quad) {
                    // Manage periodicity
                    if (!full_quad_idx_range.contains(idx_quad)) {
                        idx_quad -= full_quad_idx_range.template extent&lt;QDimThetaMesh&gt;();
                    }
                    assert(full_quad_idx_range.contains(idx_quad));
                    return weak_integral_element(
                            idx_test_polar,
                            idx_trial_polar,
                            idx_quad,
                            coeff_alpha,
                            coeff_beta,
                            evaluator,
                            mapping,
                            int_volume_proxy);
                });
    }

    static KOKKOS_FUNCTION IdxStepBSTheta theta_mod(IdxStepBSTheta idx_theta)
    {
        int n_theta = ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        while (idx_theta &lt; 0)
            idx_theta += n_theta;
        while (idx_theta &gt;= n_theta)
            idx_theta -= n_theta;
        return idx_theta;
    }

    template &lt;class IdxType&gt;
    static KOKKOS_INLINE_FUNCTION IdxType theta_mod(IdxType idx)
    {
        static_assert(ddc::is_discrete_element_v&lt;IdxType&gt;);
        static_assert(ddc::in_tags_v&lt;BSplinesTheta, ddc::to_type_seq_t&lt;IdxType&gt;&gt;);
        IdxRangeBSTheta idx_range_theta
                = ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain().take_first(
                        IdxStepBSTheta(ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis()));
        while (ddc::select&lt;BSplinesTheta&gt;(idx) &lt; idx_range_theta.front())
            idx += idx_range_theta.extents();
        while (ddc::select&lt;BSplinesTheta&gt;(idx) &gt; idx_range_theta.back())
            idx -= idx_range_theta.extents();
        assert(idx_range_theta.contains(ddc::select&lt;BSplinesTheta&gt;(idx)));
        return idx;
    }

    template &lt;bool calculate_derivs = true&gt;
    static KOKKOS_FUNCTION auto get_polar_bspline_vals_and_derivs(
            double&amp; val,
            CoordRTheta coord,
            IdxBSPolar idx)
    {
        std::array&lt;double, PolarBSplinesRTheta::n_singular_basis()&gt; singular_data;
        std::array&lt;double, m_n_non_zero_bases_r * m_n_non_zero_bases_theta&gt; data;
        // Values of the polar basis splines around the singular point
        // at a given coordinate
        DSpan1D singular_vals(singular_data.data(), PolarBSplinesRTheta::n_singular_basis());
        // Values of the polar basis splines, that do not cover the singular point,
        // at a given coordinate
        DSpan2D vals(data.data(), m_n_non_zero_bases_r, m_n_non_zero_bases_theta);

        auto&amp; polar_bspl = ddc::discrete_space&lt;PolarBSplinesRTheta&gt;();

        if (idx &lt; IdxBSPolar(PolarBSplinesRTheta::n_singular_basis())) {
            IdxStepBSPolar offset
                    = idx
                      - PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;()
                                .front();
            polar_bspl.eval_basis(singular_vals, vals, coord);
            val = singular_vals[offset.value()];
            if constexpr (calculate_derivs) {
                polar_bspl.eval_deriv_r(singular_vals, vals, coord);
                double r_deriv = singular_vals[offset.value()];
                polar_bspl.eval_deriv_theta(singular_vals, vals, coord);
                double theta_deriv = singular_vals[offset.value()];
                DVector&lt;R_cov, Theta_cov&gt; derivs(r_deriv, theta_deriv);
                return derivs;
            } else {
                return;
            }
        } else {
            IdxBSRTheta idx_front = polar_bspl.eval_basis(singular_vals, vals, coord);
            IdxStepBSRTheta offset = PolarBSplinesRTheta::get_2d_index(idx) - idx_front;
            IdxStepBSR ir(offset);
            IdxStepBSTheta itheta(theta_mod(IdxStepBSTheta(offset)));

            val = vals(ir, itheta);
            if constexpr (calculate_derivs) {
                polar_bspl.eval_deriv_r(singular_vals, vals, coord);
                double r_deriv = vals(ir, itheta);
                polar_bspl.eval_deriv_theta(singular_vals, vals, coord);
                double theta_deriv = vals(ir, itheta);
                DVector&lt;R_cov, Theta_cov&gt; derivs(r_deriv, theta_deriv);
                return derivs;
            } else {
                return;
            }
        }
    }

    static KOKKOS_INLINE_FUNCTION double get_polar_bspline_vals(CoordRTheta coord, IdxBSPolar idx)
    {
        double val;
        get_polar_bspline_vals_and_derivs&lt;false&gt;(val, coord, idx);
        return val;
    }

    void init_nnz_per_line(Kokkos::View&lt;int*, Kokkos::LayoutRight&gt; nnz_per_row) const
    {
        Kokkos::Profiling::pushRegion("PolarPoissonInitNnz");
        size_t const mat_size = nnz_per_row.extent(0) - 1;
        IdxStepBSPolar radial_boundary_splines(m_nbasis_theta);
        IdxRangeBSPolar polar_bspl_idx_range
                = ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain().remove_last(
                        radial_boundary_splines);

        Kokkos::deep_copy(nnz_per_row, 0.);

        assert(mat_size == polar_bspl_idx_range.size());
        // nnz per line
        Field&lt;int, IdxRangeBSPolar&gt;
                nnz(Kokkos::subview(nnz_per_row, std::pair&lt;int, int&gt;(2, mat_size + 1)),
                    polar_bspl_idx_range.remove_last(IdxStepBSPolar(1)));

        size_t constexpr n_singular_basis = PolarBSplinesRTheta::n_singular_basis();
        size_t constexpr degree = BSplinesR::degree();
        size_t constexpr stencil_overlap = 2 * degree + 1;
        size_t const nbasis_theta_proxy = m_nbasis_theta;

        // The number of radial splines which overlap with a given radial spline to its
        // left or to its right
        IdxStepBSR n_one_side_overlap(BSplinesR::degree());

        int nnz_for_sigular_rows = n_singular_basis + degree * nbasis_theta_proxy;

        // rows representing the bsplines which cover the singular domain
        // These overlap with other singular domain splines and degree radial splines
        Kokkos::parallel_for(
                "overlap singular radial",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(1, n_singular_basis + 1),
                KOKKOS_LAMBDA(const int k) { nnz_per_row(k + 1) = k * nnz_for_sigular_rows; });

        int nnz_sum = nnz_for_sigular_rows * n_singular_basis;

        IdxRangeBSR idxrange_bsplines_r_overlapping_singular
                = m_idxrange_bsplines_r.take_first(n_one_side_overlap);
        IdxRangeBSTheta idxrange_bsplines_theta = m_idxrange_bsplines_theta;
        IdxRangeBSRTheta idxrange_singular_overlap(
                idxrange_bsplines_r_overlapping_singular,
                idxrange_bsplines_theta);
        // rows representing the bsplines which can be represented as a tensor product of
        // radial and poloidal bsplines but which still overlap with the singular domain
        Kokkos::parallel_for(
                "inner overlap",
                Kokkos::TeamPolicy&lt;&gt;(
                        Kokkos::DefaultExecutionSpace(),
                        idxrange_bsplines_r_overlapping_singular.size(),
                        Kokkos::AUTO),
                KOKKOS_LAMBDA(const Kokkos::TeamPolicy&lt;&gt;::member_type&amp; team) {
                    IdxStepBSR ir(team.league_rank());
                    // number of radial bases which overlap with this element
                    int nr = degree + ir + 1;

                    // nnz to this line = nnz_singular + n_singular * ir*ntheta + ntheta * n_stencil_theta \sum_{k=degree+1}^{nr-1} k
                    int nnz_sum_to_r = nnz_sum + n_singular_basis * ir * nbasis_theta_proxy
                                       + (nr * (nr - 1) - degree * (degree + 1))
                                                 * nbasis_theta_proxy * stencil_overlap / 2;

                    // Loop over poloidal dimensions
                    Kokkos::parallel_for(
                            Kokkos::TeamThreadRange(team, nbasis_theta_proxy),
                            [&amp;](int const&amp; thread_index) {
                                IdxStepBSTheta itheta(thread_index);
                                IdxBSRTheta k_2d = idxrange_singular_overlap.front() + ir + itheta;
                                IdxBSPolar k(to_polar(k_2d));
                                nnz(k) = nnz_sum_to_r
                                         + (thread_index + 1)
                                                   * (n_singular_basis + nr * stencil_overlap);
                            });
                });

        {
            int nr = idxrange_bsplines_r_overlapping_singular.size();
            nnz_sum += (n_singular_basis * nr + nr * (nr + 2 * degree + 1) * stencil_overlap / 2)
                       * nbasis_theta_proxy;
        }

        IdxRangeBSR idxrange_bsplines_r_stencil
                = m_idxrange_bsplines_r.remove(n_one_side_overlap, n_one_side_overlap + 1);
        IdxRangeBSRTheta idxrange_stencil(idxrange_bsplines_r_stencil, idxrange_bsplines_theta);
        IdxBSPolar idx_stencil_front = to_polar(idxrange_stencil.front());
        // Stencil for tensor product bsplines which only overlap with other tensor product bsplines
        Kokkos::parallel_for(
                "Inner Stencil",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(0, idxrange_stencil.size()),
                KOKKOS_LAMBDA(const int k) {
                    IdxBSPolar kp(idx_stencil_front + IdxStepBSPolar(k));
                    nnz(kp) = nnz_sum + (k + 1) * stencil_overlap * stencil_overlap;
                });

        nnz_sum += idxrange_stencil.size() * stencil_overlap * stencil_overlap;

        // Get the outer radial bsplines excluding the bspline used for homogeneous Hermite boundary conditions
        IdxRangeBSR outer_bsplines_r = m_idxrange_bsplines_r.take_last(n_one_side_overlap + 1)
                                               .remove_last(IdxStepBSR(1));
        IdxRangeBSRTheta outer_bsplines_2d(outer_bsplines_r, idxrange_bsplines_theta);
        IdxRangeBSPolar outer_bsplines(
                to_polar(outer_bsplines_2d.front()),
                IdxStepBSPolar(outer_bsplines_2d.size() - 1));
        assert(outer_bsplines.back() == get_idx_range(nnz).back());
        // Approaching the external boundary the overlapping possibilities between two radial splines decrease
        Kokkos::parallel_for(
                "outer overlap",
                Kokkos::TeamPolicy&lt;&gt;(
                        Kokkos::DefaultExecutionSpace(),
                        outer_bsplines_r.size(),
                        Kokkos::AUTO),
                KOKKOS_LAMBDA(const Kokkos::TeamPolicy&lt;&gt;::member_type&amp; team) {
                    IdxStepBSR ir(team.league_rank());
                    int nr = 2 * degree - ir;
                    IdxBSR k_r(outer_bsplines_2d.front() + ir);
                    int nnz_sum_to_r = nnz_sum
                                       + (degree * (2 * degree + 1) - nr * (nr + 1) / 2)
                                                 * stencil_overlap * nbasis_theta_proxy;
                    // Loop over poloidal dimensions
                    Kokkos::parallel_for(
                            Kokkos::TeamThreadRange(team, nbasis_theta_proxy),
                            [&amp;](int const&amp; thread_index) {
                                IdxStepBSTheta itheta(thread_index);
                                IdxBSRTheta k_2d = outer_bsplines_2d.front() + ir + itheta;
                                IdxBSPolar k(to_polar(k_2d));
                                if (outer_bsplines.contains(k)) {
                                    nnz(k) = nnz_sum_to_r
                                             + (thread_index + 1) * nr * stencil_overlap;
                                }
                            });
                });

        Kokkos::Profiling::popRegion();
    }

    static KOKKOS_INLINE_FUNCTION IdxBSPolar to_polar(IdxBSRTheta idx)
    {
        return PolarBSplinesRTheta::template get_polar_index&lt;PolarBSplinesRTheta&gt;(idx);
    }

    static KOKKOS_FUNCTION IdxRangeQuadratureRTheta get_quadrature_between_knots(
            Idx&lt;KnotsR&gt; start_knot_r,
            Idx&lt;KnotsR&gt; end_knot_r,
            Idx&lt;KnotsTheta&gt; start_knot_theta,
            Idx&lt;KnotsTheta&gt; end_knot_theta,
            IdxQuadratureRTheta idx_quad_front)
    {
        const IdxRange&lt;KnotsR&gt; k_range_r(start_knot_r, end_knot_r - start_knot_r);
        const IdxRange&lt;KnotsTheta&gt;
                k_range_theta(start_knot_theta, end_knot_theta - start_knot_theta);

        IdxStep&lt;KnotsR&gt; k_r_offset
                = k_range_r.front() - ddc::discrete_space&lt;BSplinesR&gt;().break_point_domain().front();
        IdxQuadratureR q_r_offset
                = IdxQuadratureR(idx_quad_front) + k_r_offset.value() * s_n_gauss_legendre_r;
        IdxStepQuadratureR q_r_len(k_range_r.extents().value() * s_n_gauss_legendre_r);
        IdxRangeQuadratureR q_range_r(q_r_offset, q_r_len);

        IdxStep&lt;KnotsTheta&gt; k_theta_offset
                = k_range_theta.front()
                  - ddc::discrete_space&lt;BSplinesTheta&gt;().break_point_domain().front();
        if (k_theta_offset &lt; 0)
            k_theta_offset += ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        IdxQuadratureTheta q_theta_offset = IdxQuadratureTheta(idx_quad_front)
                                            + k_theta_offset.value() * s_n_gauss_legendre_theta;
        IdxStepQuadratureTheta q_theta_len(
                k_range_theta.extents().value() * s_n_gauss_legendre_theta);
        IdxRangeQuadratureTheta q_range_theta(q_theta_offset, q_theta_len);
        assert(q_range_r.extents() &gt; 0);
        assert(q_range_theta.extents() &gt; 0);

        return IdxRangeQuadratureRTheta(q_range_r, q_range_theta);
    }
};
</code></pre></div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/gyselax/gyselalibxx/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../docs/jscript/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
