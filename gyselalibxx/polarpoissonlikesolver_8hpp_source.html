<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>File polarpoissonlikesolver.hpp - GyselalibX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "File polarpoissonlikesolver.hpp";
        var mkdocs_page_input_path = "gyselalibxx/polarpoissonlikesolver_8hpp_source.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> GyselalibX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >First Steps</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/getting_started.html">Getting Started</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Installation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../docs/first_steps/install.html">Gyselalib++ Installation</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../toolchains/index.html">Pre-made build settings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/DDC_in_gyselalibxx.html">DDC in Gyselalib++</a>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tutorials</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/landau_damping_tutorial.html">1D-1V Landau Damping Simulation with Gyselalib++</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Standards</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/CODING_STANDARD.html">Coding Standard</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/mathematical_and_physical_conventions.html">Math & Physics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gyselalib++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Source</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../src/index.html">Gyselalib++ contents</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/advection/index.html">Advection methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/collisions/index.html">Collisions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/data_types/index.html">Data Storage Types</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryRTheta/index.html">Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_field</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection_field/index.html">Advection Field finder</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/geometry/index.html">Geometry RTheta</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/initialisation/index.html">Initialisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/poisson/index.html">Polar Poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_solver</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/time_solver/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryVparMu</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryVparMu/index.html">Geometry (vpar, mu)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/collisions/index.html">CollisionConfiguration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/geometry/index.html">GeometryVparMu</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXVx/index.html">Geometry (x, v_x)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >boltzmann</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/boltzmann/index.html">Boltzmann solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/geometry/index.html">Geometry X-Vx</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >rhs</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/rhs/index.html">RHS</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/utils/index.html">Utils</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXY/index.html">Geometry (x, y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/geometry/index.html">Geometry XY</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/initialisation/index.html">Initialisation on (x,y) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/time_integration/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXYVxVy</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXYVxVy/index.html">Geometry (x, y, v_x, v_y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/geometry/index.html">Geometry X Y-Vx Vy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vlasov</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/vlasov/index.html">Vlasov solver</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >interpolation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/interpolation/index.html">Interpolation Methods</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_splines</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/interpolation/polar_splines/index.html">Polar Splines</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >io</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/io/index.html">Functions used for input and output</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mapping</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mapping/index.html">Mappings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >math_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/math_tools/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >matrix_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/matrix_tools/index.html">Matrix tools</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mpi_parallelisation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mpi_parallelisation/index.html">Parallelisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/multipatch/index.html">Multipatch</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >connectivity</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/connectivity/index.html">Multipatch connectivity</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/data_types/index.html">Data Types for Multipatch Geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/spline/index.html">Spline on multipatch geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/utils/index.html">Multipatch utilitary functions</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >pde_solvers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/pde_solvers/index.html">PDE Solvers</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >quadrature</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/quadrature/index.html">Quadrature Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >speciesinfo</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/speciesinfo/index.html">SpeciesInfo (x, v_x)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >timestepper</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/timestepper/index.html">Time Stepping Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/utils/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Simulations</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../simulations/index.html">Gyselalib++ simulations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryRTheta/index.html">Simulations in (r, theta) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >diocotron</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/diocotron/index.html">Diocotron instability</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vortex_merger</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/vortex_merger/index.html">Vortex merger</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXVx/index.html">Simulations in (x, vx) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXY/index.html">Simulations in (x, y) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >guiding_centre</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryXY/guiding_centre/index.html">Guiding centre (X,Y) simulation</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tests</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tests/index.html">Gyselalib++ tests</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/advection/index.html">Tests on the templated advection operators</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/geometryRTheta/index.html">Tests : Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/advection_rtheta/index.html">Tests on the 2D polar advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/polar_poisson/index.html">Tests on the 2D polar poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline_interpolator_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/spline_interpolator_rtheta/index.html">Tests on spline interpolator in polar coordinates</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/multipatch/index.html">Multipatch geometry tests</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometries</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/multipatch/geometries/index.html">Multipatch geometries</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Adding_docs.html">Adding Docs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Using_git.html">Using Git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/developer_FAQ.html">Developer FAQ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Troubleshooting</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/troubleshooting/Common_compilation_problems.html">Compilation Issues</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Gyselalib++</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Classes</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="annotated.html">Class List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="classes.html">Class Index</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="hierarchy.html">Class Hierarchy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Namespaces</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="namespaces.html">Namespace List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_members.html">Namespace Members</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_functions.html">Namespace Member Functions</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_variables.html">Namespace Member Variables</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_typedefs.html">Namespace Member Typedefs</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_enums.html">Namespace Member Enumerations</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="files.html">Files</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">GyselalibX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">File polarpoissonlikesolver.hpp</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/gyselax/gyselalibxx/edit/main/gyselalibxx/polarpoissonlikesolver_8hpp_source.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div><h1 id="file-polarpoissonlikesolverhpp">File polarpoissonlikesolver.hpp</h1>
<p><a href="files.html"><strong>File List</strong></a> <strong>&gt;</strong> <a href="dir_be2a347b8fed8e825bae8c199ecc63c1.html"><strong>pde_solvers</strong></a> <strong>&gt;</strong> <a href="polarpoissonlikesolver_8hpp.html"><strong>polarpoissonlikesolver.hpp</strong></a></p>
<p><a href="polarpoissonlikesolver_8hpp.html">Go to the documentation of this file</a></p>
<pre><code class="language-C++">// SPDX-License-Identifier: MIT
#pragma once

#include &lt;ddc/ddc.hpp&gt;

#include "ddc_alias_inline_functions.hpp"
#include "ddc_aliases.hpp"
#include "gauss_legendre_integration.hpp"
#include "mapping_tools.hpp"
#include "math_tools.hpp"
#include "matrix_batch_csr.hpp"
#include "metric_tensor_evaluator.hpp"
#include "polar_spline.hpp"
#include "polar_spline_evaluator.hpp"
#include "quadrature_coeffs_nd.hpp"
#include "view.hpp"
#include "volume_quadrature_nd.hpp"


template &lt;
        class GridR,
        class GridTheta,
        class PolarBSplinesRTheta,
        class SplineRThetaEvaluatorNullBound,
        class IdxRangeFull = IdxRange&lt;GridR, GridTheta&gt;&gt;
class PolarSplineFEMPoissonLikeSolver
{
    // TODO: Add a batch loop to operator()
    static_assert(
            std::is_same_v&lt;IdxRangeFull, IdxRange&lt;GridR, GridTheta&gt;&gt;,
            "PolarSplineFEMPoissonLikeSolver is not yet batched");

public:
    using R = typename GridR::continuous_dimension_type;
    using Theta = typename GridTheta::continuous_dimension_type;

    static_assert(R::IS_CONTRAVARIANT);
    static_assert(Theta::IS_CONTRAVARIANT);

private:
    using R_cov = typename R::Dual;
    using Theta_cov = typename Theta::Dual;

public:
    struct RBasisSubset
    {
    };
    struct ThetaBasisSubset
    {
    };
    struct RCellDim
    {
    };
    struct ThetaCellDim
    {
    };


public:
    struct QDimRMesh : NonUniformGridBase&lt;R&gt;
    {
    };
    struct QDimThetaMesh : NonUniformGridBase&lt;Theta&gt;
    {
    };

private:
    using CoordRTheta = Coord&lt;R, Theta&gt;;
    using BSplinesR = typename PolarBSplinesRTheta::BSplinesR_tag;
    using BSplinesTheta = typename PolarBSplinesRTheta::BSplinesTheta_tag;

    using IdxRangeRTheta = IdxRange&lt;GridR, GridTheta&gt;;
    using IdxRTheta = Idx&lt;GridR, GridTheta&gt;;

    using IdxRangeBSPolar = IdxRange&lt;PolarBSplinesRTheta&gt;;
    using IdxBSPolar = Idx&lt;PolarBSplinesRTheta&gt;;

    using IdxRangeBSR = IdxRange&lt;BSplinesR&gt;;
    using IdxRangeBSTheta = IdxRange&lt;BSplinesTheta&gt;;
    using IdxRangeBSRTheta = IdxRange&lt;BSplinesR, BSplinesTheta&gt;;
    using IdxBSRTheta = Idx&lt;BSplinesR, BSplinesTheta&gt;;

    using IdxRangeBatchedBSRTheta
            = ddc::detail::convert_type_seq_to_discrete_domain_t&lt;ddc::type_seq_replace_t&lt;
                    ddc::to_type_seq_t&lt;IdxRangeFull&gt;,
                    ddc::detail::TypeSeq&lt;GridR, GridTheta&gt;,
                    ddc::detail::TypeSeq&lt;BSplinesR, BSplinesTheta&gt;&gt;&gt;;

    using IdxRangeBatch = ddc::remove_dims_of_t&lt;IdxRangeFull, IdxRange&lt;GridR&gt;, IdxRange&lt;GridTheta&gt;&gt;;

    using IdxRangeQuadratureR = IdxRange&lt;QDimRMesh&gt;;
    using IdxRangeQuadratureTheta = IdxRange&lt;QDimThetaMesh&gt;;
    using IdxRangeQuadratureRTheta = IdxRange&lt;QDimRMesh, QDimThetaMesh&gt;;
    using IdxQuadratureR = Idx&lt;QDimRMesh&gt;;
    using IdxQuadratureTheta = Idx&lt;QDimThetaMesh&gt;;
    using IdxQuadratureRTheta = Idx&lt;QDimRMesh, QDimThetaMesh&gt;;
    using IdxStepQuadratureR = IdxStep&lt;QDimRMesh&gt;;
    using IdxStepQuadratureTheta = IdxStep&lt;QDimThetaMesh&gt;;

    using KnotsR = ddc::NonUniformBsplinesKnots&lt;BSplinesR&gt;;
    using KnotsTheta = ddc::NonUniformBsplinesKnots&lt;BSplinesTheta&gt;;

    using ConstSpline2D = DConstField&lt;IdxRangeBatchedBSRTheta&gt;;
    using PolarSplineMemRTheta = PolarSplineMem&lt;PolarBSplinesRTheta&gt;;

    using CoordFieldMemRTheta = FieldMem&lt;CoordRTheta, IdxRangeRTheta&gt;;
    using CoordFieldRTheta = Field&lt;CoordRTheta, IdxRangeRTheta&gt;;
    using DFieldRTheta = DField&lt;IdxRangeRTheta&gt;;

public:
    struct EvalDeriv1DType
    {
        double value;
        double derivative;
    };

    struct EvalDeriv2DType
    {
        double value;
        DVector&lt;R_cov, Theta_cov&gt; derivative;
    };

    using IdxCell = Idx&lt;RCellDim, ThetaCellDim&gt;;

private:
    static constexpr int s_n_gauss_legendre_r = BSplinesR::degree() + 1;
    static constexpr int s_n_gauss_legendre_theta = BSplinesTheta::degree() + 1;
    // The number of cells (in the radial direction) in which both types of basis splines can be found
    static constexpr int m_n_overlap_cells = PolarBSplinesRTheta::continuity + 1;

    // Number of cells over which a radial B-splines has its support
    // This is the case for b-splines which are not affected by the higher knot multiplicity at the boundary.
    static constexpr IdxStep&lt;RBasisSubset&gt; m_n_non_zero_bases_r
            = IdxStep&lt;RBasisSubset&gt;(BSplinesR::degree() + 1);

    // Number of cells over which a poloidal B-splines has its support
    static constexpr IdxStep&lt;ThetaBasisSubset&gt; m_n_non_zero_bases_theta
            = IdxStep&lt;ThetaBasisSubset&gt;(BSplinesTheta::degree() + 1);

    static constexpr IdxRange&lt;RBasisSubset&gt; m_non_zero_bases_r
            = IdxRange&lt;RBasisSubset&gt;(Idx&lt;RBasisSubset&gt; {0}, m_n_non_zero_bases_r);
    static constexpr IdxRange&lt;ThetaBasisSubset&gt; m_non_zero_bases_theta
            = IdxRange&lt;ThetaBasisSubset&gt;(Idx&lt;ThetaBasisSubset&gt; {0}, m_n_non_zero_bases_theta);

    const int m_nbasis_r;
    const int m_nbasis_theta;

    // Matrix size is equal to the number of Polar bspline
    const int m_matrix_size;

    // Domains
    IdxRangeBSPolar m_idxrange_fem_non_singular;
    IdxRangeBSR m_idxrange_bsplines_r;
    IdxRangeBSTheta m_idxrange_bsplines_theta;

    IdxRangeQuadratureR m_idxrange_quadrature_r;
    IdxRangeQuadratureTheta m_idxrange_quadrature_theta;
    IdxRangeQuadratureRTheta m_idxrange_quadrature_singular;

    // Gauss-Legendre points and weights
    FieldMem&lt;double, IdxRangeQuadratureR&gt; m_weights_r;
    FieldMem&lt;double, IdxRangeQuadratureTheta&gt; m_weights_theta;

    // Basis Spline values and derivatives at Gauss-Legendre points
    host_t&lt;FieldMem&lt;EvalDeriv2DType, IdxRange&lt;PolarBSplinesRTheta, QDimRMesh, QDimThetaMesh&gt;&gt;&gt;
            m_singular_basis_vals_and_derivs;
    host_t&lt;FieldMem&lt;EvalDeriv1DType, IdxRange&lt;RBasisSubset, QDimRMesh&gt;&gt;&gt; m_r_basis_vals_and_derivs;
    host_t&lt;FieldMem&lt;EvalDeriv1DType, IdxRange&lt;ThetaBasisSubset, QDimThetaMesh&gt;&gt;&gt;
            m_theta_basis_vals_and_derivs;

    FieldMem&lt;double, IdxRangeQuadratureRTheta&gt; m_int_volume;

    PolarSplineEvaluator&lt;PolarBSplinesRTheta, ddc::NullExtrapolationRule&gt; m_polar_spline_evaluator;
    std::unique_ptr&lt;MatrixBatchCsr&lt;Kokkos::DefaultExecutionSpace, MatrixBatchCsrSolver::CG&gt;&gt;
            m_gko_matrix;
    mutable host_t&lt;PolarSplineMemRTheta&gt; m_phi_spline_coef;
    Kokkos::View&lt;double**, Kokkos::LayoutRight&gt; m_x_init;

    const int m_batch_idx {0}; // TODO: Remove when batching is supported
public:
    template &lt;class Mapping&gt;
    PolarSplineFEMPoissonLikeSolver(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator)
        : m_nbasis_r(ddc::discrete_space&lt;BSplinesR&gt;().nbasis() - m_n_overlap_cells - 1)
        , m_nbasis_theta(ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis())
        , m_matrix_size(ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().nbasis() - m_nbasis_theta)
        , m_idxrange_fem_non_singular(
                  ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().tensor_bspline_idx_range().remove_last(
                          IdxStep&lt;PolarBSplinesRTheta&gt; {m_nbasis_theta}))
        , m_idxrange_bsplines_r(ddc::discrete_space&lt;BSplinesR&gt;().full_domain().remove_first(
                  IdxStep&lt;BSplinesR&gt; {m_n_overlap_cells}))
        , m_idxrange_bsplines_theta(ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain().take_first(
                  IdxStep&lt;BSplinesTheta&gt; {m_nbasis_theta}))
        , m_idxrange_quadrature_r(
                  Idx&lt;QDimRMesh&gt;(0),
                  IdxStep&lt;QDimRMesh&gt;(
                          s_n_gauss_legendre_r * ddc::discrete_space&lt;BSplinesR&gt;().ncells()))
        , m_idxrange_quadrature_theta(
                  Idx&lt;QDimThetaMesh&gt;(0),
                  IdxStep&lt;QDimThetaMesh&gt;(
                          s_n_gauss_legendre_theta * ddc::discrete_space&lt;BSplinesTheta&gt;().ncells()))
        , m_idxrange_quadrature_singular(
                  m_idxrange_quadrature_r.take_first(
                          IdxStep&lt;QDimRMesh&gt; {m_n_overlap_cells * s_n_gauss_legendre_r}),
                  m_idxrange_quadrature_theta)
        , m_weights_r(m_idxrange_quadrature_r)
        , m_weights_theta(m_idxrange_quadrature_theta)
        , m_singular_basis_vals_and_derivs(IdxRange&lt;PolarBSplinesRTheta, QDimRMesh, QDimThetaMesh&gt;(
                  PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;(),
                  ddc::select&lt;QDimRMesh&gt;(m_idxrange_quadrature_singular),
                  ddc::select&lt;QDimThetaMesh&gt;(m_idxrange_quadrature_singular)))
        , m_r_basis_vals_and_derivs(
                  IdxRange&lt;RBasisSubset, QDimRMesh&gt;(m_non_zero_bases_r, m_idxrange_quadrature_r))
        , m_theta_basis_vals_and_derivs(
                  IdxRange&lt;
                          ThetaBasisSubset,
                          QDimThetaMesh&gt;(m_non_zero_bases_theta, m_idxrange_quadrature_theta))
        , m_polar_spline_evaluator(ddc::NullExtrapolationRule())
        , m_phi_spline_coef(
                  PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;(),
                  IdxRangeBSRTheta(
                          m_idxrange_bsplines_r,
                          ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain()))
        , m_x_init(
                  "x_init",
                  1,
                  ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().nbasis()
                          - ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis())
    {
        static_assert(has_jacobian_v&lt;Mapping, CoordRTheta&gt;);
        //initialise x_init
        Kokkos::deep_copy(m_x_init, 0);
        // Get break points
        IdxRange&lt;KnotsR&gt; idxrange_r_edges = ddc::discrete_space&lt;BSplinesR&gt;().break_point_domain();
        IdxRange&lt;KnotsTheta&gt; idxrange_theta_edges
                = ddc::discrete_space&lt;BSplinesTheta&gt;().break_point_domain();
        host_t&lt;FieldMem&lt;Coord&lt;R&gt;, IdxRange&lt;KnotsR&gt;&gt;&gt; breaks_r(idxrange_r_edges);
        host_t&lt;FieldMem&lt;Coord&lt;Theta&gt;, IdxRange&lt;KnotsTheta&gt;&gt;&gt; breaks_theta(idxrange_theta_edges);

        ddcHelper::dump_coordinates(Kokkos::DefaultHostExecutionSpace(), get_field(breaks_r));
        ddcHelper::dump_coordinates(Kokkos::DefaultHostExecutionSpace(), get_field(breaks_theta));

        // Define quadrature points and weights
        GaussLegendre&lt;QDimRMesh, s_n_gauss_legendre_r&gt; gl_coeffs_r(get_const_field(breaks_r));
        GaussLegendre&lt;QDimThetaMesh, s_n_gauss_legendre_theta&gt; gl_coeffs_theta(
                get_const_field(breaks_theta));
        m_int_volume = compute_coeffs_on_mapping(
                Kokkos::DefaultExecutionSpace(),
                mapping,
                gauss_legendre_quadrature_coefficients&lt;
                        Kokkos::DefaultExecutionSpace&gt;(gl_coeffs_r, gl_coeffs_theta));

        // Find value and derivative of 1D B-splines in radial direction
        ddc::for_each(m_idxrange_quadrature_r, [&amp;](IdxQuadratureR const idx_r) {
            std::array&lt;double, 2 * m_n_non_zero_bases_r&gt; data;
            DSpan2D vals(data.data(), m_n_non_zero_bases_r, 2);
            ddc::discrete_space&lt;BSplinesR&gt;()
                    .eval_basis_and_n_derivs(vals, ddc::coordinate(idx_r), 1);
            for (auto ib : m_non_zero_bases_r) {
                const int ib_idx = ib - m_non_zero_bases_r.front();
                m_r_basis_vals_and_derivs(ib, idx_r).value = vals(ib_idx, 0);
                m_r_basis_vals_and_derivs(ib, idx_r).derivative = vals(ib_idx, 1);
            }
        });

        // Find value and derivative of 1D B-splines in poloidal direction
        ddc::for_each(m_idxrange_quadrature_theta, [&amp;](IdxQuadratureTheta const idx_theta) {
            std::array&lt;double, 2 * m_n_non_zero_bases_theta&gt; data;
            DSpan2D vals(data.data(), m_n_non_zero_bases_theta, 2);
            ddc::discrete_space&lt;BSplinesTheta&gt;()
                    .eval_basis_and_n_derivs(vals, ddc::coordinate(idx_theta), 1);
            for (auto ib : m_non_zero_bases_theta) {
                const int ib_idx = ib - m_non_zero_bases_theta.front();
                m_theta_basis_vals_and_derivs(ib, idx_theta).value = vals(ib_idx, 0);
                m_theta_basis_vals_and_derivs(ib, idx_theta).derivative = vals(ib_idx, 1);
            }
        });

        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();

        // Find value and derivative of 2D B-splines covering the singular point
        ddc::for_each(m_idxrange_quadrature_singular, [&amp;](IdxQuadratureRTheta const irtheta) {
            std::array&lt;double, PolarBSplinesRTheta::n_singular_basis()&gt; singular_data;
            std::array&lt;double, m_n_non_zero_bases_r * m_n_non_zero_bases_theta&gt; data;
            // Values of the polar basis splines around the singular point
            // at a given coordinate
            DSpan1D singular_vals(singular_data.data(), PolarBSplinesRTheta::n_singular_basis());
            // Values of the polar basis splines, that do not cover the singular point,
            // at a given coordinate
            DSpan2D vals(data.data(), m_n_non_zero_bases_r, m_n_non_zero_bases_theta);
            IdxQuadratureR const idx_r(irtheta);
            IdxQuadratureTheta const idx_theta(irtheta);

            const CoordRTheta coord(ddc::coordinate(irtheta));

            // Calculate the value
            ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().eval_basis(singular_vals, vals, coord);
            for (IdxBSPolar ib : idxrange_singular) {
                m_singular_basis_vals_and_derivs(ib, idx_r, idx_theta).value
                        = singular_vals[ib - idxrange_singular.front()];
            }

            // Calculate the radial derivative
            ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().eval_deriv_r(singular_vals, vals, coord);
            for (IdxBSPolar ib : idxrange_singular) {
                ddcHelper::get&lt;R_cov&gt;(
                        m_singular_basis_vals_and_derivs(ib, idx_r, idx_theta).derivative)
                        = singular_vals[ib - idxrange_singular.front()];
            }

            // Calculate the poloidal derivative
            ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().eval_deriv_theta(singular_vals, vals, coord);
            for (IdxBSPolar ib : idxrange_singular) {
                ddcHelper::get&lt;Theta_cov&gt;(
                        m_singular_basis_vals_and_derivs(ib, idx_r, idx_theta).derivative)
                        = singular_vals[ib - idxrange_singular.front()];
            }
        });

        // Number of elements in the matrix that correspond to the splines
        // that cover the singular point
        constexpr int n_elements_singular
                = PolarBSplinesRTheta::n_singular_basis() * PolarBSplinesRTheta::n_singular_basis();
        // Number of non-zero elements in the matrix corresponding to the inner product of
        // polar splines at the singular point and the other splines
        const int n_elements_overlap = 2
                                       * (PolarBSplinesRTheta::n_singular_basis()
                                          * BSplinesR::degree() * m_nbasis_theta);
        const int n_stencil_theta
                = m_nbasis_theta * min(int(1 + 2 * BSplinesTheta::degree()), m_nbasis_theta);
        const int n_stencil_r = m_nbasis_r * (1 + 2 * BSplinesR::degree())
                                - (1 + BSplinesR::degree()) * BSplinesR::degree();
        // Number of non-zero elements in the matrix corresponding to the inner product of
        // non-central splines. These have a tensor product structure
        const int n_elements_stencil = n_stencil_r * n_stencil_theta;

        const int batch_size = 1;

        const int n_matrix_elements = n_elements_singular + n_elements_overlap + n_elements_stencil;

        //CSR data storage
        Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                values_csr_host("values_csr", batch_size, n_matrix_elements);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                col_idx_csr_host("idx_csr", n_matrix_elements);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::DefaultExecutionSpace&gt;
                nnz_per_row_csr("nnz_per_row_csr", m_matrix_size + 1);
        Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                nnz_per_row_csr_host("nnz_per_row_csr", m_matrix_size + 1);

        m_gko_matrix = std::make_unique&lt;MatrixBatchCsr&lt;
                Kokkos::DefaultExecutionSpace,
                MatrixBatchCsrSolver::CG&gt;&gt;(1, m_matrix_size, n_matrix_elements);
        auto [values, col_idx, nnz_per_row] = m_gko_matrix-&gt;get_batch_csr();
        init_nnz_per_line(nnz_per_row);
        Kokkos::deep_copy(nnz_per_row_csr_host, nnz_per_row);

        compute_singular_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);
        compute_overlapping_singular_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);
        compute_stencil_elements(
                coeff_alpha,
                coeff_beta,
                mapping,
                spline_evaluator,
                values_csr_host,
                col_idx_csr_host,
                nnz_per_row_csr_host);

        assert(nnz_per_row_csr_host(m_matrix_size) == n_matrix_elements);
        Kokkos::deep_copy(values, values_csr_host);
        Kokkos::deep_copy(col_idx, col_idx_csr_host);
        Kokkos::deep_copy(nnz_per_row, nnz_per_row_csr_host);
        m_gko_matrix-&gt;setup_solver();
    }

    template &lt;class Mapping&gt;
    void compute_singular_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();
        IdxRangeQuadratureRTheta idxrange_quadrature_singular = m_idxrange_quadrature_singular;

        auto singular_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_singular_basis_vals_and_derivs));
        auto r_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_r_basis_vals_and_derivs));
        Field&lt;EvalDeriv2DType, IdxRange&lt;PolarBSplinesRTheta, QDimRMesh, QDimThetaMesh&gt;&gt;
                singular_basis_vals_and_derivs = get_field(singular_basis_vals_and_derivs_alloc);
        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume);

        Kokkos::Profiling::pushRegion("PolarPoissonFillFemMatrix");
        // Calculate the matrix elements corresponding to the B-splines which cover the singular point
        ddc::for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_test) {
            ddc::for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_trial) {
                // Calculate the weak integral
                double const element = ddc::parallel_transform_reduce(
                        Kokkos::DefaultExecutionSpace(),
                        idxrange_quadrature_singular,
                        0.0,
                        ddc::reducer::sum&lt;double&gt;(),
                        KOKKOS_LAMBDA(Idx&lt;QDimRMesh, QDimThetaMesh&gt; const&amp; idx_quad) {
                            Idx&lt;QDimRMesh&gt; const idx_r(idx_quad);
                            Idx&lt;QDimThetaMesh&gt; const idx_theta(idx_quad);
                            return weak_integral_element(
                                    idx_r,
                                    idx_theta,
                                    singular_basis_vals_and_derivs(idx_test, idx_r, idx_theta),
                                    singular_basis_vals_and_derivs(idx_trial, idx_r, idx_theta),
                                    coeff_alpha,
                                    coeff_beta,
                                    spline_evaluator,
                                    mapping,
                                    int_volume_proxy);
                        });
                const int row_idx = idx_test - idxrange_singular.front();
                const int col_idx = idx_trial - idxrange_singular.front();
                const int csr_idx_singular_area = nnz_per_row_csr_host(row_idx + 1);
                //Fill the C matrix corresponding to the splines on the singular point
                col_idx_csr_host(csr_idx_singular_area) = col_idx;
                values_csr_host(m_batch_idx, csr_idx_singular_area) = element;
                nnz_per_row_csr_host(row_idx + 1)++;
            });
        });
    }

    template &lt;class Mapping&gt;
    void compute_overlapping_singular_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        // Create index ranges associated with the 2D splines
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();
        IdxRangeBSR central_radial_bspline_idx_range(
                m_idxrange_bsplines_r.take_first(IdxStep&lt;BSplinesR&gt; {BSplinesR::degree()}));

        IdxRangeBSRTheta idxrange_non_singular_near_centre(
                central_radial_bspline_idx_range,
                m_idxrange_bsplines_theta);

        auto singular_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_singular_basis_vals_and_derivs));
        auto r_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_r_basis_vals_and_derivs));
        auto theta_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_theta_basis_vals_and_derivs));
        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume);
        Field&lt;EvalDeriv2DType, IdxRange&lt;PolarBSplinesRTheta, QDimRMesh, QDimThetaMesh&gt;&gt;
                singular_basis_vals_and_derivs = get_field(singular_basis_vals_and_derivs_alloc);
        Field&lt;EvalDeriv1DType, IdxRange&lt;RBasisSubset, QDimRMesh&gt;&gt; r_basis_vals_and_derivs
                = get_field(r_basis_vals_and_derivs_alloc);
        Field&lt;EvalDeriv1DType, IdxRange&lt;ThetaBasisSubset, QDimThetaMesh&gt;&gt;
                theta_basis_vals_and_derivs = get_field(theta_basis_vals_and_derivs_alloc);
        // Calculate the matrix elements where bspline products overlap the B-splines which cover the singular point
        ddc::for_each(idxrange_singular, [&amp;](IdxBSPolar const idx_test) {
            ddc::for_each(idxrange_non_singular_near_centre, [&amp;](IdxBSRTheta const idx_trial) {
                const IdxBSPolar idx_trial_polar(
                        PolarBSplinesRTheta::template get_polar_index&lt;PolarBSplinesRTheta&gt;(
                                idx_trial));
                const Idx&lt;BSplinesR&gt; idx_trial_r(ddc::select&lt;BSplinesR&gt;(idx_trial));
                const Idx&lt;BSplinesTheta&gt; idx_trial_theta(ddc::select&lt;BSplinesTheta&gt;(idx_trial));

                // Find the index range covering the cells where both the test and trial functions are non-zero
                const Idx&lt;RCellDim&gt; first_overlap_element_r(
                        idx_trial_r.uid() &lt; BSplinesR::degree()
                                ? 0
                                : idx_trial_r.uid() - BSplinesR::degree());
                const Idx&lt;ThetaCellDim&gt; first_overlap_element_theta(
                        theta_mod(idx_trial_theta.uid() - BSplinesTheta::degree()));

                const IdxStep&lt;RCellDim&gt; n_overlap_r(
                        m_n_overlap_cells - first_overlap_element_r.uid());
                const IdxStep&lt;ThetaCellDim&gt; n_overlap_theta(BSplinesTheta::degree() + 1);

                const IdxRange&lt;RCellDim&gt; r_cells(first_overlap_element_r, n_overlap_r);
                const IdxRange&lt;ThetaCellDim&gt;
                        theta_cells(first_overlap_element_theta, n_overlap_theta);
                const IdxRange&lt;RCellDim, ThetaCellDim&gt; non_zero_cells(r_cells, theta_cells);

                if (n_overlap_r &gt; 0) {
                    double element = 0.0;

                    ddc::for_each(non_zero_cells, [&amp;](IdxCell const cell_idx) {
                        const int cell_idx_r(ddc::select&lt;RCellDim&gt;(cell_idx).uid());
                        const int cell_idx_theta(
                                theta_mod(ddc::select&lt;ThetaCellDim&gt;(cell_idx).uid()));

                        const IdxRangeQuadratureRTheta cell_quad_points(
                                get_quadrature_points_in_cell(cell_idx_r, cell_idx_theta));
                        // Find the column where the non-zero data is stored
                        Idx&lt;RBasisSubset&gt; ib_trial_r(idx_trial_r.uid() - cell_idx_r);
                        Idx&lt;ThetaBasisSubset&gt; ib_trial_theta(
                                theta_mod(idx_trial_theta.uid() - cell_idx_theta));
                        // Calculate the weak integral
                        element += ddc::parallel_transform_reduce(
                                Kokkos::DefaultExecutionSpace(),
                                cell_quad_points,
                                0.0,
                                ddc::reducer::sum&lt;double&gt;(),
                                KOKKOS_LAMBDA(IdxQuadratureRTheta const idx_quad) {
                                    IdxQuadratureR const idx_r(idx_quad);
                                    IdxQuadratureTheta const idx_theta(idx_quad);
                                    return weak_integral_element&lt;Mapping&gt;(
                                            idx_r,
                                            idx_theta,
                                            singular_basis_vals_and_derivs(
                                                    idx_test,
                                                    idx_r,
                                                    idx_theta),
                                            r_basis_vals_and_derivs(ib_trial_r, idx_r),
                                            theta_basis_vals_and_derivs(ib_trial_theta, idx_theta),
                                            coeff_alpha,
                                            coeff_beta,
                                            spline_evaluator,
                                            mapping,
                                            int_volume_proxy);
                                });
                    });

                    int const row_idx = idx_test - idxrange_singular.front();
                    int const col_idx = idx_trial_polar - idxrange_singular.front();
                    //a_ij
                    col_idx_csr_host(nnz_per_row_csr_host(row_idx + 1)) = col_idx;
                    values_csr_host(m_batch_idx, nnz_per_row_csr_host(row_idx + 1)) = element;
                    nnz_per_row_csr_host(row_idx + 1)++;
                    //a_ji
                    col_idx_csr_host(nnz_per_row_csr_host(col_idx + 1)) = row_idx;
                    values_csr_host(m_batch_idx, nnz_per_row_csr_host(col_idx + 1)) = element;
                    nnz_per_row_csr_host(col_idx + 1)++;
                }
            });
        });
    }

    template &lt;class Mapping&gt;
    void compute_stencil_elements(
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            Mapping const&amp; mapping,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const values_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const col_idx_csr_host,
            Kokkos::View&lt;int*, Kokkos::LayoutRight, Kokkos::HostSpace&gt; const nnz_per_row_csr_host)
    {
        IdxRangeBSPolar idxrange_singular
                = PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;();

        // Calculate the matrix elements following a stencil
        ddc::for_each(m_idxrange_fem_non_singular, [&amp;](IdxBSPolar const idx_test_polar) {
            const IdxBSRTheta idx_test(PolarBSplinesRTheta::get_2d_index(idx_test_polar));
            const std::size_t idx_test_r(ddc::select&lt;BSplinesR&gt;(idx_test).uid());
            const std::size_t idx_test_theta(ddc::select&lt;BSplinesTheta&gt;(idx_test).uid());

            // Calculate the index of the elements that are already filled
            IdxRangeBSTheta remaining_theta(
                    Idx&lt;BSplinesTheta&gt; {idx_test_theta},
                    IdxStep&lt;BSplinesTheta&gt; {BSplinesTheta::degree() + 1});
            ddc::for_each(remaining_theta, [&amp;](Idx&lt;BSplinesTheta&gt; const idx_trial_theta) {
                IdxBSRTheta idx_trial(Idx&lt;BSplinesR&gt;(idx_test_r), idx_trial_theta);
                IdxBSPolar idx_trial_polar(
                        PolarBSplinesRTheta::template get_polar_index&lt;PolarBSplinesRTheta&gt;(
                                IdxBSRTheta(idx_test_r, theta_mod(idx_trial_theta.uid()))));
                double element = get_matrix_stencil_element(
                        idx_test,
                        idx_trial,
                        coeff_alpha,
                        coeff_beta,
                        spline_evaluator,
                        mapping);
                int const int_polar_idx_test = idx_test_polar - idxrange_singular.front();
                if (idx_test_polar == idx_trial_polar) {
                    const int idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;
                } else {
                    int const int_polar_idx_trial = idx_trial_polar - idxrange_singular.front();

                    const int aij_idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(aij_idx) = int_polar_idx_trial;
                    values_csr_host(m_batch_idx, aij_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;

                    const int aji_idx = nnz_per_row_csr_host(int_polar_idx_trial + 1);
                    col_idx_csr_host(aji_idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, aji_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_trial + 1)++;
                }
            });
            IdxRangeBSR remaining_r(
                    ddc::select&lt;BSplinesR&gt;(idx_test) + 1,
                    IdxStep&lt;BSplinesR&gt; {
                            min(BSplinesR::degree(),
                                ddc::discrete_space&lt;BSplinesR&gt;().nbasis() - 2 - idx_test_r)});
            IdxRangeBSTheta relevant_theta(
                    Idx&lt;BSplinesTheta&gt; {
                            idx_test_theta + ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis()
                            - BSplinesTheta::degree()},
                    IdxStep&lt;BSplinesTheta&gt; {2 * BSplinesTheta::degree() + 1});

            IdxRangeBSRTheta trial_idx_range(remaining_r, relevant_theta);

            ddc::for_each(trial_idx_range, [&amp;](IdxBSRTheta const idx_trial) {
                const int idx_trial_r(ddc::select&lt;BSplinesR&gt;(idx_trial).uid());
                const int idx_trial_theta(ddc::select&lt;BSplinesTheta&gt;(idx_trial).uid());
                IdxBSPolar idx_trial_polar(
                        PolarBSplinesRTheta::template get_polar_index&lt;PolarBSplinesRTheta&gt;(
                                IdxBSRTheta(idx_trial_r, theta_mod(idx_trial_theta))));
                double element = get_matrix_stencil_element(
                        idx_test,
                        idx_trial,
                        coeff_alpha,
                        coeff_beta,
                        spline_evaluator,
                        mapping);
                int const int_polar_idx_test = idx_test_polar - idxrange_singular.front();
                if (idx_test_polar == idx_trial_polar) {
                    const int idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;
                } else {
                    int const int_polar_idx_trial = idx_trial_polar - idxrange_singular.front();
                    const int aij_idx = nnz_per_row_csr_host(int_polar_idx_test + 1);
                    col_idx_csr_host(aij_idx) = int_polar_idx_trial;
                    values_csr_host(m_batch_idx, aij_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_test + 1)++;

                    const int aji_idx = nnz_per_row_csr_host(int_polar_idx_trial + 1);
                    col_idx_csr_host(aji_idx) = int_polar_idx_test;
                    values_csr_host(m_batch_idx, aji_idx) = element;
                    nnz_per_row_csr_host(int_polar_idx_trial + 1)++;
                }
            });
        });

        Kokkos::Profiling::popRegion();
    }
    template &lt;class RHSFunction&gt;
    void operator()(RHSFunction const&amp; rhs, host_t&lt;PolarSplineMemRTheta&gt;&amp; spline) const
    {
        Kokkos::Profiling::pushRegion("PolarPoissonRHS");

        static_assert(
                std::is_invocable_r_v&lt;double, RHSFunction, CoordRTheta&gt;,
                "RHSFunction must have an operator() which takes a coordinate and returns a "
                "double");
        const int b_size = ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().nbasis()
                           - ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        const int batch_size = 1;
        // Create b for rhs
        Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                b_host("b_host", batch_size, b_size);
        //Create an initial guess
        Kokkos::View&lt;double**, Kokkos::LayoutRight, Kokkos::HostSpace&gt;
                x_init_host("x_init_host", batch_size, b_size);
        // Fill b
        auto int_volume_host = ddc::create_mirror_view_and_copy(get_field(m_int_volume));
        ddc::for_each(
                PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;(),
                [&amp;](IdxBSPolar const idx) {
                    const int bspl_idx = idx
                                         - PolarBSplinesRTheta::template singular_idx_range&lt;
                                                   PolarBSplinesRTheta&gt;()
                                                   .front();
                    b_host(0, bspl_idx) = ddc::transform_reduce(
                            m_idxrange_quadrature_singular,
                            0.0,
                            ddc::reducer::sum&lt;double&gt;(),
                            [&amp;](IdxQuadratureRTheta const idx_quad) {
                                IdxQuadratureR const idx_r(idx_quad);
                                IdxQuadratureTheta const idx_theta(idx_quad);
                                CoordRTheta coord(ddc::coordinate(idx_quad));
                                return rhs(coord)
                                       * m_singular_basis_vals_and_derivs(idx, idx_r, idx_theta)
                                                 .value
                                       * int_volume_host(idx_r, idx_theta);
                            });
                });
        const std::size_t ncells_r = ddc::discrete_space&lt;BSplinesR&gt;().ncells();

        ddc::for_each(m_idxrange_fem_non_singular, [&amp;](IdxBSPolar const idx) {
            const IdxBSRTheta idx_2d(PolarBSplinesRTheta::get_2d_index(idx));
            const std::size_t idx_r(ddc::select&lt;BSplinesR&gt;(idx_2d).uid());
            const std::size_t idx_theta(ddc::select&lt;BSplinesTheta&gt;(idx_2d).uid());

            // Find the cells on which the bspline is non-zero
            int first_cell_r(idx_r - BSplinesR::degree());
            int first_cell_theta(idx_theta - BSplinesTheta::degree());
            std::size_t last_cell_r(idx_r + 1);
            if (first_cell_r &lt; 0)
                first_cell_r = 0;
            if (last_cell_r &gt; ncells_r)
                last_cell_r = ncells_r;
            IdxStep&lt;RCellDim&gt; const r_length(last_cell_r - first_cell_r);
            IdxStep&lt;ThetaCellDim&gt; const theta_length(BSplinesTheta::degree() + 1);


            Idx&lt;RCellDim&gt; const start_r(first_cell_r);
            Idx&lt;ThetaCellDim&gt; const start_theta(theta_mod(first_cell_theta));
            const IdxRange&lt;RCellDim&gt; r_cells(start_r, r_length);
            const IdxRange&lt;ThetaCellDim&gt; theta_cells(start_theta, theta_length);
            const IdxRange&lt;RCellDim, ThetaCellDim&gt; non_zero_cells(r_cells, theta_cells);
            assert(r_length * theta_length &gt; 0);
            double element = 0.0;
            ddc::for_each(non_zero_cells, [&amp;](IdxCell const cell_idx) {
                const int cell_idx_r(ddc::select&lt;RCellDim&gt;(cell_idx).uid());
                const int cell_idx_theta(theta_mod(ddc::select&lt;ThetaCellDim&gt;(cell_idx).uid()));

                const IdxRangeQuadratureRTheta cell_quad_points(
                        get_quadrature_points_in_cell(cell_idx_r, cell_idx_theta));

                // Find the column where the non-zero data is stored
                Idx&lt;RBasisSubset&gt; ib_r(idx_r - cell_idx_r);
                Idx&lt;ThetaBasisSubset&gt; ib_theta(theta_mod(idx_theta - cell_idx_theta));

                // Calculate the weak integral
                element += ddc::transform_reduce(
                        cell_quad_points,
                        0.0,
                        ddc::reducer::sum&lt;double&gt;(),
                        [&amp;](IdxQuadratureRTheta const idx_quad) {
                            IdxQuadratureR const idx_r(idx_quad);
                            IdxQuadratureTheta const idx_theta(idx_quad);
                            CoordRTheta coord(ddc::coordinate(idx_quad));
                            double rb = m_r_basis_vals_and_derivs(ib_r, idx_r).value;
                            double pb = m_theta_basis_vals_and_derivs(ib_theta, idx_theta).value;
                            return rhs(coord) * rb * pb * int_volume_host(idx_r, idx_theta);
                        });
            });
            const std::size_t singular_index
                    = idx - ddc::discrete_space&lt;PolarBSplinesRTheta&gt;().full_domain().front();
            b_host(0, singular_index) = element;
        });

        Kokkos::View&lt;double**, Kokkos::LayoutRight&gt; b("b", batch_size, b_size);
        Kokkos::deep_copy(b, b_host);
        Kokkos::Profiling::popRegion();

        Kokkos::deep_copy(m_x_init, x_init_host);
        // Solve the matrix equation
        Kokkos::Profiling::pushRegion("PolarPoissonSolve");
        m_gko_matrix-&gt;solve(m_x_init, b);
        Kokkos::deep_copy(x_init_host, m_x_init);
        //-----------------
        IdxRangeBSRTheta dirichlet_boundary_idx_range(
                m_idxrange_bsplines_r.take_last(IdxStep&lt;BSplinesR&gt; {1}),
                m_idxrange_bsplines_theta);
        IdxRangeBSTheta idxrange_polar(ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain());

        // Fill the spline
        ddc::for_each(
                PolarBSplinesRTheta::template singular_idx_range&lt;PolarBSplinesRTheta&gt;(),
                [&amp;](IdxBSPolar const idx) {
                    const int bspl_idx = idx
                                         - PolarBSplinesRTheta::template singular_idx_range&lt;
                                                   PolarBSplinesRTheta&gt;()
                                                   .front();
                    spline.singular_spline_coef(idx) = x_init_host(0, bspl_idx);
                });
        ddc::for_each(m_idxrange_fem_non_singular, [&amp;](IdxBSPolar const idx) {
            const IdxBSRTheta idx_2d(PolarBSplinesRTheta::get_2d_index(idx));
            spline.spline_coef(idx_2d) = x_init_host(0, idx.uid());
        });
        ddc::for_each(dirichlet_boundary_idx_range, [&amp;](IdxBSRTheta const idx) {
            spline.spline_coef(idx) = 0.0;
        });

        // Copy the periodic elements
        IdxRangeBSRTheta copy_idx_range(
                m_idxrange_bsplines_r,
                idxrange_polar.remove_first(
                        IdxStep&lt;BSplinesTheta&gt;(ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis())));
        ddc::for_each(copy_idx_range, [&amp;](IdxBSRTheta const idx_2d) {
            spline.spline_coef(ddc::select&lt;BSplinesR&gt;(idx_2d), ddc::select&lt;BSplinesTheta&gt;(idx_2d))
                    = spline.spline_coef(
                            ddc::select&lt;BSplinesR&gt;(idx_2d),
                            ddc::select&lt;BSplinesTheta&gt;(idx_2d)
                                    - ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis());
        });
        Kokkos::Profiling::popRegion();
    }

    template &lt;class RHSFunction&gt;
    void operator()(RHSFunction const&amp; rhs, DFieldRTheta phi) const
    {
        static_assert(
                std::is_invocable_r_v&lt;double, RHSFunction, CoordRTheta&gt;,
                "RHSFunction must have an operator() which takes a coordinate and returns a "
                "double");

        (*this)(rhs, m_phi_spline_coef);
        CoordFieldMemRTheta coords_eval_alloc(get_idx_range(phi));
        CoordFieldRTheta coords_eval(get_field(coords_eval_alloc));
        ddc::parallel_for_each(
                Kokkos::DefaultExecutionSpace(),
                get_idx_range(phi),
                KOKKOS_LAMBDA(IdxRTheta idx) { coords_eval(idx) = ddc::coordinate(idx); });
        auto coords_eval_host = ddc::create_mirror_and_copy(coords_eval);
        auto phi_host = ddc::create_mirror_and_copy(phi);
        m_polar_spline_evaluator(
                get_field(phi_host),
                get_const_field(coords_eval_host),
                get_const_field(m_phi_spline_coef));
        ddc::parallel_deepcopy(phi, phi_host);
    }

    static KOKKOS_FUNCTION IdxRangeQuadratureRTheta
    get_quadrature_points_in_cell(int cell_idx_r, int cell_idx_theta)
    {
        const IdxQuadratureR first_quad_point_r(cell_idx_r * s_n_gauss_legendre_r);
        const IdxQuadratureTheta first_quad_point_theta(cell_idx_theta * s_n_gauss_legendre_theta);
        constexpr IdxStepQuadratureR n_GL_r(s_n_gauss_legendre_r);
        constexpr IdxStepQuadratureTheta n_GL_theta(s_n_gauss_legendre_theta);
        const IdxRangeQuadratureR quad_points_r(first_quad_point_r, n_GL_r);
        const IdxRangeQuadratureTheta quad_points_theta(first_quad_point_theta, n_GL_theta);
        return IdxRangeQuadratureRTheta(quad_points_r, quad_points_theta);
    }

    template &lt;class Mapping&gt;
    static KOKKOS_FUNCTION double weak_integral_element(
            IdxQuadratureR idx_r,
            IdxQuadratureTheta idx_theta,
            EvalDeriv2DType const&amp; test_bspline_val_and_deriv,
            EvalDeriv2DType const&amp; trial_bspline_val_and_deriv,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        return templated_weak_integral_element(
                idx_r,
                idx_theta,
                test_bspline_val_and_deriv,
                trial_bspline_val_and_deriv,
                test_bspline_val_and_deriv,
                trial_bspline_val_and_deriv,
                coeff_alpha,
                coeff_beta,
                evaluator,
                mapping,
                int_volume);
    }

    template &lt;class Mapping&gt;
    static KOKKOS_FUNCTION double weak_integral_element(
            IdxQuadratureR idx_r,
            IdxQuadratureTheta idx_theta,
            EvalDeriv2DType const&amp; test_bspline_val_and_deriv,
            EvalDeriv1DType const&amp; trial_bspline_val_and_deriv_r,
            EvalDeriv1DType const&amp; trial_bspline_val_and_deriv_theta,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        return templated_weak_integral_element(
                idx_r,
                idx_theta,
                test_bspline_val_and_deriv,
                trial_bspline_val_and_deriv_r,
                test_bspline_val_and_deriv,
                trial_bspline_val_and_deriv_theta,
                coeff_alpha,
                coeff_beta,
                evaluator,
                mapping,
                int_volume);
    }

    template &lt;class Mapping&gt;
    static KOKKOS_FUNCTION double weak_integral_element(
            IdxQuadratureR idx_r,
            IdxQuadratureTheta idx_theta,
            EvalDeriv1DType const&amp; test_bspline_val_and_deriv_r,
            EvalDeriv2DType const&amp; trial_bspline_val_and_deriv,
            EvalDeriv1DType const&amp; test_bspline_val_and_deriv_theta,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        return templated_weak_integral_element(
                idx_r,
                idx_theta,
                test_bspline_val_and_deriv_r,
                trial_bspline_val_and_deriv,
                test_bspline_val_and_deriv_theta,
                trial_bspline_val_and_deriv,
                coeff_alpha,
                coeff_beta,
                evaluator,
                mapping,
                int_volume);
    }

    template &lt;class Mapping&gt;
    static KOKKOS_FUNCTION double weak_integral_element(
            IdxQuadratureR idx_r,
            IdxQuadratureTheta idx_theta,
            EvalDeriv1DType const&amp; test_bspline_val_and_deriv_r,
            EvalDeriv1DType const&amp; trial_bspline_val_and_deriv_r,
            EvalDeriv1DType const&amp; test_bspline_val_and_deriv_theta,
            EvalDeriv1DType const&amp; trial_bspline_val_and_deriv_theta,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        return templated_weak_integral_element(
                idx_r,
                idx_theta,
                test_bspline_val_and_deriv_r,
                trial_bspline_val_and_deriv_r,
                test_bspline_val_and_deriv_theta,
                trial_bspline_val_and_deriv_theta,
                coeff_alpha,
                coeff_beta,
                evaluator,
                mapping,
                int_volume);
    }

    static KOKKOS_INLINE_FUNCTION void get_value_and_gradient(
            double&amp; value,
            DVector&lt;R_cov, Theta_cov&gt;&amp; derivs,
            EvalDeriv1DType const&amp; r_basis,
            EvalDeriv1DType const&amp; theta_basis)
    {
        value = r_basis.value * theta_basis.value;
        ddcHelper::get&lt;R_cov&gt;(derivs) = r_basis.derivative * theta_basis.value;
        ddcHelper::get&lt;Theta_cov&gt;(derivs) = r_basis.value * theta_basis.derivative;
    }

    static KOKKOS_INLINE_FUNCTION void get_value_and_gradient(
            double&amp; value,
            DVector&lt;R_cov, Theta_cov&gt;&amp; derivs,
            EvalDeriv2DType const&amp; basis,
            EvalDeriv2DType const&amp;) // Last argument is duplicate
    {
        value = basis.value;
        derivs = basis.derivative;
    }

    template &lt;class Mapping, class TestValDerivType, class TrialValDerivType&gt;
    static KOKKOS_FUNCTION double templated_weak_integral_element(
            IdxQuadratureR idx_r,
            IdxQuadratureTheta idx_theta,
            TestValDerivType const&amp; test_bspline_val_and_deriv,
            TrialValDerivType const&amp; trial_bspline_val_and_deriv,
            TestValDerivType const&amp; test_bspline_val_and_deriv_theta,
            TrialValDerivType const&amp; trial_bspline_val_and_deriv_theta,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; spline_evaluator,
            Mapping const&amp; mapping,
            DField&lt;IdxRangeQuadratureRTheta&gt; int_volume)
    {
        static_assert(
                std::is_same_v&lt;
                        TestValDerivType,
                        EvalDeriv1DType&gt; || std::is_same_v&lt;TestValDerivType, EvalDeriv2DType&gt;);
        static_assert(
                std::is_same_v&lt;
                        TrialValDerivType,
                        EvalDeriv1DType&gt; || std::is_same_v&lt;TrialValDerivType, EvalDeriv2DType&gt;);

        // Calculate coefficients at quadrature point
        CoordRTheta coord(ddc::coordinate(idx_r), ddc::coordinate(idx_theta));
        const double alpha = spline_evaluator(coord, coeff_alpha);
        const double beta = spline_evaluator(coord, coeff_beta);

        // Define the value and gradient of the test and trial basis functions
        double basis_val_test_space;
        double basis_val_trial_space;
        DVector&lt;R_cov, Theta_cov&gt; basis_derivs_test_space;
        DVector&lt;R_cov, Theta_cov&gt; basis_derivs_trial_space;
        get_value_and_gradient(
                basis_val_test_space,
                basis_derivs_test_space,
                test_bspline_val_and_deriv,
                test_bspline_val_and_deriv_theta);
        get_value_and_gradient(
                basis_val_trial_space,
                basis_derivs_trial_space,
                trial_bspline_val_and_deriv,
                trial_bspline_val_and_deriv_theta);

        MetricTensorEvaluator&lt;Mapping, CoordRTheta&gt; get_metric_tensor(mapping);

        Tensor inv_metric_tensor = get_metric_tensor.inverse(coord);

        // Assemble the weak integral element
        return int_volume(idx_r, idx_theta)
               * (alpha
                          * tensor_mul(
                                  index&lt;'i'&gt;(basis_derivs_test_space),
                                  index&lt;'i', 'j'&gt;(inv_metric_tensor),
                                  index&lt;'j'&gt;(basis_derivs_trial_space))
                  + beta * basis_val_test_space * basis_val_trial_space);
    }

    template &lt;class Mapping&gt;
    double get_matrix_stencil_element(
            IdxBSRTheta idx_test,
            IdxBSRTheta idx_trial,
            ConstSpline2D coeff_alpha,
            ConstSpline2D coeff_beta,
            SplineRThetaEvaluatorNullBound const&amp; evaluator,
            Mapping const&amp; mapping)
    {
        // 0 &lt;= idx_test_r &lt; 8
        // 0 &lt;= idx_trial_r &lt; 8
        // idx_test_r &lt; idx_trial_r
        const int idx_test_r(ddc::select&lt;BSplinesR&gt;(idx_test).uid());
        const int idx_trial_r(ddc::select&lt;BSplinesR&gt;(idx_trial).uid());
        // 0 &lt;= idx_test_theta &lt; 8
        // 0 &lt;= idx_trial_theta &lt; 8
        int idx_test_theta(theta_mod(ddc::select&lt;BSplinesTheta&gt;(idx_test).uid()));
        int idx_trial_theta(theta_mod(ddc::select&lt;BSplinesTheta&gt;(idx_trial).uid()));

        const std::size_t ncells_r = ddc::discrete_space&lt;BSplinesR&gt;().ncells();

        // 0&lt;= r_offset &lt;= degree_r
        // -degree_theta &lt;= theta_offset &lt;= degree_theta
        const int r_offset = idx_trial_r - idx_test_r;
        int theta_offset = theta_mod(idx_trial_theta - idx_test_theta);
        if (theta_offset &gt;= int(m_nbasis_theta - BSplinesTheta::degree())) {
            theta_offset -= m_nbasis_theta;
        }
        assert(r_offset &gt;= 0);
        assert(r_offset &lt;= int(BSplinesR::degree()));
        assert(theta_offset &gt;= -int(BSplinesTheta::degree()));
        assert(theta_offset &lt;= int(BSplinesTheta::degree()));

        // Find the index range covering the cells where both the test and trial functions are non-zero
        int n_overlap_stencil_r(BSplinesR::degree() + 1 - r_offset);
        int first_overlap_r(idx_trial_r - BSplinesR::degree());

        int first_overlap_theta;
        int n_overlap_stencil_theta;
        if (theta_offset &gt; 0) {
            n_overlap_stencil_theta = BSplinesTheta::degree() + 1 - theta_offset;
            first_overlap_theta = theta_mod(idx_trial_theta - BSplinesTheta::degree());
        } else {
            n_overlap_stencil_theta = BSplinesTheta::degree() + 1 + theta_offset;
            first_overlap_theta = theta_mod(idx_test_theta - BSplinesTheta::degree());
        }

        if (first_overlap_r &lt; 0) {
            const int n_compact = first_overlap_r;
            first_overlap_r = 0;
            n_overlap_stencil_r += n_compact;
        }

        const int n_to_edge_r(ncells_r - first_overlap_r);

        const IdxStep&lt;RCellDim&gt; n_overlap_r(min(n_overlap_stencil_r, n_to_edge_r));
        const IdxStep&lt;ThetaCellDim&gt; n_overlap_theta(n_overlap_stencil_theta);

        const Idx&lt;RCellDim&gt; first_overlap_element_r(first_overlap_r);
        const Idx&lt;ThetaCellDim&gt; first_overlap_element_theta(first_overlap_theta);

        const IdxRange&lt;RCellDim&gt; r_cells(first_overlap_element_r, n_overlap_r);
        const IdxRange&lt;ThetaCellDim&gt; theta_cells(first_overlap_element_theta, n_overlap_theta);
        const IdxRange&lt;RCellDim, ThetaCellDim&gt; non_zero_cells(r_cells, theta_cells);

        auto r_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_r_basis_vals_and_derivs));
        auto theta_basis_vals_and_derivs_alloc = ddc::create_mirror_view_and_copy(
                Kokkos::DefaultExecutionSpace(),
                get_field(m_theta_basis_vals_and_derivs));

        Field&lt;EvalDeriv1DType, IdxRange&lt;RBasisSubset, QDimRMesh&gt;&gt; r_basis_vals_and_derivs
                = get_field(r_basis_vals_and_derivs_alloc);
        Field&lt;EvalDeriv1DType, IdxRange&lt;ThetaBasisSubset, QDimThetaMesh&gt;&gt;
                theta_basis_vals_and_derivs = get_field(theta_basis_vals_and_derivs_alloc);
        DField&lt;IdxRangeQuadratureRTheta&gt; int_volume_proxy = get_field(m_int_volume);

        assert(n_overlap_r * n_overlap_theta &gt; 0);
        return ddc::transform_reduce(
                non_zero_cells,
                0.0,
                ddc::reducer::sum&lt;double&gt;(),
                [&amp;](IdxCell const cell_idx) {
                    const int cell_idx_r(ddc::select&lt;RCellDim&gt;(cell_idx).uid());
                    const int cell_idx_theta(theta_mod(ddc::select&lt;ThetaCellDim&gt;(cell_idx).uid()));

                    const IdxRangeQuadratureRTheta cell_quad_points(
                            get_quadrature_points_in_cell(cell_idx_r, cell_idx_theta));

                    int ib_test_theta_idx = idx_test_theta - cell_idx_theta;
                    int ib_trial_theta_idx = idx_trial_theta - cell_idx_theta;

                    // Find the column where the non-zero data is stored
                    Idx&lt;RBasisSubset&gt; ib_test_r(idx_test_r - cell_idx_r);
                    Idx&lt;ThetaBasisSubset&gt; ib_test_theta(theta_mod(ib_test_theta_idx));
                    Idx&lt;RBasisSubset&gt; ib_trial_r(idx_trial_r - cell_idx_r);
                    Idx&lt;ThetaBasisSubset&gt; ib_trial_theta(theta_mod(ib_trial_theta_idx));

                    assert(ib_test_r.uid() &lt; BSplinesR::degree() + 1);
                    assert(ib_test_theta.uid() &lt; BSplinesTheta::degree() + 1);
                    assert(ib_trial_r.uid() &lt; BSplinesR::degree() + 1);
                    assert(ib_trial_theta.uid() &lt; BSplinesTheta::degree() + 1);

                    // Calculate the weak integral
                    return ddc::parallel_transform_reduce(
                            Kokkos::DefaultExecutionSpace(),
                            cell_quad_points,
                            0.0,
                            ddc::reducer::sum&lt;double&gt;(),
                            KOKKOS_LAMBDA(IdxQuadratureRTheta const idx_quad) {
                                IdxQuadratureR const idx_r(idx_quad);
                                IdxQuadratureTheta const idx_theta(idx_quad);
                                return weak_integral_element(
                                        idx_r,
                                        idx_theta,
                                        r_basis_vals_and_derivs(ib_test_r, idx_r),
                                        r_basis_vals_and_derivs(ib_trial_r, idx_r),
                                        theta_basis_vals_and_derivs(ib_test_theta, idx_theta),
                                        theta_basis_vals_and_derivs(ib_trial_theta, idx_theta),
                                        coeff_alpha,
                                        coeff_beta,
                                        evaluator,
                                        mapping,
                                        int_volume_proxy);
                            });
                });
    }

    static KOKKOS_FUNCTION int theta_mod(int idx_theta)
    {
        int ncells_theta = ddc::discrete_space&lt;BSplinesTheta&gt;().ncells();
        while (idx_theta &lt; 0)
            idx_theta += ncells_theta;
        while (idx_theta &gt;= ncells_theta)
            idx_theta -= ncells_theta;
        return idx_theta;
    }

    void init_nnz_per_line(Kokkos::View&lt;int*, Kokkos::LayoutRight&gt; nnz) const
    {
        Kokkos::Profiling::pushRegion("PolarPoissonInitNnz");
        size_t const mat_size = nnz.extent(0) - 1;
        size_t constexpr n_singular_basis = PolarBSplinesRTheta::n_singular_basis();
        size_t constexpr degree = BSplinesR::degree();
        size_t constexpr radial_overlap = 2 * degree + 1;
        size_t const nbasis_theta_proxy = m_nbasis_theta;

        // overlap between singular domain splines and radial splines
        Kokkos::parallel_for(
                "overlap singular radial",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(1, n_singular_basis + 1),
                KOKKOS_LAMBDA(const int k) {
                    nnz(k + 1) = n_singular_basis + degree * nbasis_theta_proxy;
                });

        // going from the internal boundary the overlapping possibilities between two radial splines increase
        Kokkos::parallel_for(
                "inner overlap",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(1, degree + 2),
                KOKKOS_LAMBDA(const int i) {
                    for (size_t k = n_singular_basis + (i - 1) * nbasis_theta_proxy;
                         k &lt; n_singular_basis + i * nbasis_theta_proxy;
                         k++) {
                        nnz(k + 2) = n_singular_basis + (degree + i) * radial_overlap;
                    }
                });

        // Stencil with maximum possible overlap from two sides for radial spline
        Kokkos::parallel_for(
                "Inner Stencil",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(
                        n_singular_basis + degree * nbasis_theta_proxy,
                        mat_size - degree * nbasis_theta_proxy),
                KOKKOS_LAMBDA(const int k) { nnz(k + 2) = radial_overlap * radial_overlap; });

        // Approaching the external boundary the overlapping possibilities between two radial splines decrease
        Kokkos::parallel_for(
                "outer overlap",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(1, degree + 1),
                KOKKOS_LAMBDA(const int i) {
                    for (size_t k = mat_size - i * nbasis_theta_proxy;
                         k &lt; mat_size - (i - 1) * nbasis_theta_proxy;
                         k++) {
                        nnz(k + 2) = (degree + i) * radial_overlap;
                    }
                });

        // sum non-zero elements count
        Kokkos::parallel_for(
                "Sum over lines",
                Kokkos::RangePolicy&lt;Kokkos::DefaultExecutionSpace&gt;(0, 1),
                KOKKOS_LAMBDA(const int idx) {
                    for (size_t k = 1; k &lt; mat_size; k++) {
                        nnz(k + 1) += nnz(k);
                    }
                    nnz(0) = 0;
                    nnz(1) = 0;
                });
        Kokkos::Profiling::popRegion();
    }
};
</code></pre></div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/gyselax/gyselalibxx/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../docs/jscript/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
