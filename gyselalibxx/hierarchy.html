<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Class Hierarchy - GyselalibX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Class Hierarchy";
        var mkdocs_page_input_path = "gyselalibxx/hierarchy.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> GyselalibX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >First Steps</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/getting_started.html">Getting Started</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Installation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../docs/first_steps/install.html">Gyselalib++ Installation</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../toolchains/index.html">Pre-made build settings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/DDC_in_gyselalibxx.html">DDC in Gyselalib++</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Standards</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/CODING_STANDARD.html">Coding Standard</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/mathematical_and_physical_conventions.html">Math & Physics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gyselalib++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Source</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../src/index.html">Gyselalib++ contents</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/advection/index.html">Advection methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/collisions/index.html">Collisions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/data_types/index.html">Data Storage Types</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryRTheta/index.html">Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection/index.html">Advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_field</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection_field/index.html">Advection Field finder</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/geometry/index.html">Geometry RTheta</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/initialisation/index.html">Initialisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/poisson/index.html">Polar Poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_solver</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/time_solver/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryVparMu</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryVparMu/index.html">Geometry (vpar, mu)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/collisions/index.html">CollisionConfiguration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/geometry/index.html">GeometryVparMu</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXVx/index.html">Geometry (x, v_x)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >boltzmann</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/boltzmann/index.html">Boltzmann solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/geometry/index.html">Geometry X-Vx</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >rhs</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/rhs/index.html">RHS</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/utils/index.html">Utils</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXY/index.html">Geometry (x, y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/geometry/index.html">Geometry XY</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/initialisation/index.html">Initialisation on (x,y) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/time_integration/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXYVxVy</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXYVxVy/index.html">Geometry (x, y, v_x, v_y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/geometry/index.html">Geometry X Y-Vx Vy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vlasov</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/vlasov/index.html">Vlasov solver</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >interpolation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/interpolation/index.html">Interpolation Methods</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_splines</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/interpolation/polar_splines/index.html">Polar Splines</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >io</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/io/index.html">Functions used for input and output</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mapping</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mapping/index.html">Mappings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >math_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/math_tools/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >matrix_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/matrix_tools/index.html">Matrix tools</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mpi_parallelisation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mpi_parallelisation/index.html">Parallelisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/multipatch/index.html">Multipatch</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >connectivity</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/connectivity/index.html">Multipatch connectivity</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/data_types/index.html">Data Types for Multipatch Geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/spline/index.html">Spline on multipatch geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/utils/index.html">Multipatch utilitary functions</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >pde_solvers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/pde_solvers/index.html">PDE Solvers</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >quadrature</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/quadrature/index.html">Quadrature Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >speciesinfo</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/speciesinfo/index.html">SpeciesInfo (x, v_x)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >timestepper</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/timestepper/index.html">Time Stepping Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/utils/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Simulations</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../simulations/index.html">Gyselalib++ simulations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryRTheta/index.html">Simulations in (r, theta) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >diocotron</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/diocotron/index.html">Diocotron instability</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vortex_merger</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/vortex_merger/index.html">Vortex merger</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXVx/index.html">Simulations in (x, vx) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXY/index.html">Simulations in (x, y) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >guiding_centre</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryXY/guiding_centre/index.html">Guiding centre (X,Y) simulation</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tests</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tests/index.html">Gyselalib++ tests</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/advection/index.html">Tests on the templated advection operators</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/geometryRTheta/index.html">Tests : Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/advection_rtheta/index.html">Tests on the 2D polar advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/polar_poisson/index.html">Tests on the 2D polar poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline_interpolator_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/spline_interpolator_rtheta/index.html">Tests on spline interpolator in polar coordinates</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/multipatch/index.html">Multipatch geometry tests</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometries</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/multipatch/geometries/index.html">Multipatch geometries</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Adding_docs.html">Adding Docs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Using_git.html">Using Git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/developer_FAQ.html">Developer FAQ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Troubleshooting</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/troubleshooting/Common_compilation_problems.html">Compilation Issues</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" >Gyselalib++</a>
    <ul class="current">
                <li class="toctree-l2 current"><a class="reference internal current" >Classes</a>
    <ul class="current">
                <li class="toctree-l3"><a class="reference internal" href="annotated.html">Class List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="classes.html">Class Index</a>
                </li>
                <li class="toctree-l3 current"><a class="reference internal current" href="#">Class Hierarchy</a>
    <ul class="current">
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Namespaces</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="namespaces.html">Namespace List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_members.html">Namespace Members</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_functions.html">Namespace Member Functions</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_variables.html">Namespace Member Variables</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_typedefs.html">Namespace Member Typedefs</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_enums.html">Namespace Member Enumerations</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="files.html">Files</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">GyselalibX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">API</li>
          <li class="breadcrumb-item">Gyselalib++</li>
          <li class="breadcrumb-item">Classes</li>
      <li class="breadcrumb-item active">Class Hierarchy</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/gyselax/gyselalibxx/edit/main/gyselalibxx/hierarchy.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div><h1 id="class-hierarchy">Class Hierarchy</h1>
<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p>
<ul>
<li><strong>class</strong> <a href="classAdvectionFieldFinder.html"><strong>AdvectionFieldFinder</strong></a> <em>Solve the Poisson-like equation and return the electric field for the coupled Vlasov equation.</em> </li>
<li><strong>class</strong> <a href="classBarycentricToCartesian.html"><strong>BarycentricToCartesian</strong></a> <em>A class to convert barycentric coordinates to Cartesian coordinates on a triangle.</em> </li>
<li><strong>class</strong> <a href="classBslAdvection1D.html"><strong>BslAdvection1D</strong></a> <em>A class which computes the advection along the dimension of interest GridInterest.</em> </li>
<li><strong>class</strong> <a href="classIAdvectionRTheta.html"><strong>IAdvectionRTheta</strong></a> <em>Define the base class of 2D advection operators in polar index range.</em>     <ul>
<li><strong>class</strong> <a href="classBslAdvectionRTheta.html"><strong>BslAdvectionRTheta</strong></a> <em>Define an advection operator on 2D</em>  <em>index range.</em></li>
<li><strong>class</strong> <a href="classBslAdvectionRTheta.html"><strong>BslAdvectionRTheta</strong></a> <em>Define an advection operator on 2D</em>  <em>index range.</em></li>
</ul>
</li>
<li><strong>class</strong> <a href="classIAdvectionSpatial.html"><strong>IAdvectionSpatial</strong></a> <em>A class which provides an advection operator.</em>     <ul>
<li><strong>class</strong> <a href="classBslAdvectionSpatial.html"><strong>BslAdvectionSpatial</strong></a> <em>A class which computes the spatial advection along the dimension of interest</em> <a href="structGridX.html"><em><strong>GridX</strong></em></a> <em>. Working for every Cartesian geometry.</em></li>
</ul>
</li>
<li><strong>class</strong> <a href="classIAdvectionVelocity.html"><strong>IAdvectionVelocity</strong></a> <em>A class which provides an advection operator.</em>     <ul>
<li><strong>class</strong> <a href="classBslAdvectionVelocity.html"><strong>BslAdvectionVelocity</strong></a> <em>A class which computes the velocity advection along the dimension of interest GridV. Working for every Cartesian geometry.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classITimeSolverRTheta.html"><strong>ITimeSolverRTheta</strong></a> <em>Base class for the time solvers.</em>     <ul>
<li><strong>class</strong> <a href="classBslExplicitPredCorrRTheta.html"><strong>BslExplicitPredCorrRTheta</strong></a> <em>A second order explicit predictor-corrector for the Vlasov-Poisson equations.</em> </li>
<li><strong>class</strong> <a href="classBslImplicitPredCorrRTheta.html"><strong>BslImplicitPredCorrRTheta</strong></a> <em>A second order implicit predictor-corrector for the Vlasov-Poisson equations.</em> </li>
<li><strong>class</strong> <a href="classBslPredCorrRTheta.html"><strong>BslPredCorrRTheta</strong></a> <em>Predictor-corrector for the Vlasov-Poisson equations.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIEquilibrium.html"><strong>IEquilibrium</strong></a> <em>An abstract class for initialising a distribution function in (species,vpar,mu).</em>     <ul>
<li><strong>class</strong> <a href="classBumpontailEquilibrium.html"><strong>BumpontailEquilibrium</strong></a> <em>A class that initialises the distribution function as a sum of two Maxwellian functions.</em> </li>
<li><strong>class</strong> <a href="classMaxwellianEquilibrium.html"><strong>MaxwellianEquilibrium</strong></a> <em>Equilibrium operator as Maxwellian. This initialises all species.</em> </li>
<li><strong>class</strong> <a href="classMaxwellianEquilibrium.html"><strong>MaxwellianEquilibrium</strong></a> <em>Equilibrium operator as Maxwellian. This initialises all species.</em> </li>
<li><strong>class</strong> <a href="classMaxwellianEquilibrium.html"><strong>MaxwellianEquilibrium</strong></a> <em>Equilibrium operator as Maxwellian. This initialises all species.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classCartesianToBarycentric.html"><strong>CartesianToBarycentric</strong></a> <em>A class to convert Cartesian coordinates to barycentric coordinates on a triangle.</em> </li>
<li><strong>class</strong> <a href="classCartesianToCircular.html"><strong>CartesianToCircular</strong></a> <em>A class for describing the circular 2D mapping.</em> </li>
<li><strong>class</strong> <a href="classCartesianToCzarny.html"><strong>CartesianToCzarny</strong></a> <em>A class for describing the Czarny 2D mapping.</em> </li>
<li><strong>class</strong> <a href="classIPartialDerivative.html"><strong>IPartialDerivative</strong></a> <em>An abstract class for a partial derivative operator.</em>     <ul>
<li><strong>class</strong> <a href="classCentralFDMPartialDerivative.html"><strong>CentralFDMPartialDerivative</strong></a> <em>A class which implements a partial derivative operator using a finite differences calculation of order two. A decentered scheme is used at the boundary, whereas centred finite difference are used inside the domain.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIPartialDerivativeCreator.html"><strong>IPartialDerivativeCreator</strong></a> <em>An abstract class which provides a create_instance function to instantiate an object of the</em> <a href="classIPartialDerivative.html"><em><strong>IPartialDerivative</strong></em></a> <em>class where required.</em>    <ul>
<li><strong>class</strong> <a href="classCentralFDMPartialDerivativeCreator.html"><strong>CentralFDMPartialDerivativeCreator</strong></a> <em>A class which stores information necessary to create a pointer to an instance of the</em> <a href="classCentralFDMPartialDerivative.html"><em><strong>CentralFDMPartialDerivative</strong></em></a> <em>class.</em></li>
</ul>
</li>
<li><strong>class</strong> <a href="classIChargeDensityCalculator.html"><strong>IChargeDensityCalculator</strong></a> <em>A class which computes charges density.</em>     <ul>
<li><strong>class</strong> <a href="classChargeDensityCalculator.html"><strong>ChargeDensityCalculator</strong></a> <em>A class which computes charges density with Kokkos.</em> </li>
<li><strong>class</strong> <a href="classChargeDensityCalculator.html"><strong>ChargeDensityCalculator</strong></a> <em>A class which computes charges density with Kokkos.</em> </li>
<li><strong>class</strong> <a href="classMpiChargeDensityCalculator.html"><strong>MpiChargeDensityCalculator</strong></a> <em>A class which computes charges density with Kokkos.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classCircularToCartesian.html"><strong>CircularToCartesian</strong></a> <em>A class for describing the circular 2D mapping.</em> </li>
<li><strong>class</strong> <a href="classCollisionConfiguration.html"><strong>CollisionConfiguration</strong></a> <em>Class to collect information to initialise the collision operator for a SpVparMu geometry.</em> </li>
<li><strong>class</strong> <a href="classCollisionOperator.html"><strong>CollisionOperator</strong></a> <em>A class which computes the collision operator in (Sp,vpar,mu).</em> </li>
<li><strong>class</strong> <a href="classIRightHandSide.html"><strong>IRightHandSide</strong></a> <em>An abstract class representing a source in Boltzmann equation.</em>     <ul>
<li><strong>class</strong> <a href="classCollisionsInter.html"><strong>CollisionsInter</strong></a> <em>Class describing the inter-species collision operator.</em> </li>
<li><strong>class</strong> <a href="classCollisionsIntra.html"><strong>CollisionsIntra</strong></a> <em>Class describing the intra-species collision operator.</em> </li>
<li><strong>class</strong> <a href="classKineticSource.html"><strong>KineticSource</strong></a> <em>A class that describes a source of particles.</em> </li>
<li><strong>class</strong> <a href="classKrookSourceAdaptive.html"><strong>KrookSourceAdaptive</strong></a> <em>A class that describes a source of particles.</em> </li>
<li><strong>class</strong> <a href="classKrookSourceConstant.html"><strong>KrookSourceConstant</strong></a> <em>A class that describes a source of particles.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classCombinedMapping.html"><strong>CombinedMapping</strong></a> <em>A class which describes a mapping which is constructed by combining two mappings. Let us denote Mapping1 as</em>  <em>and Mapping2 as</em> <em>then this mapping represents:</em> <em>.</em></li>
<li><strong>class</strong> <a href="classITimeStepper.html"><strong>ITimeStepper</strong></a> <em>The superclass from which all timestepping methods inherit.</em>     <ul>
<li><strong>class</strong> <a href="classCrankNicolson.html"><strong>CrankNicolson</strong></a> <em>A class which provides an implementation of a Crank-Nicolson method.</em> </li>
<li><strong>class</strong> <a href="classEuler.html"><strong>Euler</strong></a> <em>A class which provides an implementation of an explicit</em> <a href="classEuler.html"><em><strong>Euler</strong></em></a> <em>method.</em></li>
<li><strong>class</strong> <a href="classRK2.html"><strong>RK2</strong></a> <em>A class which provides an implementation of a second-order Runge-Kutta method.</em> </li>
<li><strong>class</strong> <a href="classRK3.html"><strong>RK3</strong></a> <em>A class which provides an implementation of a third-order Runge-Kutta method.</em> </li>
<li><strong>class</strong> <a href="classRK4.html"><strong>RK4</strong></a> <em>A class which provides an implementation of a fourth-order Runge-Kutta method.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classCzarnyToCartesian.html"><strong>CzarnyToCartesian</strong></a> <em>A class for describing the Czarny 2D mapping.</em> </li>
<li><strong>class</strong> <a href="classDerivField.html"><strong>DerivField</strong></a> </li>
<li><strong>class</strong> <a href="classDerivFieldCommon.html"><strong>DerivFieldCommon</strong></a> </li>
<li><strong>class</strong> <a href="classDerivFieldCommon_3_01FieldType_00_01IdxRange_3_01DDims_8_8_8_01_4_01_4.html"><strong>DerivFieldCommon&lt; FieldType, IdxRange&lt; DDims... &gt; &gt;</strong></a> <em>An abstract class which holds a chunk of memory describing a field and its derivatives. This is the superclass for</em> <a href="classDerivFieldMem.html"><em><strong>DerivFieldMem</strong></em></a> <em>and</em><a href="classDerivField.html"><em><strong>DerivField</strong></em></a> <em>.</em></li>
<li><strong>class</strong> <a href="classDerivFieldMem.html"><strong>DerivFieldMem</strong></a> </li>
<li><strong>class</strong> <a href="classDiocotronDensitySolution.html"><strong>DiocotronDensitySolution</strong></a> <em>The diocotron exact solution of the density</em>  <em>.</em></li>
<li><strong>class</strong> <a href="classDiscreteToCartesian.html"><strong>DiscreteToCartesian</strong></a> <em>A class for describing discrete 2D mappings from the logical domain to the physical domain.</em> </li>
<li><strong>class</strong> <a href="classDiscreteToCartesianBuilder.html"><strong>DiscreteToCartesianBuilder</strong></a> <em>A class to create a</em> <a href="classDiscreteToCartesian.html"><em><strong>DiscreteToCartesian</strong></em></a> <em>instance from an analytical mapping. This class creates and stores splines memory spaces describing the analytical mapping. The discrete mapping is then created using the splines without copying data.</em></li>
<li><strong>class</strong> <a href="classEdgeTransformation.html"><strong>EdgeTransformation</strong></a> <em>Transform a coordinate or an index from one edge to the one on the other edge.</em> </li>
<li><strong>class</strong> <a href="classIPoissonSolver.html"><strong>IPoissonSolver</strong></a> </li>
<li><strong>class</strong> <a href="classFFTPoissonSolver.html"><strong>FFTPoissonSolver</strong></a> </li>
<li><strong>class</strong> <a href="classFluidMoments.html"><strong>FluidMoments</strong></a> <em>A class that computes fluid moments of the distribution function.</em> </li>
<li><strong>class</strong> <a href="classGaussLegendre.html"><strong>GaussLegendre</strong></a> <em>An operator for constructing a Gauss-Legendre quadrature.</em> </li>
<li><strong>class</strong> <a href="classGeometryVxVyXY.html"><strong>GeometryVxVyXY</strong></a> <em>A class providing aliases for useful subindex ranges of the geometry when the data is saved with the velocity dimensions distributed across MPI ranks. It is used as template parameter for generic dimensionality-agnostic operators such as advections.</em> </li>
<li><strong>class</strong> <a href="classGeometryXVx.html"><strong>GeometryXVx</strong></a> <em>A class providing aliases for useful subindex ranges of the geometry. It is used as template parameter for generic dimensionality-agnostic operators such as advections.</em> </li>
<li><strong>class</strong> <a href="classGeometryXYVxVy.html"><strong>GeometryXYVxVy</strong></a> <em>A class providing aliases for useful subindex ranges of the geometry when the data is saved with the spatial dimensions distributed across MPI ranks. It is used as template parameter for generic dimensionality-agnostic operators such as advections.</em> </li>
<li><strong>class</strong> <a href="classGradient.html"><strong>Gradient</strong></a> <em>A class which implements a gradient operator.</em> </li>
<li><strong>class</strong> <a href="classIBoltzmannSolver.html"><strong>IBoltzmannSolver</strong></a> <em>An abstract class for solving a Boltzmann equation.</em>     <ul>
<li><strong>class</strong> <a href="classSplitRightHandSideSolver.html"><strong>SplitRightHandSideSolver</strong></a> <em>A class that solves a Boltzmann equation using Strang's splitting.</em> </li>
<li><strong>class</strong> <a href="classSplitVlasovSolver.html"><strong>SplitVlasovSolver</strong></a> <em>A class that solves a Vlasov equation using Strang's splitting.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIInitialisation.html"><strong>IInitialisation</strong></a> <em>An abstract class that allows for initialising a distribution function.</em>     <ul>
<li><strong>class</strong> <a href="classNoPerturbInitialisation.html"><strong>NoPerturbInitialisation</strong></a> <em>Initialisation operator with no perturbation, i.e the distribution function equal to the Maxwellian.</em> </li>
<li><strong>class</strong> <a href="classRestartInitialisation.html"><strong>RestartInitialisation</strong></a> <em>A class that initialises the distribution function from a previous simulation.</em> </li>
<li><strong>class</strong> <a href="classSingleModePerturbInitialisation.html"><strong>SingleModePerturbInitialisation</strong></a> <em>A class that initialises the distribution function as a perturbed Maxwellian.</em> </li>
<li><strong>class</strong> <a href="classSingleModePerturbInitialisation.html"><strong>SingleModePerturbInitialisation</strong></a> <em>A class that initialises the distribution function as a perturbed Maxwellian.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIInterpolator.html"><strong>IInterpolator</strong></a> <em>A class which provides an interpolating function.</em> </li>
<li><strong>class</strong> <a href="classIInterpolator2D.html"><strong>IInterpolator2D</strong></a> <em>A class which provides an interpolating function.</em>     <ul>
<li><strong>class</strong> <a href="classIPreallocatableInterpolator2D.html"><strong>IPreallocatableInterpolator2D</strong></a> <em>A class which provides access to an interpolating function which can be preallocated where useful.</em> </li>
<li><strong>class</strong> <a href="classIPreallocatableInterpolator2D.html"><strong>IPreallocatableInterpolator2D</strong></a> <em>A class which provides access to an interpolating function which can be preallocated where useful.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIMPILayout.html"><strong>IMPILayout</strong></a> <em>A super class describing a way in which data may be laid out across MPI processes.</em> </li>
<li><strong>class</strong> <a href="classIMPITranspose.html"><strong>IMPITranspose</strong></a> <em>A superclass describing an operator for converting from/to different MPI layouts.</em>     <ul>
<li><strong>class</strong> <a href="classMPITransposeAllToAll.html"><strong>MPITransposeAllToAll</strong></a> <em>A class describing an operator for converting from/to different MPI layouts using AlltoAll.</em> </li>
<li><strong>class</strong> <a href="classMPITransposeAllToAll.html"><strong>MPITransposeAllToAll</strong></a> <em>A class describing an operator for converting from/to different MPI layouts using AlltoAll.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIPoissonSolver_3_01IdxRange_3_01ODims_8_8_8_01_4_00_01IdxRangeFull_00_01MemorySpace_00_01LayoutSpace_01_4.html"><strong>IPoissonSolver&lt; IdxRange&lt; ODims... &gt;, IdxRangeFull, MemorySpace, LayoutSpace &gt;</strong></a> </li>
<li><strong>class</strong> <a href="classIPolarFootFinder.html"><strong>IPolarFootFinder</strong></a> <em>Define a base class for all the time integration methods used to find the foot of a characteristic on a polar domain (a polar domain is a domain defined on the</em>  <em>plane).</em></li>
<li><strong>class</strong> <a href="classIQNSolver.html"><strong>IQNSolver</strong></a> <em>Base class for a Quasi-Neutrality solver.</em>     <ul>
<li><strong>class</strong> <a href="classNullQNSolver.html"><strong>NullQNSolver</strong></a> <em>Null operator.</em> </li>
<li><strong>class</strong> <a href="classNullQNSolver.html"><strong>NullQNSolver</strong></a> <em>Null operator.</em> </li>
<li><strong>class</strong> <a href="classQNSolver.html"><strong>QNSolver</strong></a> <em>An operator which solves the Quasi-Neutrality equation using a fast Fourier transform.</em> </li>
<li><strong>class</strong> <a href="classQNSolver.html"><strong>QNSolver</strong></a> <em>An operator which solves the Quasi-Neutrality equation using a fast Fourier transform.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classITimeSolver.html"><strong>ITimeSolver</strong></a> <em>An abstract class for solving a Boltzmann-Poisson system of equations.</em>     <ul>
<li><strong>class</strong> <a href="classPredCorr.html"><strong>PredCorr</strong></a> <em>A class that solves a Boltzmann-Poisson system of equations using a predictor-corrector scheme.</em> </li>
<li><strong>class</strong> <a href="classPredCorr.html"><strong>PredCorr</strong></a> <em>A class that solves a Boltzmann-Poisson system of equations using a predictor-corrector scheme.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIVlasovSolver.html"><strong>IVlasovSolver</strong></a> <em>An abstract class for solving a Vlasov equation.</em>     <ul>
<li><strong>class</strong> <a href="classMpiSplitVlasovSolver.html"><strong>MpiSplitVlasovSolver</strong></a> <em>A class that solves a Vlasov equation using Strang's splitting on an MPI distributed mesh.</em> </li>
<li><strong>class</strong> <a href="classSplitVlasovSolver.html"><strong>SplitVlasovSolver</strong></a> <em>A class that solves a Vlasov equation using Strang's splitting.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classIdxRangeSlice.html"><strong>IdxRangeSlice</strong></a> <em>A class which describes a collection of equally spaced Idxs which form a index range.</em> </li>
<li><strong>class</strong> <a href="classInvJacobianOPoint.html"><strong>InvJacobianOPoint</strong></a> <em>An operator for calculating the inverse of the Jacobian at an O-point. This class is used in</em> <a href="classCombinedMapping.html"><em><strong>CombinedMapping</strong></em></a> <em>to calculate the inverse of the Jacobian at an O-point when one of the mappings does not allow the evaluation of its Jacobian/inverse Jacobian at the O-point.</em></li>
<li><strong>class</strong> <a href="classInvJacobianOPoint_3_01CombinedMapping_3_01CircularToCartesian_3_01R_00_01Theta_00_01X_00_01be6b75c3c69e2165a260584a5fd55276.html"><strong>InvJacobianOPoint&lt; CombinedMapping&lt; CircularToCartesian&lt; R, Theta, X, Y &gt;, CartesianToCircular&lt; Xpc, Ypc, R, Theta &gt; &gt;, Coord&lt; R, Theta &gt; &gt;</strong></a> </li>
<li><strong>class</strong> <a href="classInvJacobianOPoint_3_01CombinedMapping_3_01CzarnyToCartesian_3_01R_00_01Theta_00_01X_00_01Y_399a54ae9b96ca8e75637deab2a35d95.html"><strong>InvJacobianOPoint&lt; CombinedMapping&lt; CzarnyToCartesian&lt; R, Theta, X, Y &gt;, CartesianToCircular&lt; Xpc, Ypc, R, Theta &gt; &gt;, Coord&lt; R, Theta &gt; &gt;</strong></a> </li>
<li><strong>class</strong> <a href="classInvJacobianOPoint_3_01CombinedMapping_3_01DiscreteToCartesian_3_01X_00_01Y_00_01SplineEvalu8b276096a791392bbf161b1f2d34e864.html"><strong>InvJacobianOPoint&lt; CombinedMapping&lt; DiscreteToCartesian&lt; X, Y, SplineEvaluator, R, Theta, MemorySpace &gt;, CartesianToCircular&lt; Xpc, Ypc, R, Theta &gt; &gt;, Coord&lt; R, Theta &gt; &gt;</strong></a> </li>
<li><strong>class</strong> <a href="classInverseJacobianMatrix.html"><strong>InverseJacobianMatrix</strong></a> </li>
<li><strong>class</strong> <a href="classKelvinHelmholtzInstabilityInitialisation.html"><strong>KelvinHelmholtzInstabilityInitialisation</strong></a> <em>Initialise the allfdistribu function.</em> </li>
<li><strong>class</strong> <a href="classLagrange.html"><strong>Lagrange</strong></a> <em>A class which implements</em> <a href="classLagrange.html"><em><strong>Lagrange</strong></em></a> <em>polynomials.</em></li>
<li><strong>class</strong> <a href="classLeviCivitaTensor.html"><strong>LeviCivitaTensor</strong></a> </li>
<li><strong>class</strong> <a href="classMatchingIdxSlice.html"><strong>MatchingIdxSlice</strong></a> <em>Store the conforming indexes of each patch of a given interface.</em> </li>
<li><strong>class</strong> <a href="classMatrix.html"><strong>Matrix</strong></a> <em>The super class from which matrix classes should inherit. This class is used to solve matrix equations.</em>     <ul>
<li><strong>class</strong> <a href="classMatrix__Banded.html"><strong>Matrix_Banded</strong></a> <em>A matrix class representing a banded matrix.</em> </li>
<li><strong>class</strong> <a href="classMatrix__Corner__Block.html"><strong>Matrix_Corner_Block</strong></a> <em>A class representing a matrix with the following block pattern:</em>     <ul>
<li><strong>class</strong> <a href="classMatrix__Centre__Block.html"><strong>Matrix_Centre_Block</strong></a> <em>A</em> <a href="classMatrix.html"><em><strong>Matrix</strong></em></a> <em>representing a matrix which has a banded region. This matrix must be able to be described by the following block matrices:</em></li>
<li><strong>class</strong> <a href="classMatrix__Periodic__Banded.html"><strong>Matrix_Periodic_Banded</strong></a> <em>A class representing a periodic banded matrix. A periodic banded matrix is like a banded matrix but additionally contains non- zero values in the corners. I.e it has the following sparsity pattern:</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classMatrix__Dense.html"><strong>Matrix_Dense</strong></a> <em>A class describing a dense matrix.</em> </li>
<li><strong>class</strong> <a href="classMatrix__PDS__Tridiag.html"><strong>Matrix_PDS_Tridiag</strong></a> <em>A class representing a real symmetric positive definite matrix.</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classMatrixBatch.html"><strong>MatrixBatch</strong></a> <a href="classMatrixBatch.html"><em><strong>MatrixBatch</strong></em></a> <em>superclass for managing a collection of linear systems. The main assumption is that all matrices have the same size. It is also assumed that each matrix is used to solve one equation.</em>    <ul>
<li><strong>class</strong> <a href="classMatrixBatchCsr.html"><strong>MatrixBatchCsr</strong></a> <a href="classMatrix.html"><em><strong>Matrix</strong></em></a> <em>class which is able to manage and solve a batch of sparse linear systems. Executes on either CPU or GPU. It takes advantage of the sparse structure, and the only batched solver available in Ginkgo : Stabilised Bicg. This class uses the CSR storage format which needs three arrays, one stores values, the other column indices. The third array contains the count of non-zero inside the matrix lines.(eg:for a given line index i nn_per_row[i]= sum of non-zeros until line i) The class returns these arrays (as Kokkos views) with the get_csr_views function, it is then possible to fill them outside the class. The sparsity pattern is the same for all matrices, hence column indices are stored only for one system. Tolerance and maximal number of iterations, which are parameters for the iterative solver, are set in the constructor. It is possible to get convergence information by activating the logger at constructor call.</em></li>
<li><strong>class</strong> <a href="classMatrixBatchCsr.html"><strong>MatrixBatchCsr</strong></a> <a href="classMatrix.html"><em><strong>Matrix</strong></em></a> <em>class which is able to manage and solve a batch of sparse linear systems. Executes on either CPU or GPU. It takes advantage of the sparse structure, and the only batched solver available in Ginkgo : Stabilised Bicg. This class uses the CSR storage format which needs three arrays, one stores values, the other column indices. The third array contains the count of non-zero inside the matrix lines.(eg:for a given line index i nn_per_row[i]= sum of non-zeros until line i) The class returns these arrays (as Kokkos views) with the get_csr_views function, it is then possible to fill them outside the class. The sparsity pattern is the same for all matrices, hence column indices are stored only for one system. Tolerance and maximal number of iterations, which are parameters for the iterative solver, are set in the constructor. It is possible to get convergence information by activating the logger at constructor call.</em></li>
<li><strong>class</strong> <a href="classMatrixBatchEll.html"><strong>MatrixBatchEll</strong></a> <a href="classMatrix.html"><em><strong>Matrix</strong></em></a> <em>class which is able to manage and solve a batch of sparse linear systems. Executes on either CPU or GPU. It takes advantage of the sparse structure, and the only batched solver available in Ginkgo : Stabilised Bicg. The sparsity pattern is assumed to be the same for all matrices. ie the non-zero components are located at the same places for all matrices. This class uses the ELL storage format which needs two 1D arrays, one stores values the other column indices. The class returns these arrays (as Kokkos views) with the get_batch_idx_and_vals function, it is then possible to fill them outside the class. Tolerance and maximal number of iterations, which are parameters for the iterative solver, are set in the constructor. It is possible to get convergence information by activating the logger at constructor call.</em></li>
<li><strong>class</strong> <a href="classMatrixBatchTridiag.html"><strong>MatrixBatchTridiag</strong></a> <em>A structure for solving a set of independent tridiagonal systems using a direct method. The parallelism operates on the whole collection by dispatching to threads. Each problem is treated sequentially, by the tridiagonal matrix algorithm (TDMA). This solver is stable for tridiagonal matrices which satisfy one of the following conditions:</em> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classMetricTensorEvaluator.html"><strong>MetricTensorEvaluator</strong></a> <em>An operator for calculating the metric tensor.</em> </li>
<li><strong>class</strong> <a href="classMoments.html"><strong>Moments</strong></a> <a href="classMoments.html"><em><strong>Moments</strong></em></a> <em>discrete dimension to access constant attributes related to fluid moments.</em>    <ul>
<li><strong>struct</strong> <a href="structGridMom.html"><strong>GridMom</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classMoments_1_1Impl.html"><strong>Moments::Impl</strong></a> <a href="classMoments_1_1Impl.html"><em><strong>Impl</strong></em></a> <em>object storing attributes in</em><code>MemorySpace</code> <em>.</em></li>
<li><strong>class</strong> <a href="classMultipatchConnectivity.html"><strong>MultipatchConnectivity</strong></a> <em>A helper class which provides functionalities to recognise how different patches are connected.</em> </li>
<li><strong>class</strong> <a href="classMultipatchType.html"><strong>MultipatchType</strong></a> <em>A class to store several objects that are of a type which is templated by the patch.</em> </li>
<li><strong>class</strong> <a href="classMultipatchSplineBuilder.html"><strong>MultipatchSplineBuilder</strong></a> <em>A class to call all the builders of all the patches once.</em> </li>
<li><strong>class</strong> <a href="classMultipatchSplineBuilder2D.html"><strong>MultipatchSplineBuilder2D</strong></a> <em>A class to call all the builders of all the patches once.</em> </li>
<li><strong>class</strong> <a href="classMultipatchSplineEvaluator2D.html"><strong>MultipatchSplineEvaluator2D</strong></a> <em>A class to evaluate all the splines of all the patches at once.</em> </li>
<li><strong>class</strong> <a href="classOnionPatchLocator.html"><strong>OnionPatchLocator</strong></a> <a href="structPatch.html"><em><strong>Patch</strong></em></a> <em>locator specialised for "onion" geometry.</em></li>
<li><strong>class</strong> <a href="classOnionPatchLocator_3_01MultipatchType_3_01IdxRangeOnPatch_00_01Patches_8_8_8_01_4_00_01Logicff6c45b073183ccdfc0de0e4a415a7fa.html"><strong>OnionPatchLocator&lt; MultipatchType&lt; IdxRangeOnPatch, Patches... &gt;, LogicalToPhysicalMapping, PhysicalToLogicalMapping, ExecSpace &gt;</strong></a> <a href="structPatch.html"><em><strong>Patch</strong></em></a> <em>locator specialised for "onion" geometry.</em></li>
<li><strong>class</strong> <a href="classPoissonLikeRHSFunction.html"><strong>PoissonLikeRHSFunction</strong></a> <em>Type of right-hand side (rhs) function of the Poisson equation.</em> </li>
<li><strong>class</strong> <a href="classPolarBSplines.html"><strong>PolarBSplines</strong></a> </li>
<li><strong>class</strong> <a href="classPolarBSplines_1_1Impl.html"><strong>PolarBSplines::Impl</strong></a> </li>
<li><strong>class</strong> <a href="classPolarSplineEvaluator.html"><strong>PolarSplineEvaluator</strong></a> <em>Define an evaluator on polar B-splines.</em> </li>
<li><strong>class</strong> <a href="classPolarSplineFEMPoissonLikeSolver.html"><strong>PolarSplineFEMPoissonLikeSolver</strong></a> <em>Define a polar PDE solver for a Poisson-like equation.</em> </li>
<li><strong>class</strong> <a href="classPredCorrRK2XY.html"><strong>PredCorrRK2XY</strong></a> <em>Predictor-corrector based on</em> <a href="classRK2.html"><em><strong>RK2</strong></em></a> <em>for the guiding-centre model.</em></li>
<li><strong>class</strong> <a href="classQuadrature.html"><strong>Quadrature</strong></a> <em>A class providing an operator for integrating functions defined on a discrete index range.</em> </li>
<li><strong>class</strong> <a href="classRefinedDiscreteToCartesianBuilder.html"><strong>RefinedDiscreteToCartesianBuilder</strong></a> <em>A class to create a</em> <a href="classDiscreteToCartesian.html"><em><strong>DiscreteToCartesian</strong></em></a> <em>instance from an analytical mapping. This class creates an instance which uses more refined splines than the provided builder and evaluator. This class creates and stores splines memory spaces describing the analytical mapping. The discrete mapping is then created using the splines without copying data.</em></li>
<li><strong>class</strong> <a href="classSpeciesInformation.html"><strong>SpeciesInformation</strong></a> <a href="structSpecies.html"><em><strong>Species</strong></em></a> <em>discrete dimension to access constant attributes related to species.</em>    <ul>
<li><strong>struct</strong> <a href="structSpecies.html"><strong>Species</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <a href="classSpeciesInformation_1_1Impl.html"><strong>SpeciesInformation::Impl</strong></a> <a href="classSpeciesInformation_1_1Impl.html"><em><strong>Impl</strong></em></a> <em>object storing attributes in</em><code>MemorySpace</code> <em>.</em></li>
<li><strong>class</strong> <a href="classSplineBuilder2DCache.html"><strong>SplineBuilder2DCache</strong></a> <em>A class that stores spline builder coefficients and recomputes them when required.</em> </li>
<li><strong>class</strong> <a href="classTensor.html"><strong>Tensor</strong></a> <em>A class representing a</em> <a href="classTensor.html"><em><strong>Tensor</strong></em></a> <em>.</em></li>
<li><strong>class</strong> <a href="classTriangularBernsteinPolynomialBasis.html"><strong>TriangularBernsteinPolynomialBasis</strong></a> <em>A class which evaluates the triangular Bernstein polynomials.</em> </li>
<li><strong>class</strong> <a href="classTriangularBernsteinPolynomialBasis_1_1Impl.html"><strong>TriangularBernsteinPolynomialBasis::Impl</strong></a> </li>
<li><strong>class</strong> <a href="classVectorFieldCommon.html"><strong>VectorFieldCommon</strong></a> </li>
<li><strong>class</strong> <a href="classVectorMapper.html"><strong>VectorMapper</strong></a> </li>
<li><strong>class</strong> <a href="classVectorMapper_3_01VectorIndexSet_3_01XIn_00_01YIn_01_4_00_01VectorIndexSet_3_01XOut_00_01YOu77c12468788509067d2c0ef34f5e389c.html"><strong>VectorMapper&lt; VectorIndexSet&lt; XIn, YIn &gt;, VectorIndexSet&lt; XOut, YOut &gt;, Mapping, ExecSpace &gt;</strong></a> <em>A class to map vector fields from one coordinate system to another.</em> </li>
<li><strong>class</strong> <a href="classVortexMergerDensitySolution.html"><strong>VortexMergerDensitySolution</strong></a> <em>Initial condition for the vortex merger simulation.</em> </li>
<li><strong>class</strong> <a href="classVortexMergerEquilibria.html"><strong>VortexMergerEquilibria</strong></a> <em>Equilibrium solution of a Vlasov-Poissson equations system in polar coordinates.</em> </li>
<li><strong>class</strong> <a href="classddcHelper_1_1NonUniformInterpolationPoints.html"><strong>ddcHelper::NonUniformInterpolationPoints</strong></a> <em>Helper class for the initialisation of the mesh of interpolation points.</em> </li>
<li><strong>class</strong> <a href="classtensor__tools_1_1IndexedTensor.html"><strong>tensor_tools::IndexedTensor</strong></a> <em>A class to capture the description of a tensor indexed at a specific component. This class should not be explicitly declared in user code. It is the output of a call to the index&lt;...&gt; function and is an input to the tensor_mul function.</em> </li>
<li><strong>class</strong> <a href="classtensor__tools_1_1TensorIndexElement.html"><strong>tensor_tools::TensorIndexElement</strong></a> <em>A class describing an index of a tensor. For example for a 2x2 metric tensor on an (x,y) plane the element</em>  <em>would have the index TensorIndexElement&lt;TensorIndexSetXY, X, X&gt;.</em></li>
<li><strong>struct</strong> <a href="structConstPolarSpline.html"><strong>ConstPolarSpline</strong></a> <em>A structure containing the two ConstFields necessary to define a constant reference to a spline on a set of polar basis splines.</em> </li>
<li><strong>struct</strong> <a href="structConstantExtrapolationRuleOnion.html"><strong>ConstantExtrapolationRuleOnion</strong></a> <em>Define constant extrapolation rule for onion shape geometries. Struct useful for the MultipatchSplineEvaluator types.</em>  __</li>
<li><strong>struct</strong> <a href="structEdge.html"><strong>Edge</strong></a> <em>Define an edge of a given patch.</em> </li>
<li><strong>struct</strong> <a href="structFEM1DPoissonSolver_1_1FEMSplineEvaluatorBuilder.html"><strong>FEM1DPoissonSolver::FEMSplineEvaluatorBuilder</strong></a> </li>
<li><strong>struct</strong> <a href="structFEM1DPoissonSolver_1_1FEMSplineEvaluatorBuilder_3_01IdxRange_3_01DimX_8_8_8_01_4_01_4.html"><strong>FEM1DPoissonSolver::FEMSplineEvaluatorBuilder&lt; IdxRange&lt; DimX... &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structFluidMoments_1_1MomentDensity.html"><strong>FluidMoments::MomentDensity</strong></a> </li>
<li><strong>struct</strong> <a href="structFluidMoments_1_1MomentTemperature.html"><strong>FluidMoments::MomentTemperature</strong></a> </li>
<li><strong>struct</strong> <a href="structFluidMoments_1_1MomentVelocity.html"><strong>FluidMoments::MomentVelocity</strong></a> </li>
<li><strong>struct</strong> <a href="structGaussLegendreCoefficients.html"><strong>GaussLegendreCoefficients</strong></a> <em>A structure containing the weights and positions associated with a Gauss-Legendre quadrature using NPoints points.</em> </li>
<li><strong>struct</strong> <a href="structIdxRangeSliceIterator.html"><strong>IdxRangeSliceIterator</strong></a> <em>An iterator type for the</em> <a href="classIdxRangeSlice.html"><em><strong>IdxRangeSlice</strong></em></a> <em>.</em></li>
<li><strong>struct</strong> <a href="structIdxRangeToSlice.html"><strong>IdxRangeToSlice</strong></a> <em>A class to create a</em> <a href="classIdxRangeSlice.html"><em><strong>IdxRangeSlice</strong></em></a> <em>type from a TypeSeq.</em></li>
<li><strong>struct</strong> <a href="structInterface.html"><strong>Interface</strong></a> <em>Represent a simple sticking of two edges.</em> </li>
<li><strong>struct</strong> <a href="structMPIDim.html"><strong>MPIDim</strong></a> <em>An internal tag used to dsecribe an artificial dimension describing the MPI rank where the scattered information will be sent to or where the gathered information will be collected from.</em> </li>
<li><strong>struct</strong> <a href="structMu.html"><strong>Mu</strong></a> <em>Define non periodic magnetic momentum</em>  <em>.</em></li>
<li><strong>struct</strong> <a href="structMultipatchSplineBuilder2D_1_1Build__BuilderType.html"><strong>MultipatchSplineBuilder2D::Build_BuilderType</strong></a> </li>
<li><strong>struct</strong> <a href="structMultipatchSplineBuilder2D_1_1Build__BuilderType_3_01Patch_00_01DConstField_3_01IdxRange_3_388990a8744187d12e0f612652c86727.html"><strong>MultipatchSplineBuilder2D::Build_BuilderType&lt; Patch, DConstField&lt; IdxRange&lt; Grid1D... &gt;, MemorySpace &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structMultipatchSplineBuilder_1_1Build__BuilderType.html"><strong>MultipatchSplineBuilder::Build_BuilderType</strong></a> </li>
<li><strong>struct</strong> <a href="structMultipatchSplineBuilder_1_1Build__BuilderType_3_01Patch_00_01DConstField_3_01IdxRange_3_0143963206948829b7e1024cedaaccd580.html"><strong>MultipatchSplineBuilder::Build_BuilderType&lt; Patch, DConstField&lt; IdxRange&lt; Grid1D... &gt;, MemorySpace &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structMultipatchSplineEvaluator2D_1_1eval__deriv__type.html"><strong>MultipatchSplineEvaluator2D::eval_deriv_type</strong></a> <em>Tag to indicate that derivative of the spline should be evaluated.</em> </li>
<li><strong>struct</strong> <a href="structMultipatchSplineEvaluator2D_1_1eval__type.html"><strong>MultipatchSplineEvaluator2D::eval_type</strong></a> <em>Tag to indicate that the value of the spline should be evaluated.</em> </li>
<li><strong>struct</strong> <a href="structNullExtrapolationRule.html"><strong>NullExtrapolationRule</strong></a> <em>Define null extrapolation rule common to all geometries.</em> </li>
<li><strong>struct</strong> <a href="structOutsideEdge.html"><strong>OutsideEdge</strong></a> <em>Define an edge for the outside index range.</em> <a href="structOutsideEdge.html"><em><strong>OutsideEdge</strong></em></a> <em>is a pseudo-edge outside the index range used to define interfaces between patches and the outside index range.</em></li>
<li><strong>struct</strong> <a href="structPatch.html"><strong>Patch</strong></a> <em>Base tag for a patch.</em> </li>
<li><strong>struct</strong> <a href="structPatch_3_01grid1_00_01grid2_00_01bsplines__dim1_00_01bsplines__dim2_01_4.html"><strong>Patch&lt; grid1, grid2, bsplines_dim1, bsplines_dim2 &gt;</strong></a> <em>Tag for a patch.</em> </li>
<li><strong>struct</strong> <a href="structPolarBSplines_1_1Impl_1_1Corner1Tag.html"><strong>PolarBSplines::Impl::Corner1Tag</strong></a> <em>The tag for the first corner of the Barycentric coordinates.</em> </li>
<li><strong>struct</strong> <a href="structPolarBSplines_1_1Impl_1_1Corner2Tag.html"><strong>PolarBSplines::Impl::Corner2Tag</strong></a> <em>The tag for the second corner of the Barycentric coordinates.</em> </li>
<li><strong>struct</strong> <a href="structPolarBSplines_1_1Impl_1_1Corner3Tag.html"><strong>PolarBSplines::Impl::Corner3Tag</strong></a> <em>The tag for the third corner of the Barycentric coordinates.</em> </li>
<li><strong>struct</strong> <a href="structPolarBSplines_1_1eval__deriv__type.html"><strong>PolarBSplines::eval_deriv_type</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarBSplines_1_1eval__type.html"><strong>PolarBSplines::eval_type</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarSpline.html"><strong>PolarSpline</strong></a> <em>A structure containing the two Fields necessary to define a reference to a spline on a set of polar basis splines.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineEvaluator_1_1eval__deriv__r__theta__type.html"><strong>PolarSplineEvaluator::eval_deriv_r_theta_type</strong></a> <em>Tag for the evaluation of the cross derivative of the function.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineEvaluator_1_1eval__deriv__r__type.html"><strong>PolarSplineEvaluator::eval_deriv_r_type</strong></a> <em>Tag for the evaluation of the derivative on the first dimension.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineEvaluator_1_1eval__deriv__theta__type.html"><strong>PolarSplineEvaluator::eval_deriv_theta_type</strong></a> <em>Tag for the evaluation of the derivative on the second dimension.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineEvaluator_1_1eval__type.html"><strong>PolarSplineEvaluator::eval_type</strong></a> <em>Tag for the evaluation of the function.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1EvalDeriv1DType.html"><strong>PolarSplineFEMPoissonLikeSolver::EvalDeriv1DType</strong></a> <em>Object storing a value and a value of the derivative of a 1D function.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1EvalDeriv2DType.html"><strong>PolarSplineFEMPoissonLikeSolver::EvalDeriv2DType</strong></a> <em>Object storing a value and a value of the derivatives in each direction of a 2D function.</em> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1RBasisSubset.html"><strong>PolarSplineFEMPoissonLikeSolver::RBasisSubset</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1RCellDim.html"><strong>PolarSplineFEMPoissonLikeSolver::RCellDim</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1ThetaBasisSubset.html"><strong>PolarSplineFEMPoissonLikeSolver::ThetaBasisSubset</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1ThetaCellDim.html"><strong>PolarSplineFEMPoissonLikeSolver::ThetaCellDim</strong></a> </li>
<li><strong>struct</strong> <a href="structPolarSplineMem.html"><strong>PolarSplineMem</strong></a> <em>A structure containing the two FieldMems necessary to define a spline on a set of polar basis splines.</em> </li>
<li><strong>struct</strong> <a href="structR.html"><strong>R</strong></a> <em>Define non periodic real contravariant</em> <a href="structR.html"><em><strong>R</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structR__cov.html"><strong>R_cov</strong></a> <em>Define non periodic real covariant</em> <a href="structR.html"><em><strong>R</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1Build__BuilderType.html"><strong>RefinedDiscreteToCartesianBuilder::Build_BuilderType</strong></a> </li>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1Build__BuilderType_3_01ddc_1_1SplineBuilder2D_3_01Exe5e607dcd09b0e5dcea3e1a165ab7545e.html"><strong>RefinedDiscreteToCartesianBuilder::Build_BuilderType&lt; ddc::SplineBuilder2D&lt; ExecSpace, MemorySpace, BSplinesROriginal, BSplinesThetaOriginal, GridROriginal, GridThetaOriginal, BcLower1, BcUpper1, BcLower2, BcUpper2, Solver, GridROriginal, GridThetaOriginal &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structT.html"><strong>T</strong></a> <em>A class which describes the real space in the temporal direction.</em> </li>
<li><strong>struct</strong> <a href="structTheta.html"><strong>Theta</strong></a> <em>Define periodic real contravariant</em> <a href="structTheta.html"><em><strong>Theta</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structTheta__cov.html"><strong>Theta_cov</strong></a> <em>Define periodic real covariant</em> <a href="structTheta.html"><em><strong>Theta</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structVpar.html"><strong>Vpar</strong></a> <em>Define non periodic parallel velocity</em>  <em>.</em></li>
<li><strong>struct</strong> <a href="structVr.html"><strong>Vr</strong></a> <em>Define non periodic real</em> <a href="structR.html"><em><strong>R</strong></em></a> <em>velocity dimension.</em></li>
<li><strong>struct</strong> <a href="structVtheta.html"><strong>Vtheta</strong></a> <em>Define periodic real</em> <a href="structTheta.html"><em><strong>Theta</strong></em></a> <em>velocity dimension.</em></li>
<li><strong>struct</strong> <a href="structVx.html"><strong>Vx</strong></a> <em>Define non periodic real</em> <a href="structX.html"><em><strong>X</strong></em></a> <em>velocity dimension.</em></li>
<li><strong>struct</strong> <a href="structVy.html"><strong>Vy</strong></a> <em>Define non periodic real</em> <a href="structY.html"><em><strong>Y</strong></em></a> <em>velocity dimension.</em></li>
<li><strong>struct</strong> <a href="structX.html"><strong>X</strong></a> <em>Define non periodic real</em> <a href="structX.html"><em><strong>X</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structX__pC.html"><strong>X_pC</strong></a> <em>Tag the first non periodic dimension in the pseudo_Cartesian index range.</em> </li>
<li><strong>struct</strong> <a href="structY.html"><strong>Y</strong></a> <em>Define non periodic real</em> <a href="structY.html"><em><strong>Y</strong></em></a> <em>dimension.</em></li>
<li><strong>struct</strong> <a href="structY__pC.html"><strong>Y_pC</strong></a> <em>Tag the second non periodic dimension in the pseudo_Cartesian index range.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1AddToTypeSeq.html"><strong>connectivity_details::AddToTypeSeq</strong></a> <em>A class which helps insert an element into a type sequence.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1AddToTypeSeq_3_01ToInsert_00_01TypeSeq_00_01BackInsert_01_4.html"><strong>connectivity_details::AddToTypeSeq&lt; ToInsert, TypeSeq, BackInsert &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1AddToTypeSeq.html"><em><strong>AddToTypeSeq</strong></em></a> <em>to add an element at the back of the type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1AddToTypeSeq_3_01ToInsert_00_01TypeSeq_00_01FrontInsert_01_4.html"><strong>connectivity_details::AddToTypeSeq&lt; ToInsert, TypeSeq, FrontInsert &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1AddToTypeSeq.html"><em><strong>AddToTypeSeq</strong></em></a> <em>to add an element at the front of the type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectAllGridsOnDim.html"><strong>connectivity_details::CollectAllGridsOnDim</strong></a> <em>A class which collects all grids along a given dimension in both directions.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectAllInterfacesOnDim.html"><strong>connectivity_details::CollectAllInterfacesOnDim</strong></a> <em>A class which collects all grids along a given dimension in both directions.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><strong>connectivity_details::CollectGridsAlongDim</strong></a> <em>A class which collects grids along a given dimension on a specified direction from a starting edge.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectGridsAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_01insd7a4bdb826ecb568487bbd509c5f008b.html"><strong>connectivity_details::CollectGridsAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundGrids, MatchingEdge, false &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><em><strong>CollectGridsAlongDim</strong></em></a> <em>to iterate recursively over the grids on the dimension.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectGridsAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_01ins8ee738c554d8fbbf6bab92ba87dd3b80.html"><strong>connectivity_details::CollectGridsAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundGrids, MatchingEdge, true &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><em><strong>CollectGridsAlongDim</strong></em></a> <em>to stop when the grid has already been identified (due to periodicity).</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectGridsAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_01ins70deef724c6e45ed62db534c3d9697ec.html"><strong>connectivity_details::CollectGridsAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundGrids, OutsideEdge, false &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><em><strong>CollectGridsAlongDim</strong></em></a> <em>to stop when there are no more grids.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectInterfacesAlongDim.html"><strong>connectivity_details::CollectInterfacesAlongDim</strong></a> <em>A class which collects interfaces along a given dimension on a specified direction from a starting edge.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectInterfacesAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_b2108f65f3430e895714f416a2f43701.html"><strong>connectivity_details::CollectInterfacesAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundInterfaces, MatchingEdge, false &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><em><strong>CollectGridsAlongDim</strong></em></a> <em>to iterate recursively over the grids on the dimension.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectInterfacesAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_36879d7a164b5ac728612e4a981c6d65.html"><strong>connectivity_details::CollectInterfacesAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundInterfaces, MatchingEdge, true &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectInterfacesAlongDim.html"><em><strong>CollectInterfacesAlongDim</strong></em></a> <em>to stop when the interface has already been identified (due to periodicity).</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1CollectInterfacesAlongDim_3_01StartEdge_00_01InterfaceTypeSeq_00_ebd86d7b2345baf351562d16964c47d9.html"><strong>connectivity_details::CollectInterfacesAlongDim&lt; StartEdge, InterfaceTypeSeq, insert_pos, FoundInterfaces, OutsideEdge, false &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1CollectGridsAlongDim.html"><em><strong>CollectGridsAlongDim</strong></em></a> <em>to stop when there are no more grids.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1EnforceFirstInterfaceEdge.html"><strong>connectivity_details::EnforceFirstInterfaceEdge</strong></a> <em>A class to flip the edges in an interface to ensure that the correct edge comes first.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1EnforceFirstInterfaceEdge_3_01Interface_3_01Edge2_00_01FirstEdge_221a02b03250a49af1745b2263467420.html"><strong>connectivity_details::EnforceFirstInterfaceEdge&lt; Interface&lt; Edge2, FirstEdge, Orientations &gt;, FirstEdge &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1EnforceFirstInterfaceEdge.html"><em><strong>EnforceFirstInterfaceEdge</strong></em></a> <em>for an interface which needs rearranging.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1EnforceFirstInterfaceEdge_3_01Interface_3_01FirstEdge_00_01Edge2_788676fcb3310ca4c1ec984ff0b4531b.html"><strong>connectivity_details::EnforceFirstInterfaceEdge&lt; Interface&lt; FirstEdge, Edge2, Orientations &gt;, FirstEdge &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1EnforceFirstInterfaceEdge.html"><em><strong>EnforceFirstInterfaceEdge</strong></em></a> <em>for an interface which is already correctly arranged.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1ExtractPatches.html"><strong>connectivity_details::ExtractPatches</strong></a> <em>A class to find all the patches used by the various edges.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1ExtractPatches_3_01ddc_1_1detail_1_1TypeSeq_3_01EdgeType1_00_01EdgeTypes_8_8_8_01_4_01_4.html"><strong>connectivity_details::ExtractPatches&lt; ddc::detail::TypeSeq&lt; EdgeType1, EdgeTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1ExtractPatches.html"><em><strong>ExtractPatches</strong></em></a> <em>to iterate recursively over the edge type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1ExtractPatches_3_01ddc_1_1detail_1_1TypeSeq_3_4_01_4.html"><strong>connectivity_details::ExtractPatches&lt; ddc::detail::TypeSeq&lt;&gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1ExtractPatches.html"><em><strong>ExtractPatches</strong></em></a> <em>for an empty patch list.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindInterface.html"><strong>connectivity_details::FindInterface</strong></a> <em>A class to locate an interface which contains the specified edge.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindInterface_3_01Edge_00_01ddc_1_1detail_1_1TypeSeq_3_01Interfac6d31b188ee73012ad6c98be99219379f.html"><strong>connectivity_details::FindInterface&lt; Edge, ddc::detail::TypeSeq&lt; Interface1, RemainingInterfaceTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindInterface.html"><em><strong>FindInterface</strong></em></a> <em>to iterate recursively over the interface type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindInterface_3_01Edge_00_01ddc_1_1detail_1_1TypeSeq_3_01Interfacd1aa547d7cc4bf022e85928246ab2d07.html"><strong>connectivity_details::FindInterface&lt; Edge, ddc::detail::TypeSeq&lt; Interface&lt; Edge, OEdge, Orientations &gt;, RemainingInterfaceTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindInterface.html"><em><strong>FindInterface</strong></em></a> <em>for the case where Edge1 from the first interface matches</em><a href="structEdge.html"><em><strong>Edge</strong></em></a> <em>.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindInterface_3_01Edge_00_01ddc_1_1detail_1_1TypeSeq_3_01Interfacee698732bdf35f06db097afe1714904c.html"><strong>connectivity_details::FindInterface&lt; Edge, ddc::detail::TypeSeq&lt; Interface&lt; OEdge, Edge, Orientations &gt;, RemainingInterfaceTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindInterface.html"><em><strong>FindInterface</strong></em></a> <em>for the case where Edge1 from the second interface matches</em><a href="structEdge.html"><em><strong>Edge</strong></em></a> <em>.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindInterface_3_01Edge_00_01ddc_1_1detail_1_1TypeSeq_3_4_01_4.html"><strong>connectivity_details::FindInterface&lt; Edge, ddc::detail::TypeSeq&lt;&gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindInterface.html"><em><strong>FindInterface</strong></em></a> <em>for an empty interface list.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindPatch.html"><strong>connectivity_details::FindPatch</strong></a> <em>A class to locate a patch which contains the specified grid.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindPatch_3_01Grid1D_00_01ddc_1_1detail_1_1TypeSeq_3_01Patch1_00_33770856242f7c5cee1ce419b2efaf64.html"><strong>connectivity_details::FindPatch&lt; Grid1D, ddc::detail::TypeSeq&lt; Patch1, RemainingPatchTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindPatch.html"><em><strong>FindPatch</strong></em></a> <em>to iterate recursively over the patch type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindPatch_3_01Grid1D_00_01ddc_1_1detail_1_1TypeSeq_3_4_01_4.html"><strong>connectivity_details::FindPatch&lt; Grid1D, ddc::detail::TypeSeq&lt;&gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindPatch.html"><em><strong>FindPatch</strong></em></a> <em>for an empty patch list.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindPatch_3_01QueryGrid1D_00_01ddc_1_1detail_1_1TypeSeq_3_01Patch5f5acd76cfd59a22ebf513823679a320.html"><strong>connectivity_details::FindPatch&lt; QueryGrid1D, ddc::detail::TypeSeq&lt; Patch&lt; OGrid, QueryGrid1D, BSpl1, BSpl2 &gt;, RemainingPatchTypes... &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindPatch_3_01QueryGrid1D_00_01ddc_1_1detail_1_1TypeSeq_3_01Patchd8fc8921dec760f8fe4c90c2a6947228.html"><strong>connectivity_details::FindPatch&lt; QueryGrid1D, ddc::detail::TypeSeq&lt; Patch&lt; QueryGrid1D, OGrid, BSpl1, BSpl2 &gt;, RemainingPatchTypes... &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindRelevantIdxRangeType.html"><strong>connectivity_details::FindRelevantIdxRangeType</strong></a> <em>A class to find any index range types which contain an index range defined on the provided grid. E.g. Grid1, std::tuple&lt;IdxRange&lt;Grid1, Grid2&gt;, IdxRange&lt;Grid3,Grid4&gt;&gt; will find: ddc::detail::TypeSeq&lt;IdxRange&lt;Grid1, Grid2&gt;&gt;</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindRelevantIdxRangeType_3_01QueryGrid1D_00_01std_1_1tuple_3_01Id3b131c802b30082f4412eb4689d6d53b.html"><strong>connectivity_details::FindRelevantIdxRangeType&lt; QueryGrid1D, std::tuple&lt; IdxRangeHead, IdxRangeTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindRelevantIdxRangeType.html"><em><strong>FindRelevantIdxRangeType</strong></em></a> <em>to iterate recursively over the possible index range types.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1FindRelevantIdxRangeType_3_01QueryGrid1D_00_01std_1_1tuple_3_4_01_4.html"><strong>connectivity_details::FindRelevantIdxRangeType&lt; QueryGrid1D, std::tuple&lt;&gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1FindRelevantIdxRangeType.html"><em><strong>FindRelevantIdxRangeType</strong></em></a> <em>for an empty list of index range types.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1PatchConnection.html"><strong>connectivity_details::PatchConnection</strong></a> <em>A class which finds all interfaces connected to a given patch.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1PatchConnection_3_01Patch_00_01ddc_1_1detail_1_1TypeSeq_3_01InterfaceType_01_4_01_4.html"><strong>connectivity_details::PatchConnection&lt; Patch, ddc::detail::TypeSeq&lt; InterfaceType &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1PatchConnection.html"><em><strong>PatchConnection</strong></em></a> <em>for an interface list with one element.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1PatchConnection_3_01Patch_00_01ddc_1_1detail_1_1TypeSeq_3_01Interd9a0a5e7aafe0b71fe7c76720b7c5da6.html"><strong>connectivity_details::PatchConnection&lt; Patch, ddc::detail::TypeSeq&lt; InterfaceType1, RemainingInterfaceTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1PatchConnection.html"><em><strong>PatchConnection</strong></em></a> <em>to iterate recursively over the interface type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1PatchConnection_3_01Patch_00_01ddc_1_1detail_1_1TypeSeq_3_4_01_4.html"><strong>connectivity_details::PatchConnection&lt; Patch, ddc::detail::TypeSeq&lt;&gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1PatchConnection.html"><em><strong>PatchConnection</strong></em></a> <em>for an empty interface list.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1SelectRelevantIdxRangeType.html"><strong>connectivity_details::SelectRelevantIdxRangeType</strong></a> <em>A class to create a type sequence which contains the index range if it can be used to index the grid.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1SelectRelevantIdxRangeType_3_01QueryGrid1D_00_01IdxRange_3_01IdxRangeGrids_8_8_8_01_4_01_4.html"><strong>connectivity_details::SelectRelevantIdxRangeType&lt; QueryGrid1D, IdxRange&lt; IdxRangeGrids... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1SelectRelevantIdxRangeType.html"><em><strong>SelectRelevantIdxRangeType</strong></em></a> <em>to get access to the grids in the index range.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1StripOutsideEdges.html"><strong>connectivity_details::StripOutsideEdges</strong></a> <em>A class which finds all edges which are not</em> <a href="structOutsideEdge.html"><em><strong>OutsideEdge</strong></em></a> <em>types.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1StripOutsideEdges_3_01ddc_1_1detail_1_1TypeSeq_3_01EdgeType_01_4_01_4.html"><strong>connectivity_details::StripOutsideEdges&lt; ddc::detail::TypeSeq&lt; EdgeType &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1StripOutsideEdges.html"><em><strong>StripOutsideEdges</strong></em></a> <em>for the case with one edge in the list.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1StripOutsideEdges_3_01ddc_1_1detail_1_1TypeSeq_3_01EdgeType1_00_036e9ce7e4506982efa52c09ca049ae90.html"><strong>connectivity_details::StripOutsideEdges&lt; ddc::detail::TypeSeq&lt; EdgeType1, RemainingEdgeTypes... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1StripOutsideEdges.html"><em><strong>StripOutsideEdges</strong></em></a> <em>to iterate recursively over the edge type sequence.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1SwapExtremity.html"><strong>connectivity_details::SwapExtremity</strong></a> <em>A class to get the opposite edge of a grid line from one of the edges.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1SwapExtremity_3_01Edge_3_01Patch_00_01Grid1D_00_01BACK_01_4_01_4.html"><strong>connectivity_details::SwapExtremity&lt; Edge&lt; Patch, Grid1D, BACK &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1SwapExtremity.html"><em><strong>SwapExtremity</strong></em></a> <em>for an edge at the back end of a grid line.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1SwapExtremity_3_01Edge_3_01Patch_00_01Grid1D_00_01FRONT_01_4_01_4.html"><strong>connectivity_details::SwapExtremity&lt; Edge&lt; Patch, Grid1D, FRONT &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1SwapExtremity.html"><em><strong>SwapExtremity</strong></em></a> <em>for an edge at the front end of a grid line.</em></li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1ToTuple.html"><strong>connectivity_details::ToTuple</strong></a> <em>A class to convert a type sequence to a tuple type.</em> </li>
<li><strong>struct</strong> <a href="structconnectivity__details_1_1ToTuple_3_01ddc_1_1detail_1_1TypeSeq_3_01I_8_8_8_01_4_01_4.html"><strong>connectivity_details::ToTuple&lt; ddc::detail::TypeSeq&lt; I... &gt; &gt;</strong></a> <em>Specialisation of</em> <a href="structconnectivity__details_1_1ToTuple.html"><em><strong>ToTuple</strong></em></a> <em>for type sequences.</em></li>
<li><strong>struct</strong> <a href="structinterpolator__on__idx__range.html"><strong>interpolator_on_idx_range</strong></a> </li>
<li><strong>struct</strong> <a href="structinterpolator__on__idx__range_3_01Interp_00_01GridInterp_00_01IdxRange_3_01Grid1D_8_8_8_01_4_01_4.html"><strong>interpolator_on_idx_range&lt; Interp, GridInterp, IdxRange&lt; Grid1D... &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1GetContravariantDims.html"><strong>tensor_tools::GetContravariantDims</strong></a> <em>A class to get a VectorIndexSet containing only contravariant dimensions.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1GetContravariantDims_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::GetContravariantDims&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> <em>A class to get a VectorIndexSet containing only contravariant dimensions.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1GetCovariantDims.html"><strong>tensor_tools::GetCovariantDims</strong></a> <em>A class to get a VectorIndexSet containing only covariant dimensions.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1GetCovariantDims_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::GetCovariantDims&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> <em>A class to get a VectorIndexSet containing only covariant dimensions.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1VectorIndexIdMap.html"><strong>tensor_tools::VectorIndexIdMap</strong></a> <em>A class representing a vector index identifier.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__contravariant__vector__index__set.html"><strong>tensor_tools::is_contravariant_vector_index_set</strong></a> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__contravariant__vector__index__set_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::is_contravariant_vector_index_set&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> <em>A helper structure to check if all the dimensions in a VectorIndexSet can represent contravariant indices.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__covariant__vector__index__set.html"><strong>tensor_tools::is_covariant_vector_index_set</strong></a> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__covariant__vector__index__set_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::is_covariant_vector_index_set&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> <em>A helper structure to check if all the dimensions in a VectorIndexSet can represent covariant indices.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1vector__index__set__dual.html"><strong>tensor_tools::vector_index_set_dual</strong></a> <em>A helper structure to find a VectorIndexSet describing the covariant indices from a VectorIndexSet describing contravariant indices or to find a VectorIndexSet describing the contravariant indices from a VectorIndexSet describing covariant indices.</em> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1vector__index__set__dual_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::vector_index_set_dual&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> <em>The implementation of</em> <a href="structtensor__tools_1_1vector__index__set__dual.html"><em><strong>vector_index_set_dual</strong></em></a> <em>for a VectorIndexSet.</em></li>
<li><strong>class</strong> <strong>IAdvectionV&lt; IdxRangeFdistribu, IdxRangeSpatial &gt;</strong>    <ul>
<li><strong>class</strong> <a href="classNullAdvectionVelocity.html"><strong>NullAdvectionVelocity</strong></a> <em>This is a class which imitates a velocity advection. It inherits from IAdvectionV and can be used as an advection operator but does not actually modify the distribution function. This can be useful for debugging purposes.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsMu, ddc::UniformBSplines&lt; Mu, BSDegreeMu &gt;, ddc::NonUniformBSplines&lt; Mu, BSDegreeMu &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesMu.html"><strong>BSplinesMu</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsR, ddc::UniformBSplines&lt; R, BSDegreeR &gt;, ddc::NonUniformBSplines&lt; R, BSDegreeR &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesR.html"><strong>BSplinesR</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsTheta, ddc::UniformBSplines&lt; Theta, BSDegreeTheta &gt;, ddc::NonUniformBSplines&lt; Theta, BSDegreeTheta &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesTheta.html"><strong>BSplinesTheta</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsVpar, ddc::UniformBSplines&lt; Vpar, BSDegreeVpar &gt;, ddc::NonUniformBSplines&lt; Vpar, BSDegreeVpar &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesVpar.html"><strong>BSplinesVpar</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsVx, ddc::UniformBSplines&lt; Vx, BSDegreeVx &gt;, ddc::NonUniformBSplines&lt; Vx, BSDegreeVx &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesVx.html"><strong>BSplinesVx</strong></a> </li>
<li><strong>struct</strong> <a href="structBSplinesVx.html"><strong>BSplinesVx</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsVy, ddc::UniformBSplines&lt; Vy, BSDegreeVy &gt;, ddc::NonUniformBSplines&lt; Vy, BSDegreeVy &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesVy.html"><strong>BSplinesVy</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsX, ddc::UniformBSplines&lt; X, BSDegreeX &gt;, ddc::NonUniformBSplines&lt; X, BSDegreeX &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesX.html"><strong>BSplinesX</strong></a> </li>
<li><strong>struct</strong> <a href="structBSplinesX.html"><strong>BSplinesX</strong></a> </li>
<li><strong>struct</strong> <a href="structBSplinesX.html"><strong>BSplinesX</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BsplineOnUniformCellsY, ddc::UniformBSplines&lt; Y, BSDegreeY &gt;, ddc::NonUniformBSplines&lt; Y, BSDegreeY &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structBSplinesY.html"><strong>BSplinesY</strong></a> </li>
<li><strong>struct</strong> <a href="structBSplinesY.html"><strong>BSplinesY</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; uniform_edge_v, UniformGridBase&lt; Vx &gt;, NonUniformGridBase&lt; Vx &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structCollisionsIntra_1_1GhostedVx.html"><strong>CollisionsIntra::GhostedVx</strong></a> </li>
<li><strong>struct</strong> <a href="structCollisionsIntra_1_1GhostedVxStaggered.html"><strong>CollisionsIntra::GhostedVxStaggered</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>NonUniformGridBase&lt; PDEDim &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structFEM1DPoissonSolver_1_1GridPDEDimQ.html"><strong>FEM1DPoissonSolver::GridPDEDimQ</strong></a> <em>The grid of quadrature points along the PDEDim direction.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>ddc::NonUniformBSplines&lt; PDEDim, InputBSplines::degree()&gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structFEM1DPoissonSolver_1_1HiddenFEMBSplines.html"><strong>FEM1DPoissonSolver::HiddenFEMBSplines</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>ddc::PeriodicSampling&lt; ddc::Fourier&lt; Dim &gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structFFTPoissonSolver_3_01IdxRange_3_01GridPDEDim1D_8_8_8_01_4_00_01IdxRangeFull_00_01ExecSpace2aeecfe91d464f5738599cc105fb6087.html"><strong>FFTPoissonSolver&lt; IdxRange&lt; GridPDEDim1D... &gt;, IdxRangeFull, ExecSpace, LayoutSpace &gt;::GridFourier</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsMu::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridMu.html"><strong>GridMu</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsR::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridR.html"><strong>GridR</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsTheta::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridTheta.html"><strong>GridTheta</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsVpar::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridVpar.html"><strong>GridVpar</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsVx::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridVx.html"><strong>GridVx</strong></a> </li>
<li><strong>struct</strong> <a href="structGridVx.html"><strong>GridVx</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsVy::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridVy.html"><strong>GridVy</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsX::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridX.html"><strong>GridX</strong></a> </li>
<li><strong>struct</strong> <a href="structGridX.html"><strong>GridX</strong></a> </li>
<li><strong>struct</strong> <a href="structGridX.html"><strong>GridX</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>SplineInterpPointsY::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structGridY.html"><strong>GridY</strong></a> </li>
<li><strong>struct</strong> <a href="structGridY.html"><strong>GridY</strong></a> </li>
</ul>
</li>
<li><strong>class</strong> <strong>NonUniformGridBase&lt; R &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1QDimRMesh.html"><strong>PolarSplineFEMPoissonLikeSolver::QDimRMesh</strong></a> <em>Tag the first dimension for the quadrature mesh.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>NonUniformGridBase&lt; Theta &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structPolarSplineFEMPoissonLikeSolver_1_1QDimThetaMesh.html"><strong>PolarSplineFEMPoissonLikeSolver::QDimThetaMesh</strong></a> <em>Tag the second dimension for the quadrature mesh.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BSplinesROriginal::is_uniform(), ddc::UniformBSplines&lt; R, BSplinesROriginal::degree()&gt;, ddc::NonUniformBSplines&lt; R, BSplinesROriginal::degree()&gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1BSplinesRRefined.html"><strong>RefinedDiscreteToCartesianBuilder::BSplinesRRefined</strong></a> <em>The type of the radial B-splines on which the new mapping will be defined.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::conditional_t&lt; BSplinesThetaOriginal::is_uniform(), ddc::UniformBSplines&lt; Theta, BSplinesThetaOriginal::degree()&gt;, ddc::NonUniformBSplines&lt; Theta, BSplinesThetaOriginal::degree()&gt; &gt;</strong>    <ul>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1BSplinesThetaRefined.html"><strong>RefinedDiscreteToCartesianBuilder::BSplinesThetaRefined</strong></a> <em>The type of the poloidal B-splines on which the new mapping will be defined.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>GrevillePointsR::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1GridRRefined.html"><strong>RefinedDiscreteToCartesianBuilder::GridRRefined</strong></a> <em>The type of the grid of radial points on which the new mapping will be defined.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>GrevillePointsTheta::interpolation_discrete_dimension_type</strong>    <ul>
<li><strong>struct</strong> <a href="structRefinedDiscreteToCartesianBuilder_1_1GridThetaRefined.html"><strong>RefinedDiscreteToCartesianBuilder::GridThetaRefined</strong></a> <em>The type of the grid of poloidal points on which the new mapping will be defined.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::false_type</strong>    <ul>
<li><strong>struct</strong> <a href="structddcHelper_1_1is__non__uniform__interpolation__points.html"><strong>ddcHelper::is_non_uniform_interpolation_points</strong></a> </li>
<li><strong>struct</strong> <a href="structis__onion__patch__locator.html"><strong>is_onion_patch_locator</strong></a> <em>Struct to identify if the patch locator is adapted to onion geometry.</em> </li>
<li><strong>struct</strong> <a href="structis__subidx__range__collection.html"><strong>is_subidx_range_collection</strong></a> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__vector__index__set.html"><strong>tensor_tools::is_vector_index_set</strong></a> <em>A helper structure to recognise a VectorIndexSet type.</em> </li>
</ul>
</li>
<li><strong>class</strong> <strong>std::true_type</strong>    <ul>
<li><strong>struct</strong> <a href="structddcHelper_1_1is__non__uniform__interpolation__points_3_01NonUniformInterpolationPoints_3_047d1c8570873e3c052e2e394afcf9270.html"><strong>ddcHelper::is_non_uniform_interpolation_points&lt; NonUniformInterpolationPoints&lt; BSplines, BcXmin, BcXmax &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structis__onion__patch__locator_3_01OnionPatchLocator_3_01MultipatchIdxRanges_00_01LogicalToPhys15c96379834346672a2b2d644897e91f.html"><strong>is_onion_patch_locator&lt; OnionPatchLocator&lt; MultipatchIdxRanges, LogicalToPhysicalMapping, PhysicalToLogicalMapping, ExecSpace &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structis__subidx__range__collection_3_01IdxRangeSlice_3_01Tags_8_8_8_01_4_01_4.html"><strong>is_subidx_range_collection&lt; IdxRangeSlice&lt; Tags... &gt; &gt;</strong></a> </li>
<li><strong>struct</strong> <a href="structtensor__tools_1_1is__vector__index__set_3_01VectorIndexSet_3_01Dims_8_8_8_01_4_01_4.html"><strong>tensor_tools::is_vector_index_set&lt; VectorIndexSet&lt; Dims... &gt; &gt;</strong></a> </li>
</ul>
</li>
</ul></div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="classes.html" class="btn btn-neutral float-left" title="Class Index"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="namespaces.html" class="btn btn-neutral float-right" title="Namespace List">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/gyselax/gyselalibxx/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="classes.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="namespaces.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../docs/jscript/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
