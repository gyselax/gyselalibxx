<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>File polar_bsplines.hpp - GyselalibX</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "File polar_bsplines.hpp";
        var mkdocs_page_input_path = "gyselalibxx/polar__bsplines_8hpp_source.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> GyselalibX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >First Steps</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/getting_started.html">Getting Started</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Installation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../docs/first_steps/install.html">Gyselalib++ Installation</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../toolchains/index.html">Pre-made build settings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../docs/first_steps/DDC_in_gyselalibxx.html">DDC in Gyselalib++</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Standards</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/CODING_STANDARD.html">Coding Standard</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/standards/mathematical_and_physical_conventions.html">Math & Physics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gyselalib++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Source</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../src/index.html">Gyselalib++ contents</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/advection/index.html">Advection methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/collisions/index.html">Collisions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/data_types/index.html">Data Storage Types</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryRTheta/index.html">Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection/index.html">Advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_field</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/advection_field/index.html">Advection Field finder</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/geometry/index.html">Geometry RTheta</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/initialisation/index.html">Initialisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/poisson/index.html">Polar Poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_solver</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryRTheta/time_solver/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryVparMu</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryVparMu/index.html">Geometry (vpar, mu)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/collisions/index.html">CollisionConfiguration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/geometry/index.html">GeometryVparMu</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryVparMu/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXVx/index.html">Geometry (x, v_x)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >boltzmann</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/boltzmann/index.html">Boltzmann solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/geometry/index.html">Geometry X-Vx</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >rhs</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/rhs/index.html">RHS</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXVx/utils/index.html">Utils</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXY/index.html">Geometry (x, y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/geometry/index.html">Geometry XY</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/initialisation/index.html">Initialisation on (x,y) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXY/time_integration/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXYVxVy</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/geometryXYVxVy/index.html">Geometry (x, y, v_x, v_y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/geometry/index.html">Geometry X Y-Vx Vy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vlasov</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/geometryXYVxVy/vlasov/index.html">Vlasov solver</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >interpolation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/interpolation/index.html">Interpolation Methods</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_splines</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/interpolation/polar_splines/index.html">Polar Splines</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >io</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/io/index.html">Functions used for input and output</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mapping</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mapping/index.html">Mappings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >math_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/math_tools/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >matrix_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/matrix_tools/index.html">Matrix tools</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mpi_parallelisation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/mpi_parallelisation/index.html">Parallelisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/multipatch/index.html">Multipatch</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >connectivity</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/connectivity/index.html">Multipatch connectivity</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/data_types/index.html">Data Types for Multipatch Geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/spline/index.html">Spline on multipatch geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../src/multipatch/utils/index.html">Multipatch utilitary functions</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >pde_solvers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/pde_solvers/index.html">PDE Solvers</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >quadrature</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/quadrature/index.html">Quadrature Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >speciesinfo</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/speciesinfo/index.html">SpeciesInfo (x, v_x)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >timestepper</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/timestepper/index.html">Time Stepping Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../src/utils/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Simulations</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../simulations/index.html">Gyselalib++ simulations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryRTheta/index.html">Simulations in (r, theta) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >diocotron</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/diocotron/index.html">Diocotron instability</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vortex_merger</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryRTheta/vortex_merger/index.html">Vortex merger</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXVx/index.html">Simulations in (x, vx) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../simulations/geometryXY/index.html">Simulations in (x, y) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >guiding_centre</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../simulations/geometryXY/guiding_centre/index.html">Guiding centre (X,Y) simulation</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tests</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../tests/index.html">Gyselalib++ tests</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/advection/index.html">Tests on the templated advection operators</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/geometryRTheta/index.html">Tests : Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/advection_rtheta/index.html">Tests on the 2D polar advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/polar_poisson/index.html">Tests on the 2D polar poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline_interpolator_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/geometryRTheta/spline_interpolator_rtheta/index.html">Tests on spline interpolator in polar coordinates</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../tests/multipatch/index.html">Multipatch geometry tests</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometries</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../tests/multipatch/geometries/index.html">Multipatch geometries</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Adding_docs.html">Adding Docs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/Using_git.html">Using Git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/development/developer_FAQ.html">Developer FAQ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Troubleshooting</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../docs/troubleshooting/Common_compilation_problems.html">Compilation Issues</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Gyselalib++</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Classes</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="annotated.html">Class List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="classes.html">Class Index</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="hierarchy.html">Class Hierarchy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Namespaces</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="namespaces.html">Namespace List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_members.html">Namespace Members</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_functions.html">Namespace Member Functions</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_variables.html">Namespace Member Variables</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_typedefs.html">Namespace Member Typedefs</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="namespace_member_enums.html">Namespace Member Enumerations</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="variables.html">Variables</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="macros.html">Macros</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="files.html">Files</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">GyselalibX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">File polar_bsplines.hpp</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/gyselax/gyselalibxx/edit/main/gyselalibxx/polar__bsplines_8hpp_source.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div><h1 id="file-polar_bsplineshpp">File polar_bsplines.hpp</h1>
<p><a href="files.html"><strong>File List</strong></a> <strong>&gt;</strong> <a href="dir_264890e5c091f8c8d7fe1f842870c25e.html"><strong>interpolation</strong></a> <strong>&gt;</strong> <a href="dir_a6779ae02b71d57f488d261458bab1ce.html"><strong>polar_splines</strong></a> <strong>&gt;</strong> <a href="polar__bsplines_8hpp.html"><strong>polar_bsplines.hpp</strong></a></p>
<p><a href="polar__bsplines_8hpp.html">Go to the documentation of this file</a></p>
<pre><code class="language-C++">// SPDX-License-Identifier: MIT
#pragma once
#include &lt;array&gt;
#include &lt;vector&gt;

#include &lt;ddc/ddc.hpp&gt;

#include "bernstein.hpp"
#include "cartesian_to_barycentric.hpp"
#include "ddc_helper.hpp"
#include "discrete_to_cartesian.hpp"
#include "mapping_tools.hpp"
#include "polar_spline.hpp"
#include "view.hpp"

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
class PolarBSplines
{
    static_assert(C &gt;= -1, "Parameter `C` cannot be less than -1");
    static_assert(C &lt; 2, "Values larger than 1 are not implemented for parameter `C`");
    static_assert(!BSplinesR::is_periodic(), "Radial B-splines must not be periodic.");
    static_assert(!BSplinesR::is_uniform(), "Radial B-splines must have knots at the boundary.");
    static_assert(BSplinesTheta::is_periodic(), "Poloidal B-splines should be periodic.");

private:
    // Tags to determine what to evaluate
    struct eval_type
    {
    };

    struct eval_deriv_type
    {
    };

public:
    using BSplinesR_tag = BSplinesR;

    using BSplinesTheta_tag = BSplinesTheta;


    using DimR = typename BSplinesR::continuous_dimension_type;

    using DimTheta = typename BSplinesTheta::continuous_dimension_type;

public:
    static int constexpr continuity = C;

public:
    using discrete_dimension_type = PolarBSplines;

    using tensor_product_index_type = Idx&lt;BSplinesR, BSplinesTheta&gt;;

    using tensor_product_idx_range_type = IdxRange&lt;BSplinesR, BSplinesTheta&gt;;

    using tensor_product_idx_step_type = IdxStep&lt;BSplinesR, BSplinesTheta&gt;;

private:
    using IdxR = Idx&lt;BSplinesR&gt;;
    using IdxTheta = Idx&lt;BSplinesTheta&gt;;
    using IdxStepR = IdxStep&lt;BSplinesR&gt;;
    using IdxStepTheta = IdxStep&lt;BSplinesTheta&gt;;

public:
    static constexpr std::size_t n_singular_basis()
    {
        return (C + 1) * (C + 2) / 2;
    }


    template &lt;class DDim&gt;
    static constexpr IdxRange&lt;DDim&gt; singular_idx_range()
    {
        return IdxRange&lt;DDim&gt;(Idx&lt;DDim&gt; {0}, IdxStep&lt;DDim&gt; {n_singular_basis()});
    }

    template &lt;class DDim&gt;
    static KOKKOS_FUNCTION Idx&lt;DDim&gt; get_polar_index(tensor_product_index_type const&amp; idx)
    {
        Idx&lt;BSplinesR&gt; idx_r(idx);
        Idx&lt;BSplinesTheta&gt; idx_theta(idx);
        int const r_idx = idx_r - Idx&lt;BSplinesR&gt;(C + 1);
        int const theta_idx = idx_theta - Idx&lt;BSplinesTheta&gt;(0);
        assert(r_idx &gt;= 0);
        int local_idx(r_idx * ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis() + theta_idx);
        return Idx&lt;DDim&gt;(n_singular_basis() + local_idx);
    }

    template &lt;class DDim&gt;
    static KOKKOS_FUNCTION tensor_product_index_type get_2d_index(Idx&lt;DDim&gt; const&amp; idx)
    {
        assert(idx &gt;= Idx&lt;DDim&gt;(n_singular_basis()));
        int const idx_2d = idx - Idx&lt;DDim&gt;(n_singular_basis());
        int const r_idx = idx_2d / ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        int const theta_idx = idx_2d - r_idx * ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
        Idx&lt;BSplinesR&gt; r_idx_elem(r_idx + C + 1);
        Idx&lt;BSplinesTheta&gt; theta_idx_elem(theta_idx);
        return Idx&lt;BSplinesR, BSplinesTheta&gt;(r_idx_elem, theta_idx_elem);
    }

public:
    template &lt;class DDim, class MemorySpace&gt;
    class Impl
    {
        template &lt;class ODDim, class OMemorySpace&gt;
        friend class Impl;

        template &lt;class ExecSpace, class PBSpl, class OMemorySpace&gt;
        friend PolarSpline&lt;PBSpl, OMemorySpace&gt; integrals(
                ExecSpace const&amp; execution_space,
                PolarSpline&lt;PBSpl, OMemorySpace&gt; int_vals);

    private:
        using singular_basis_linear_combination_idx_range_type
                = IdxRange&lt;DDim, BSplinesR, BSplinesTheta&gt;;

        DFieldMem&lt;singular_basis_linear_combination_idx_range_type, MemorySpace&gt;
                m_singular_basis_elements_alloc;

        DField&lt;singular_basis_linear_combination_idx_range_type, MemorySpace&gt;
                m_singular_basis_elements;

    public:
        struct Corner1Tag
        {
        };
        struct Corner2Tag
        {
        };
        struct Corner3Tag
        {
        };

        template &lt;class DiscreteMapping&gt;
        struct IntermediateBernsteinBasis
            : TriangularBernsteinPolynomialBasis&lt;
                      typename DiscreteMapping::cartesian_tag_x,
                      typename DiscreteMapping::cartesian_tag_y,
                      Corner1Tag,
                      Corner2Tag,
                      Corner3Tag,
                      C&gt;
        {
        };

        using discrete_dimension_type = PolarBSplines;

        using discrete_element_type = Idx&lt;DDim&gt;;

        using discrete_domain_type = IdxRange&lt;DDim&gt;;

        using discrete_vector_type = IdxStep&lt;DDim&gt;;

        template &lt;class DiscreteMapping&gt;
        explicit Impl(const DiscreteMapping&amp; curvilinear_to_cartesian)
        {
            static_assert(is_accessible_v&lt;Kokkos::DefaultHostExecutionSpace, DiscreteMapping&gt;);
            static_assert(std::is_same_v&lt;MemorySpace, Kokkos::HostSpace&gt;);
            using DimX = typename DiscreteMapping::cartesian_tag_x;
            using DimY = typename DiscreteMapping::cartesian_tag_y;
            using mapping_tensor_product_index_type
                    = Idx&lt;typename DiscreteMapping::BSplineR,
                          typename DiscreteMapping::BSplineTheta&gt;;
            if constexpr (C &gt; -1) {
                const ddc::Coordinate&lt;DimX, DimY&gt; pole
                        = curvilinear_to_cartesian(ddc::Coordinate&lt;DimR, DimTheta&gt;(0.0, 0.0));
                const double x0 = ddc::get&lt;DimX&gt;(pole);
                const double y0 = ddc::get&lt;DimY&gt;(pole);
                double tau = 0.0;
                for (std::size_t i(0); i &lt; ddc::discrete_space&lt;BSplinesTheta&gt;().size(); ++i) {
                    const ddc::Coordinate&lt;DimX, DimY&gt; point
                            = curvilinear_to_cartesian.control_point(
                                    mapping_tensor_product_index_type(1, i));

                    const double c_x = ddc::get&lt;DimX&gt;(point);
                    const double c_y = ddc::get&lt;DimY&gt;(point);

                    double tau1 = -2.0 * (c_x - x0);
                    double tau2 = c_x - x0 - sqrt(3.0) * (c_y - y0);
                    double tau3 = c_x - x0 + sqrt(3.0) * (c_y - y0);
                    tau = tau &gt; tau1 ? tau : tau1;
                    tau = tau &gt; tau2 ? tau : tau2;
                    tau = tau &gt; tau3 ? tau : tau3;
                }
                // Determine the corners for the barycentric coordinates
                const ddc::Coordinate&lt;DimX, DimY&gt; corner1(x0 + tau, y0);
                const ddc::Coordinate&lt;DimX, DimY&gt;
                        corner2(x0 - 0.5 * tau, y0 + 0.5 * tau * sqrt(3.0));
                const ddc::Coordinate&lt;DimX, DimY&gt;
                        corner3(x0 - 0.5 * tau, y0 - 0.5 * tau * sqrt(3.0));

                const CartesianToBarycentric&lt;DimX, DimY, Corner1Tag, Corner2Tag, Corner3Tag&gt;
                        barycentric_coordinate_converter(corner1, corner2, corner3);

                using BernsteinBasis = IntermediateBernsteinBasis&lt;DiscreteMapping&gt;;

                ddc::init_discrete_space&lt;BernsteinBasis&gt;(barycentric_coordinate_converter);

                // The number of radial bases used to construct the B-splines traversing the singular point.
                constexpr IdxStepR nr_in_singular(C + 1);
                assert(nr_in_singular.value() &lt; int(ddc::discrete_space&lt;BSplinesR&gt;().size()));

                // The number of poloidal bases used to construct the B-splines traversing the singular point.
                const IdxStepTheta n_theta_in_singular(
                        ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis());

                // The number of elements of the poloidal basis which will have an associated coefficient
                // (This will be larger than n_theta_in_singular as it includes the periodicity)
                const IdxStepTheta np_tot(ddc::discrete_space&lt;BSplinesTheta&gt;().size());

                // The index range of the 2D B-splines in the innermost circles from which the polar B-splines
                // traversing the singular point will be constructed.
                tensor_product_idx_range_type const dom_bsplines_inner(
                        tensor_product_index_type(0, 0),
                        tensor_product_idx_step_type(nr_in_singular, np_tot));

                // Initialise memory
                m_singular_basis_elements_alloc
                        = host_t&lt;DFieldMem&lt;singular_basis_linear_combination_idx_range_type&gt;&gt;(
                                singular_basis_linear_combination_idx_range_type(
                                        singular_idx_range&lt;DDim&gt;(),
                                        dom_bsplines_inner));
                m_singular_basis_elements = get_field(m_singular_basis_elements_alloc);

                IdxRange&lt;BernsteinBasis&gt; bernstein_idx_range(
                        Idx&lt;BernsteinBasis&gt; {0},
                        IdxStep&lt;BernsteinBasis&gt; {n_singular_basis()});

                IdxRange&lt;BSplinesTheta&gt; poloidal_spline_idx_range
                        = ddc::discrete_space&lt;BSplinesTheta&gt;().full_domain();

                for (IdxR const ir : IdxRange&lt;BSplinesR&gt;(IdxR(0), IdxStepR(C + 1))) {
                    for (IdxTheta const itheta :
                         poloidal_spline_idx_range.take_first(n_theta_in_singular)) {
                        const ddc::Coordinate&lt;DimX, DimY&gt; point
                                = curvilinear_to_cartesian.control_point(
                                        mapping_tensor_product_index_type(ir, itheta));
                        host_t&lt;DFieldMem&lt;IdxRange&lt;BernsteinBasis&gt;&gt;&gt; bernstein_vals(
                                bernstein_idx_range);
                        ddc::discrete_space&lt;BernsteinBasis&gt;()
                                .eval_basis(get_field(bernstein_vals), point);
                        // Fill spline coefficients
                        for (Idx&lt;BernsteinBasis&gt; k : bernstein_idx_range) {
                            m_singular_basis_elements(
                                    discrete_element_type {
                                            (k - bernstein_idx_range.front()).value()},
                                    ir,
                                    itheta)
                                    = bernstein_vals(k);
                        }
                    }
                    for (discrete_element_type k : singular_idx_range&lt;DDim&gt;()) {
                        for (IdxTheta const itheta : poloidal_spline_idx_range.take_first(
                                     IdxStepTheta {BSplinesTheta::degree()})) {
                            m_singular_basis_elements(k, ir, itheta + n_theta_in_singular)
                                    = m_singular_basis_elements(k, ir, itheta);
                        }
                    }
                }
            } else {
                // Initialise m_singular_basis_elements to avoid any problems in the copy constructor
                tensor_product_idx_range_type const empty_dom_bsplines(
                        tensor_product_index_type(0, 0),
                        tensor_product_idx_step_type(0, 0));
                m_singular_basis_elements_alloc
                        = host_t&lt;DFieldMem&lt;singular_basis_linear_combination_idx_range_type&gt;&gt;(
                                singular_basis_linear_combination_idx_range_type(
                                        singular_idx_range&lt;DDim&gt;(),
                                        empty_dom_bsplines));
                m_singular_basis_elements = get_field(m_singular_basis_elements_alloc);
            }
        }

        template &lt;class OriginMemorySpace&gt;
        explicit Impl(Impl&lt;DDim, OriginMemorySpace&gt; const&amp; impl)
            : m_singular_basis_elements_alloc(get_idx_range(impl.m_singular_basis_elements))
        {
            m_singular_basis_elements = get_field(m_singular_basis_elements_alloc);
            ddc::parallel_deepcopy(m_singular_basis_elements, impl.m_singular_basis_elements);
        }

        Impl(Impl const&amp; x) = default;

        Impl(Impl&amp;&amp; x) = default;

        ~Impl() = default;

        Impl&amp; operator=(Impl const&amp; x) = default;

        Impl&amp; operator=(Impl&amp;&amp; x) = default;

        KOKKOS_FUNCTION tensor_product_index_type eval_basis(
                DSpan1D singular_values,
                DSpan2D values,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const;

        KOKKOS_FUNCTION tensor_product_index_type eval_deriv_r(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const;

        KOKKOS_FUNCTION tensor_product_index_type eval_deriv_theta(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const;

        KOKKOS_FUNCTION tensor_product_index_type eval_deriv_r_and_theta(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const;

        template &lt;class MemorySpace2&gt;
        [[deprecated("Use `integrals` instead")]] void integrals(
                PolarSpline&lt;DDim, MemorySpace2&gt; int_vals) const;

        std::size_t nbasis() const noexcept
        {
            std::size_t nr = ddc::discrete_space&lt;BSplinesR&gt;().nbasis() - C - 1;
            std::size_t ntheta = ddc::discrete_space&lt;BSplinesTheta&gt;().nbasis();
            return n_singular_basis() + nr * ntheta;
        }

        discrete_domain_type full_domain() const noexcept
        {
            return discrete_domain_type(discrete_element_type {0}, discrete_vector_type {nbasis()});
        }

        discrete_domain_type tensor_bspline_idx_range() const noexcept
        {
            return full_domain().remove_first(discrete_vector_type {n_singular_basis()});
        }

    private:
        template &lt;class EvalTypeR, class EvalTypeTheta&gt;
        KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; eval(
                DSpan1D singular_values,
                DSpan2D values,
                ddc::Coordinate&lt;DimR, DimTheta&gt; coord_eval,
                EvalTypeR const,
                EvalTypeTheta const) const;
    };
};

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::
        Impl&lt;DDim, MemorySpace&gt;::eval_basis(
                DSpan1D singular_values,
                DSpan2D values,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const
{
    return eval(singular_values, values, p, eval_type(), eval_type());
}

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::
        Impl&lt;DDim, MemorySpace&gt;::eval_deriv_r(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const
{
    return eval(singular_derivs, derivs, p, eval_deriv_type(), eval_type());
}

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::
        Impl&lt;DDim, MemorySpace&gt;::eval_deriv_theta(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const
{
    return eval(singular_derivs, derivs, p, eval_type(), eval_deriv_type());
}

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::
        Impl&lt;DDim, MemorySpace&gt;::eval_deriv_r_and_theta(
                DSpan1D singular_derivs,
                DSpan2D derivs,
                ddc::Coordinate&lt;DimR, DimTheta&gt; p) const
{
    return eval(singular_derivs, derivs, p, eval_deriv_type(), eval_deriv_type());
}

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
template &lt;class EvalTypeR, class EvalTypeTheta&gt;
KOKKOS_FUNCTION Idx&lt;BSplinesR, BSplinesTheta&gt; PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::
        Impl&lt;DDim, MemorySpace&gt;::eval(
                DSpan1D singular_values,
                DSpan2D values,
                ddc::Coordinate&lt;DimR, DimTheta&gt; coord_eval,
                EvalTypeR const,
                EvalTypeTheta const) const
{
    assert(singular_values.extent(0) == n_singular_basis());
    assert(values.extent(0) == BSplinesR::degree() + 1);
    assert(values.extent(1) == BSplinesTheta::degree() + 1);
    static_assert(
            std::is_same_v&lt;EvalTypeR, eval_type&gt; || std::is_same_v&lt;EvalTypeR, eval_deriv_type&gt;);
    static_assert(
            std::is_same_v&lt;
                    EvalTypeTheta,
                    eval_type&gt; || std::is_same_v&lt;EvalTypeTheta, eval_deriv_type&gt;);

    Idx&lt;BSplinesR&gt; jmin_r;
    Idx&lt;BSplinesTheta&gt; jmin_theta;

    std::size_t constexpr nr = BSplinesR::degree() + 1;
    std::size_t constexpr ntheta = BSplinesTheta::degree() + 1;

    std::array&lt;double, nr&gt; vals_r_ptr;
    std::array&lt;double, ntheta&gt; vals_theta_ptr;
    DSpan1D const vals_r(vals_r_ptr.data(), nr);
    DSpan1D const vals_theta(vals_theta_ptr.data(), ntheta);

    if constexpr (std::is_same_v&lt;EvalTypeR, eval_type&gt;) {
        jmin_r = ddc::discrete_space&lt;BSplinesR&gt;().eval_basis(vals_r, ddc::select&lt;DimR&gt;(coord_eval));
    } else if constexpr (std::is_same_v&lt;EvalTypeR, eval_deriv_type&gt;) {
        jmin_r = ddc::discrete_space&lt;BSplinesR&gt;().eval_deriv(vals_r, ddc::select&lt;DimR&gt;(coord_eval));
    }
    if constexpr (std::is_same_v&lt;EvalTypeTheta, eval_type&gt;) {
        jmin_theta = ddc::discrete_space&lt;BSplinesTheta&gt;()
                             .eval_basis(vals_theta, ddc::select&lt;DimTheta&gt;(coord_eval));
    } else if constexpr (std::is_same_v&lt;EvalTypeTheta, eval_deriv_type&gt;) {
        jmin_theta = ddc::discrete_space&lt;BSplinesTheta&gt;()
                             .eval_deriv(vals_theta, ddc::select&lt;DimTheta&gt;(coord_eval));
    }

    std::size_t nr_done = 0;

    Idx&lt;BSplinesR&gt; first_tensor_product_radial_spline(C + 1);

    if (jmin_r &lt; first_tensor_product_radial_spline) {
        nr_done = first_tensor_product_radial_spline - jmin_r;
        for (discrete_element_type k : singular_idx_range&lt;DDim&gt;()) {
            singular_values(k - discrete_element_type(0)) = 0.0;
            for (std::size_t i(0); i &lt; nr_done; ++i) {
                for (std::size_t j(0); j &lt; ntheta; ++j) {
                    singular_values(k - discrete_element_type(0))
                            += m_singular_basis_elements(k, jmin_r + i, jmin_theta + j) * vals_r[i]
                               * vals_theta[j];
                }
            }
        }
    } else {
        for (std::size_t k(0); k &lt; n_singular_basis(); ++k) {
            singular_values(k) = 0.0;
        }
    }

    for (std::size_t i(0); i &lt; nr - nr_done; ++i) {
        for (std::size_t j(0); j &lt; ntheta; ++j) {
            values(i, j) = vals_r[i + nr_done] * vals_theta[j];
        }
    }
    for (std::size_t i(nr - nr_done); i &lt; nr; ++i) {
        for (std::size_t j(0); j &lt; ntheta; ++j) {
            values(i, j) = 0.0;
        }
    }
    return Idx&lt;BSplinesR, BSplinesTheta&gt;(jmin_r, jmin_theta);
}

template &lt;class ExecSpace, class DDim, class MemorySpace&gt;
PolarSpline&lt;DDim, MemorySpace&gt; integrals(
        ExecSpace const&amp; execution_space,
        PolarSpline&lt;DDim, MemorySpace&gt; int_vals)
{
    static_assert(
            Kokkos::SpaceAccessibility&lt;ExecSpace, MemorySpace&gt;::accessible,
            "MemorySpace has to be accessible for ExecutionSpace.");
    using BSplinesR = typename DDim::BSplinesR_tag;
    using BSplinesTheta = typename DDim::BSplinesTheta_tag;
    using tensor_product_idx_range_type = IdxRange&lt;BSplinesR, BSplinesTheta&gt;;
    using tensor_product_idx_type = Idx&lt;BSplinesR, BSplinesTheta&gt;;
    using IdxR = Idx&lt;BSplinesR&gt;;
    using IdxTheta = Idx&lt;BSplinesTheta&gt;;

    auto r_bspl_space = ddc::discrete_space&lt;BSplinesR&gt;();
    auto theta_bspl_space = ddc::discrete_space&lt;BSplinesTheta&gt;();

    assert(get_idx_range(int_vals.singular_spline_coef).extents() == DDim::n_singular_basis());
    assert(get_idx_range(int_vals.spline_coef).front().template uid&lt;BSplinesR&gt;()
           == DDim::continuity + 1);
    assert(get_idx_range(int_vals.spline_coef).back().template uid&lt;BSplinesR&gt;()
           == r_bspl_space.nbasis() - 1);
    assert(get_idx_range(int_vals.spline_coef).template extent&lt;BSplinesTheta&gt;()
                   == theta_bspl_space.nbasis()
           || get_idx_range(int_vals.spline_coef).template extent&lt;BSplinesTheta&gt;()
                      == theta_bspl_space.size());

    DFieldMem&lt;IdxRange&lt;BSplinesR&gt;, MemorySpace&gt; r_integrals_alloc(
            r_bspl_space.full_domain().take_first(IdxStep&lt;BSplinesR&gt; {r_bspl_space.nbasis()}));
    DFieldMem&lt;IdxRange&lt;BSplinesTheta&gt;, MemorySpace&gt; theta_integrals_alloc(
            theta_bspl_space.full_domain().take_first(
                    IdxStep&lt;BSplinesTheta&gt; {theta_bspl_space.size()}));
    DField&lt;IdxRange&lt;BSplinesR&gt;, MemorySpace&gt; r_integrals = get_field(r_integrals_alloc);
    DField&lt;IdxRange&lt;BSplinesTheta&gt;, MemorySpace&gt; theta_integrals = get_field(theta_integrals_alloc);

    ddc::integrals(execution_space, r_integrals);
    ddc::integrals(execution_space, theta_integrals);

    IdxRange&lt;BSplinesR, BSplinesTheta&gt; singular_2d_idx_range(
            get_idx_range(ddc::discrete_space&lt;DDim&gt;().m_singular_basis_elements));
    DField&lt;IdxRange&lt;DDim&gt;&gt; singular_spline_integrals = get_field(int_vals.singular_spline_coef);

    IdxRange&lt;DDim&gt; singular_idx_range = DDim::template singular_idx_range&lt;DDim&gt;();
    Kokkos::parallel_for(
            Kokkos::TeamPolicy&lt;&gt;(execution_space, singular_idx_range.size(), Kokkos::AUTO),
            KOKKOS_LAMBDA(const Kokkos::TeamPolicy&lt;&gt;::member_type&amp; team) {
                const int idx = team.league_rank();
                Idx&lt;DDim&gt; k(idx);

                // Sum over quadrature dimensions
                double teamSum = 0;
                Kokkos::parallel_reduce(
                        Kokkos::TeamThreadMDRange(
                                team,
                                singular_2d_idx_range.template extent&lt;BSplinesR&gt;().value(),
                                singular_2d_idx_range.template extent&lt;BSplinesTheta&gt;().value()),
                        [&amp;](int r_thread_index, int theta_thread_index, double&amp; sum) {
                            IdxR i(r_thread_index);
                            IdxTheta j(theta_thread_index);
                            sum += ddc::discrete_space&lt;DDim&gt;().m_singular_basis_elements(k, i, j)
                                   * r_integrals(i) * theta_integrals(j);
                        },
                        teamSum);
                singular_spline_integrals(k) = teamSum;
            });


    IdxRange&lt;BSplinesR&gt; r_tensor_product_dom(get_idx_range(int_vals.spline_coef));
    tensor_product_idx_range_type
            tensor_bspline_idx_range(r_tensor_product_dom, get_idx_range(theta_integrals));

    ddc::parallel_for_each(
            execution_space,
            tensor_bspline_idx_range,
            KOKKOS_LAMBDA(tensor_product_idx_type idx) {
                int_vals.spline_coef(idx) = r_integrals(ddc::select&lt;BSplinesR&gt;(idx))
                                            * theta_integrals(ddc::select&lt;BSplinesTheta&gt;(idx));
            });

    if (get_idx_range(int_vals.spline_coef).template extent&lt;BSplinesTheta&gt;()
        == theta_bspl_space.size()) {
        IdxRange&lt;BSplinesTheta&gt; periodic_points(
                get_idx_range(theta_integrals)
                        .take_last(IdxStep&lt;BSplinesTheta&gt; {BSplinesTheta::degree()}));
        tensor_product_idx_range_type repeat_idx_range(r_tensor_product_dom, periodic_points);
        ddc::parallel_fill(execution_space, int_vals.spline_coef[repeat_idx_range], 0.0);
    }
    return int_vals;
}

template &lt;class BSplinesR, class BSplinesTheta, int C&gt;
template &lt;class DDim, class MemorySpace&gt;
template &lt;class MemorySpace2&gt;
void PolarBSplines&lt;BSplinesR, BSplinesTheta, C&gt;::Impl&lt;DDim, MemorySpace&gt;::integrals(
        PolarSpline&lt;DDim, MemorySpace2&gt; int_vals) const
{
    integrals(Kokkos::DefaultHostExecutionSpace(), int_vals);
}
</code></pre></div>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/gyselax/gyselalibxx/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../docs/jscript/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
