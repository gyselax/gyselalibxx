#!/usr/bin/env python3
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed
from itertools import chain
import json
import os
from pathlib import Path
import subprocess
import shutil
import sys

WARNING = 1
ERROR = 2

GYSELALIB_ROOT = Path(__file__).parent.parent

def submit_iwyu_job(iwyu_command, c : dict):
    p = subprocess.run(iwyu_command + c['command'].split(), text = True, capture_output = True, check = False)
    return Path(c['file']), p

if __name__ == '__main__':
    parser = argparse.ArgumentParser("Use cppcheck to look for common coding errors. This script must be run in a root folder.")
    parser.add_argument('toolchain', metavar='TOOLCHAIN', help='The toolchain that you would use to compile the code.')
    parser.add_argument('folders', metavar='FOLDERS', help='The folders in which the code you would like to test is found.',
                        nargs='+', type=Path)
    parser.add_argument('-j', '--jobs', type=int, default=1, help='Number of parallel jobs')
    parser.add_argument('--disable-style', help='Disable the style checks', action='store_true')
    parser.add_argument('--no-clean-up', help='Disable the clean-up of the generated folder.', action='store_true')
    parser.add_argument('--verbose', help='Run cppcheck in verbose mode', action='store_true')

    args = parser.parse_args()

    errors = []

    toolchain = Path(args.toolchain).absolute()

    build_dir = Path('build_iwyu').absolute()
    subprocess.run([shutil.which('cmake'), f'-DCMAKE_TOOLCHAIN_FILE={toolchain}',
               '-DCMAKE_EXPORT_COMPILE_COMMANDS=ON', '-B', build_dir, '.'],
                   check=True)

    with open(build_dir / 'compile_commands.json', encoding='utf-8') as f:
        config = json.load(f)

    relevant_folders = [Path(r).absolute() for r in args.folders]
    exclude_folders = [GYSELALIB_ROOT / 'tests' / 'data_types' / 'static_assert_tests']

    relevant_configs = [c for c in config if any(r in Path(c['file']).parents for r in relevant_folders) \
                                            and not any(r in Path(c['file']).parents for r in exclude_folders)]

    for c in relevant_configs:
        c['command'] = ' '.join(c['command'].split()[1:])

    iwyu_command = [shutil.which('include-what-you-use'),
                    '-Xiwyu', f'--mapping_file={GYSELALIB_ROOT / "bin" / "ci_tools" / "iwyu_config.imp"}',
                    '-Xiwyu', '--transitive_includes_only',
                    '-Xiwyu', '--no_fwd_decls',
                    '-Xiwyu', '--error']

    files_to_check = {f.absolute() for d in args.folders for f in d.glob('**/*.cpp')}.union(f for d in args.folders for f in d.glob('**/*.hpp'))
    files_to_check = {f for f in files_to_check if 'static_assert_tests' not in f.parts}

    cpp_checked_files = {Path(c['file']) for c in relevant_configs}
    hpp_checked_files = {f.with_suffix('.hpp') for f in cpp_checked_files}
    hpp_checked_files = {f for f in hpp_checked_files if f.exists()}

    header_only_files = files_to_check.difference(cpp_checked_files, hpp_checked_files)

    errors += [(f, ERROR, "cpp file does not seem to be compiled by CMake") for f in header_only_files if f.suffix == '.cpp']

    missing_files = set()

    still_to_parse = header_only_files

    changed = True
    while changed and still_to_parse:
        changed = False
        missing_files = set()
        for m in still_to_parse:
            missing = True
            for c in relevant_configs:
                cmd = c.get('ref', c)['command']
                if str(m.parent) in cmd:
                    with open(c['file'], 'r') as f:
                        code = f.read()
                    if m.name in code:
                        cmd = f'-Xiwyu --check_also={m} ' + cmd
                        orig_c = c.get('ref', c)
                        orig_c['command'] = cmd
                        relevant_configs.append({'file': str(m), 'ref': orig_c})
                        missing = False
                        break
            if missing:
                missing_files.add(m)

        changed = still_to_parse != missing_files
        still_to_parse = missing_files

    errors += [(m, WARNING, "File seems to be unused. Compilation is untested") for m in missing_files]

    with ThreadPoolExecutor(max_workers=args.jobs) as executor:
        iwyu_results = [executor.submit(submit_iwyu_job, iwyu_command, c) for c in relevant_configs if 'command' in c]

        total = len(iwyu_results)
        done = 0
        for future in as_completed(iwyu_results):
            done += 1
            percent = done / total * 100
            print(f"\rProgress: {done}/{total} ({percent:.0f}%)", end='', flush=True)
            f, p = future.result()
            if p.returncode != 0:
                errors.append((f, ERROR, p.stderr))
    print()

    errors.sort(key=lambda e:e[0])

    for f, _, m in errors:
        print(f"{f} : {m}")

    if any(e[1] > WARNING for e in errors):
        sys.exit(1)
