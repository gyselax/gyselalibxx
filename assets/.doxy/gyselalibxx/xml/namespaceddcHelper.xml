<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="namespaceddcHelper" kind="namespace" language="C++">
    <compoundname>ddcHelper</compoundname>
    <innerclass refid="structddcHelper_1_1is__non__uniform__interpolation__points" prot="public">ddcHelper::is_non_uniform_interpolation_points</innerclass>
    <innerclass refid="structddcHelper_1_1is__non__uniform__interpolation__points_3_01NonUniformInterpolationPoints_3_047d1c8570873e3c052e2e394afcf9270" prot="public">ddcHelper::is_non_uniform_interpolation_points&lt; NonUniformInterpolationPoints&lt; BSplines, BcXmin, BcXmax &gt; &gt;</innerclass>
    <innerclass refid="classddcHelper_1_1NonUniformInterpolationPoints" prot="public">ddcHelper::NonUniformInterpolationPoints</innerclass>
    <sectiondef kind="typedef">
      <memberdef kind="typedef" id="ddc__helper_8hpp_1aabbf4cbd249da175f1cea2ae2cb61aee" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>template&lt; class Tag &gt; class</type>
            <declname>Templ</declname>
            <defname>Templ</defname>
          </param>
          <param>
            <type>class TypeSeq</type>
          </param>
        </templateparamlist>
        <type>typename detail::ApplyTemplateToTypeSeq&lt; Templ, TypeSeq &gt;::type</type>
        <definition>using ddcHelper::apply_template_to_type_seq_t = typedef typename detail::ApplyTemplateToTypeSeq&lt;Templ, TypeSeq&gt;::type</definition>
        <argsstring></argsstring>
        <name>apply_template_to_type_seq_t</name>
        <qualifiedname>ddcHelper::apply_template_to_type_seq_t</qualifiedname>
        <briefdescription>
<para>A helper to get a type sequence by applying a template to a sequence of type tags. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="322" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="322" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="ddc__helper_8hpp_1aa238a8fb325126a81a31cd8fc6a436cc" prot="public" static="no">
        <templateparamlist>
          <param>
            <type>class TypeSeq1</type>
          </param>
          <param>
            <type>class TypeSeq2</type>
          </param>
        </templateparamlist>
        <type>typename detail::TypeSeqIntersection&lt; TypeSeq1, TypeSeq2, ddc::detail::TypeSeq&lt;&gt; &gt;::type</type>
        <definition>using ddcHelper::type_seq_intersection_t = typedef typename detail::TypeSeqIntersection&lt;TypeSeq1, TypeSeq2, ddc::detail::TypeSeq&lt;&gt; &gt;::type</definition>
        <argsstring></argsstring>
        <name>type_seq_intersection_t</name>
        <qualifiedname>ddcHelper::type_seq_intersection_t</qualifiedname>
        <briefdescription>
<para>A helper to find all types which are found in both TypeSeq1 and TypeSeq2. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="326" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="327" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="var">
      <memberdef kind="variable" id="non__uniform__interpolation__points_8hpp_1a6ba00773b16df1063519790796f9c1dd" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>class <ref refid="structT" kindref="compound">T</ref></type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool ddcHelper::is_non_uniform_interpolation_points_v</definition>
        <argsstring></argsstring>
        <name>is_non_uniform_interpolation_points_v</name>
        <qualifiedname>ddcHelper::is_non_uniform_interpolation_points_v</qualifiedname>
        <initializer>= <ref refid="structddcHelper_1_1is__non__uniform__interpolation__points" kindref="compound">is_non_uniform_interpolation_points</ref>&lt;<ref refid="structT" kindref="compound">T</ref>&gt;::value</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/non_uniform_interpolation_points.hpp" line="30" column="23" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/non_uniform_interpolation_points.hpp" bodystart="31" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="func">
      <memberdef kind="function" id="derivative__field_8hpp_1a9a2d3927b6e69a7dee15d2d617bf6655" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class FieldDst</type>
          </param>
          <param>
            <type>class FieldSrc</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; is_borrowed_deriv_field_v&lt; FieldDst &gt; &amp;&amp;is_borrowed_deriv_field_v&lt; FieldSrc &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto ddcHelper::deepcopy</definition>
        <argsstring>(FieldDst &amp;&amp;dst, FieldSrc &amp;&amp;src)</argsstring>
        <name>deepcopy</name>
        <qualifiedname>ddcHelper::deepcopy</qualifiedname>
        <param>
          <type>FieldDst &amp;&amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>FieldSrc &amp;&amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>Copy the contents of one <ref refid="classDerivField" kindref="compound">DerivField</ref> into another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classDerivField" kindref="compound">DerivField</ref> where the data will be saved. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classDerivField" kindref="compound">DerivField</ref> whose data will be copied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/derivative_field.hpp" line="48" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/derivative_field.hpp" bodystart="48" bodyend="58"/>
      </memberdef>
      <memberdef kind="function" id="derivative__field_8hpp_1ada5630e0ff2c91e9524e0c32aaa8ad77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class FieldDst</type>
          </param>
          <param>
            <type>class FieldSrc</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto ddcHelper::deepcopy</definition>
        <argsstring>(ExecSpace const &amp;execution_space, FieldDst &amp;&amp;dst, FieldSrc &amp;&amp;src)</argsstring>
        <name>deepcopy</name>
        <qualifiedname>ddcHelper::deepcopy</qualifiedname>
        <param>
          <type>ExecSpace const &amp;</type>
          <declname>execution_space</declname>
        </param>
        <param>
          <type>FieldDst &amp;&amp;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>FieldSrc &amp;&amp;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>Copy the contents of one <ref refid="classDerivField" kindref="compound">DerivField</ref> into another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>execution_space</parametername>
</parameternamelist>
<parameterdescription>
<para>The Kokkos execution space where the copy will be carried out. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classDerivField" kindref="compound">DerivField</ref> where the data will be saved. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classDerivField" kindref="compound">DerivField</ref> whose data will be copied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/derivative_field.hpp" line="68" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/derivative_field.hpp" bodystart="68" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="tensor_8hpp_1ad3ef4581d179399169e4128657f9bf76" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>QueryIndexTag</declname>
            <defname>QueryIndexTag</defname>
          </param>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class...</type>
            <declname>ValidIndexSet</declname>
            <defname>ValidIndexSet</defname>
          </param>
        </templateparamlist>
        <type>KOKKOS_INLINE_FUNCTION ElementType &amp;</type>
        <definition>KOKKOS_INLINE_FUNCTION ElementType &amp; ddcHelper::get</definition>
        <argsstring>(Tensor&lt; ElementType, ValidIndexSet... &gt; &amp;tensor)</argsstring>
        <name>get</name>
        <qualifiedname>ddcHelper::get</qualifiedname>
        <param>
          <type><ref refid="classTensor" kindref="compound">Tensor</ref>&lt; ElementType, ValidIndexSet... &gt; &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
<para>A helper function to get a modifiable reference to an element of the tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>QueryIndexTag</parametername>
</parameternamelist>
<parameterdescription>
<para>A type describing the relevant index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>The tensor whose elements are examined. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The relevant element of the tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" line="399" column="36" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" bodystart="399" bodyend="404"/>
      </memberdef>
      <memberdef kind="function" id="tensor_8hpp_1adcacf7bf8173bf14f4591918285aa2f0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class...</type>
            <declname>QueryIndexTag</declname>
            <defname>QueryIndexTag</defname>
          </param>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class...</type>
            <declname>ValidIndexSet</declname>
            <defname>ValidIndexSet</defname>
          </param>
        </templateparamlist>
        <type>KOKKOS_INLINE_FUNCTION ElementType const &amp;</type>
        <definition>KOKKOS_INLINE_FUNCTION ElementType const  &amp; ddcHelper::get</definition>
        <argsstring>(Tensor&lt; ElementType, ValidIndexSet... &gt; const &amp;tensor)</argsstring>
        <name>get</name>
        <qualifiedname>ddcHelper::get</qualifiedname>
        <param>
          <type><ref refid="classTensor" kindref="compound">Tensor</ref>&lt; ElementType, ValidIndexSet... &gt; const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
<para>A helper function to get an element of the tensor. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>QueryIndexTag</parametername>
</parameternamelist>
<parameterdescription>
<para>A type describing the relevant index. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>The tensor whose elements are examined. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The relevant element of the tensor. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" line="413" column="42" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" bodystart="413" bodyend="418"/>
      </memberdef>
      <memberdef kind="function" id="tensor_8hpp_1af2697d1baeaea2e5fe1bcc8311767029" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Dims</declname>
            <defname>Dims</defname>
          </param>
        </templateparamlist>
        <type>KOKKOS_INLINE_FUNCTION Coord&lt; Dims... &gt;</type>
        <definition>KOKKOS_INLINE_FUNCTION Coord&lt; Dims... &gt; ddcHelper::to_coord</definition>
        <argsstring>(Vector&lt; ElementType, Dims... &gt; const &amp;tensor)</argsstring>
        <name>to_coord</name>
        <qualifiedname>ddcHelper::to_coord</qualifiedname>
        <param>
          <type><ref refid="classTensor" kindref="compound">Vector</ref>&lt; ElementType, Dims... &gt; const &amp;</type>
          <declname>tensor</declname>
        </param>
        <briefdescription>
<para>A helper function to convert a vector to a coordinate. This is useful in order to add a Vector to a coordinate to obtain a new coordinate (e.g. when calculating the foot of a characteristic. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tensor</parametername>
</parameternamelist>
<parameterdescription>
<para>The tensor to be converted. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The new coordinate. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" line="428" column="30" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/tensor.hpp" bodystart="428" bodyend="431"/>
      </memberdef>
      <memberdef kind="function" id="vector__field_8hpp_1aa57ad767fdb365aaa4bf5b7e8929c576" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class IdxRangeType</type>
          </param>
          <param>
            <type>class...</type>
            <declname>Dims</declname>
            <defname>Dims</defname>
          </param>
          <param>
            <type>class MemorySpace</type>
          </param>
          <param>
            <type>class LayoutStridedPolicy</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto ddcHelper::create_mirror_view_and_copy</definition>
        <argsstring>(ExecSpace exec_space, VectorField&lt; ElementType, IdxRangeType, VectorIndexSet&lt; Dims... &gt;, MemorySpace, LayoutStridedPolicy &gt; field)</argsstring>
        <name>create_mirror_view_and_copy</name>
        <qualifiedname>ddcHelper::create_mirror_view_and_copy</qualifiedname>
        <param>
          <type>ExecSpace</type>
          <declname>exec_space</declname>
        </param>
        <param>
          <type><ref refid="classVectorField" kindref="compound">VectorField</ref>&lt; ElementType, IdxRangeType, VectorIndexSet&lt; Dims... &gt;, MemorySpace, LayoutStridedPolicy &gt;</type>
          <declname>field</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field.hpp" line="483" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field.hpp" bodystart="483" bodyend="505"/>
      </memberdef>
      <memberdef kind="function" id="vector__field__common_8hpp_1a6e1d8ae4a15bc95c69ac104c288af30a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class QueryTag</type>
          </param>
          <param>
            <type>class VectorFieldType</type>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto ddcHelper::get</definition>
        <argsstring>(VectorFieldType const &amp;field) noexcept</argsstring>
        <name>get</name>
        <qualifiedname>ddcHelper::get</qualifiedname>
        <param>
          <type>VectorFieldType const &amp;</type>
          <declname>field</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field_common.hpp" line="48" column="23" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field_common.hpp" bodystart="48" bodyend="52"/>
      </memberdef>
      <memberdef kind="function" id="vector__field__common_8hpp_1abef007443ceadfa034348735ab4bbdf3" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class QueryTag</type>
          </param>
          <param>
            <type>class VectorFieldType</type>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto ddcHelper::get</definition>
        <argsstring>(VectorFieldType &amp;field) noexcept</argsstring>
        <name>get</name>
        <qualifiedname>ddcHelper::get</qualifiedname>
        <param>
          <type>VectorFieldType &amp;</type>
          <declname>field</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field_common.hpp" line="55" column="23" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/vector_field_common.hpp" bodystart="55" bodyend="59"/>
      </memberdef>
      <memberdef kind="function" id="multipatch__field_8hpp_1a1c7e7fe53e09d748ce27fe0421a2ef34" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename P &gt; typename</type>
            <declname>T1</declname>
            <defname>T1</defname>
          </param>
          <param>
            <type>template&lt; typename P &gt; typename</type>
            <declname>T2</declname>
            <defname>T2</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>Patches</declname>
            <defname>Patches</defname>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void ddcHelper::deepcopy</definition>
        <argsstring>(MultipatchField&lt; T1, Patches... &gt; dst, MultipatchField&lt; T2, Patches... &gt; src)</argsstring>
        <name>deepcopy</name>
        <qualifiedname>ddcHelper::deepcopy</qualifiedname>
        <param>
          <type><ref refid="classMultipatchField" kindref="compound">MultipatchField</ref>&lt; T1, Patches... &gt;</type>
          <declname>dst</declname>
        </param>
        <param>
          <type><ref refid="classMultipatchField" kindref="compound">MultipatchField</ref>&lt; T2, Patches... &gt;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>Copy the data from one <ref refid="classMultipatchField" kindref="compound">MultipatchField</ref> into another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classMultipatchField" kindref="compound">MultipatchField</ref> that the data will be copied to. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>The <ref refid="classMultipatchField" kindref="compound">MultipatchField</ref> that the data will be copied from. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_field.hpp" line="230" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_field.hpp" bodystart="230" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1ab85a32309a76aeb021f849ea7bfd2773" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class IDim</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt;!IDim::continuous_dimension_type::PERIODIC, double &gt;</type>
        <definition>constexpr std::enable_if_t&lt;!IDim::continuous_dimension_type::PERIODIC, double &gt; ddcHelper::total_interval_length</definition>
        <argsstring>(IdxRange&lt; IDim &gt; const &amp;idx_range)</argsstring>
        <name>total_interval_length</name>
        <qualifiedname>ddcHelper::total_interval_length</qualifiedname>
        <param>
          <type>IdxRange&lt; IDim &gt; const &amp;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate the total length of a non-periodic domain.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain on which the length should be calculated.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The length of the domain. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="25" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="25" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1a4d5446b992979ca3b2382c0277626048" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class IDim</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC &amp;&amp;ddc::is_uniform_point_sampling_v&lt; IDim &gt;, double &gt;</type>
        <definition>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC &amp;&amp;ddc::is_uniform_point_sampling_v&lt; IDim &gt;, double &gt; ddcHelper::total_interval_length</definition>
        <argsstring>(IdxRange&lt; IDim &gt; const &amp;idx_range)</argsstring>
        <name>total_interval_length</name>
        <qualifiedname>ddcHelper::total_interval_length</qualifiedname>
        <param>
          <type>IdxRange&lt; IDim &gt; const &amp;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate the total length of a uniform periodic domain.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain on which the length should be calculated.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The length of the domain. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="43" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="43" bodyend="46"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1a342954bb0c44d8d86ceadb9d9fbea79c" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class IDim</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC &amp;&amp;ddc::is_non_uniform_point_sampling_v&lt; IDim &gt;, double &gt;</type>
        <definition>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC &amp;&amp;ddc::is_non_uniform_point_sampling_v&lt; IDim &gt;, double &gt; ddcHelper::total_interval_length</definition>
        <argsstring>(IdxRange&lt; IDim &gt; const &amp;idx_range)</argsstring>
        <name>total_interval_length</name>
        <qualifiedname>ddcHelper::total_interval_length</qualifiedname>
        <param>
          <type>IdxRange&lt; IDim &gt; const &amp;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Calculate the total length of a non-uniform periodic domain.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain on which the length should be calculated.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The length of the domain. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="61" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="61" bodyend="65"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1aa3a54caed10dca08ea894953cd66a5f2" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class IDim</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC, Coord&lt; typename IDim::continuous_dimension_type &gt; &gt;</type>
        <definition>constexpr std::enable_if_t&lt; IDim::continuous_dimension_type::PERIODIC, Coord&lt; typename IDim::continuous_dimension_type &gt; &gt; ddcHelper::restrict_to_idx_range</definition>
        <argsstring>(Coord&lt; typename IDim::continuous_dimension_type &gt; coord, IdxRange&lt; IDim &gt; const &amp;idx_range)</argsstring>
        <name>restrict_to_idx_range</name>
        <qualifiedname>ddcHelper::restrict_to_idx_range</qualifiedname>
        <param>
          <type>Coord&lt; typename IDim::continuous_dimension_type &gt;</type>
          <declname>coord</declname>
        </param>
        <param>
          <type>IdxRange&lt; IDim &gt; const &amp;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
<para>Calculate the Coordinate inside the domain. </para>
        </briefdescription>
        <detaileddescription>
<para>In the case of a periodic domain, a Coordinate can sometimes be found outside the domain. In this case it is useful to be able to find the equivalent coordinate inside the domain. This function makes that possible.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">coord</parametername>
</parameternamelist>
<parameterdescription>
<para>The 1D coordinate we want to compute inside the domain. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain where the coordinate is defined.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The equivalent coordinate inside the domain. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="88" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="88" bodyend="112"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1ae8ba6761a82dae62be403afdfe82b46b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class BSpline</type>
          </param>
        </templateparamlist>
        <type>KOKKOS_INLINE_FUNCTION void</type>
        <definition>KOKKOS_INLINE_FUNCTION void ddcHelper::restrict_to_bspline_domain</definition>
        <argsstring>(Coord&lt; typename BSpline::continuous_dimension_type &gt; &amp;coord)</argsstring>
        <name>restrict_to_bspline_domain</name>
        <qualifiedname>ddcHelper::restrict_to_bspline_domain</qualifiedname>
        <param>
          <type>Coord&lt; typename BSpline::continuous_dimension_type &gt; &amp;</type>
          <declname>coord</declname>
        </param>
        <briefdescription>
<para>Calculate the Coordinate inside the domain. </para>
        </briefdescription>
        <detaileddescription>
<para>In the case of a periodic domain, a Coordinate can sometimes be found outside the domain. In this case it is useful to be able to find the equivalent coordinate inside the domain. This function makes that possible.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">coord</parametername>
</parameternamelist>
<parameterdescription>
<para>The 1D coordinate we want to compute inside the domain.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The equivalent coordinate inside the domain. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="128" column="29" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="128" bodyend="140"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1afc83fef0fd54c18053bb973ee156fa49" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class Grid1D</type>
          </param>
          <param>
            <type>class Layout</type>
          </param>
          <param>
            <type>class MemorySpace</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void ddcHelper::dump_coordinates</definition>
        <argsstring>(ExecSpace exec_space, DField&lt; IdxRange&lt; Grid1D &gt;, Layout, MemorySpace &gt; dump_coord)</argsstring>
        <name>dump_coordinates</name>
        <qualifiedname>ddcHelper::dump_coordinates</qualifiedname>
        <param>
          <type>ExecSpace</type>
          <declname>exec_space</declname>
        </param>
        <param>
          <type>DField&lt; IdxRange&lt; Grid1D &gt;, Layout, MemorySpace &gt;</type>
          <declname>dump_coord</declname>
        </param>
        <briefdescription>
<para>Dump the coordinates of a field into the field. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">exec_space</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution space on which the code will run. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">dump_coord</parametername>
</parameternamelist>
<parameterdescription>
<para>The field which will contain the coordinates. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="149" column="13" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="149" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1a3b54b16fd66648bf6dd0376da991f596" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class Grid1D</type>
          </param>
          <param>
            <type>class Layout</type>
          </param>
          <param>
            <type>class MemorySpace</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void ddcHelper::dump_coordinates</definition>
        <argsstring>(ExecSpace exec_space, Field&lt; Coord&lt; typename Grid1D::continuous_dimension_type &gt;, IdxRange&lt; Grid1D &gt;, Layout, MemorySpace &gt; dump_coord)</argsstring>
        <name>dump_coordinates</name>
        <qualifiedname>ddcHelper::dump_coordinates</qualifiedname>
        <param>
          <type>ExecSpace</type>
          <declname>exec_space</declname>
        </param>
        <param>
          <type>Field&lt; Coord&lt; typename Grid1D::continuous_dimension_type &gt;, IdxRange&lt; Grid1D &gt;, Layout, MemorySpace &gt;</type>
          <declname>dump_coord</declname>
        </param>
        <briefdescription>
<para>Dump the coordinates of a field into the field. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">exec_space</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution space on which the code will run. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">dump_coord</parametername>
</parameternamelist>
<parameterdescription>
<para>The field which will contain the coordinates. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="166" column="13" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="166" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="ddc__helper_8hpp_1a9e2ce2d2ae35d41cf6d260b465560976" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class GridDim</type>
          </param>
        </templateparamlist>
        <type>double</type>
        <definition>double ddcHelper::maximum_distance_between_adjacent_points</definition>
        <argsstring>(IdxRange&lt; GridDim &gt; const &amp;idx_range)</argsstring>
        <name>maximum_distance_between_adjacent_points</name>
        <qualifiedname>ddcHelper::maximum_distance_between_adjacent_points</qualifiedname>
        <param>
          <type>IdxRange&lt; GridDim &gt; const &amp;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
<para>Computes the maximum distance between two adjacent points within an IdxRange. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The domain on which the distance should be calculated.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The maximum distance between two adjacent points. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" line="188" column="8" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/ddc_helper.hpp" bodystart="188" bodyend="206"/>
      </memberdef>
      <memberdef kind="function" id="transpose_8hpp_1a427b2ef16466ccf26ea2f81563bbedb4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class TargetDomain</type>
          </param>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class Domain</type>
          </param>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class MemSpace</type>
          </param>
          <param>
            <type>class FieldLayoutType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto ddcHelper::create_transpose_mirror_view_and_copy</definition>
        <argsstring>(ExecSpace const &amp;execution_space, Field&lt; ElementType, Domain, MemSpace, FieldLayoutType &gt; src)</argsstring>
        <name>create_transpose_mirror_view_and_copy</name>
        <qualifiedname>ddcHelper::create_transpose_mirror_view_and_copy</qualifiedname>
        <param>
          <type>ExecSpace const &amp;</type>
          <declname>execution_space</declname>
        </param>
        <param>
          <type>Field&lt; ElementType, Domain, MemSpace, FieldLayoutType &gt;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>If necessary transpose data into the requested dimension ordering. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">execution_space</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution space (Host/Device) where the code will run. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to be transposed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>If src is already in the correct dimension ordering, return a view on src. Otherwise return a chunk with the correct dimension ordering in which the data from src has been copied. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/transpose.hpp" line="103" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/transpose.hpp" bodystart="103" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="transpose_8hpp_1a46df5800c3318a0b386395442dce6ba8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class TargetDomain</type>
          </param>
          <param>
            <type>class ElementType</type>
          </param>
          <param>
            <type>class Domain</type>
          </param>
          <param>
            <type>class ExecSpace</type>
          </param>
          <param>
            <type>class MemSpace</type>
          </param>
          <param>
            <type>class FieldLayoutType</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto ddcHelper::create_transpose_mirror</definition>
        <argsstring>(ExecSpace const &amp;execution_space, Field&lt; ElementType, Domain, MemSpace, FieldLayoutType &gt; src)</argsstring>
        <name>create_transpose_mirror</name>
        <qualifiedname>ddcHelper::create_transpose_mirror</qualifiedname>
        <param>
          <type>ExecSpace const &amp;</type>
          <declname>execution_space</declname>
        </param>
        <param>
          <type>Field&lt; ElementType, Domain, MemSpace, FieldLayoutType &gt;</type>
          <declname>src</declname>
        </param>
        <briefdescription>
<para>Create a data object in the requested dimension ordering using as allocations as possible. This function does not copy data. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">execution_space</parametername>
</parameternamelist>
<parameterdescription>
<para>The execution space (Host/Device) where the code will run. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">src</parametername>
</parameternamelist>
<parameterdescription>
<para>The object to be transposed.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>If src is already in the correct dimension ordering, return a view on src. Otherwise return a chunk with the correct dimension ordering. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/transpose.hpp" line="137" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/utils/transpose.hpp" bodystart="137" bodyend="151"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/data_types/derivative_field.hpp" line="34" column="1"/>
  </compounddef>
</doxygen>
