<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="input_8hpp" kind="file" language="C++">
    <compoundname>input.hpp</compoundname>
    <includes local="no">sstream</includes>
    <includes local="no">ddc/ddc.hpp</includes>
    <includes local="no">paraconf.h</includes>
    <includes local="no">pdi.h</includes>
    <includes refid="ddc__aliases_8hpp" local="yes">ddc_aliases.hpp</includes>
    <includes refid="mesh__builder_8hpp" local="yes">mesh_builder.hpp</includes>
    <includes refid="non__uniform__interpolation__points_8hpp" local="yes">non_uniform_interpolation_points.hpp</includes>
    <includes refid="paraconfpp_8hpp" local="yes">paraconfpp.hpp</includes>
    <includes refid="pdi__helper_8hpp" local="yes">pdi_helper.hpp</includes>
    <includedby refid="input_8cpp" local="yes">/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.cpp</includedby>
    <incdepgraph>
      <node id="1">
        <label>/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp</label>
        <link refid="input_8hpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
      </node>
      <node id="20">
        <label>pdi_helper.hpp</label>
        <link refid="pdi__helper_8hpp_source"/>
        <childnode refid="5" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>paraconfpp.hpp</label>
        <link refid="paraconfpp_8hpp_source"/>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
      </node>
      <node id="6">
        <label>ddc_aliases.hpp</label>
        <link refid="ddc__aliases_8hpp_source"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="8">
        <label>mesh_builder.hpp</label>
        <link refid="mesh__builder_8hpp_source"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="12">
        <label>non_uniform_interpolation_points.hpp</label>
        <link refid="non__uniform__interpolation__points_8hpp_source"/>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>cassert</label>
      </node>
      <node id="14">
        <label>cmath</label>
      </node>
      <node id="9">
        <label>cstdlib</label>
      </node>
      <node id="10">
        <label>ctime</label>
      </node>
      <node id="3">
        <label>ddc/ddc.hpp</label>
      </node>
      <node id="7">
        <label>ddc/kernels/splines.hpp</label>
      </node>
      <node id="16">
        <label>filesystem</label>
      </node>
      <node id="4">
        <label>paraconf.h</label>
      </node>
      <node id="5">
        <label>pdi.h</label>
      </node>
      <node id="2">
        <label>sstream</label>
      </node>
      <node id="17">
        <label>stdexcept</label>
      </node>
      <node id="18">
        <label>string</label>
      </node>
      <node id="19">
        <label>utility</label>
      </node>
      <node id="11">
        <label>vector</label>
      </node>
    </incdepgraph>
    <sectiondef kind="func">
      <memberdef kind="function" id="input_8hpp_1a786e15d5483370d99f7bef2ce8321b58" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void parse_executable_arguments</definition>
        <argsstring>(PC_tree_t &amp;conf_gyselalibxx, long int &amp;iter_start, int argc, char **argv, char const *const params_yaml)</argsstring>
        <name>parse_executable_arguments</name>
        <param>
          <type>PC_tree_t &amp;</type>
          <declname>conf_gyselalibxx</declname>
        </param>
        <param>
          <type>long int &amp;</type>
          <declname>iter_start</declname>
        </param>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>char const *const</type>
          <declname>params_yaml</declname>
        </param>
        <briefdescription>
<para>Extract the paraconf configuration and the restart iteration from the executable arguments. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="out">conf_gyselalibxx</parametername>
</parameternamelist>
<parameterdescription>
<para>The paraconf configuration describing the simulation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="out">iter_start</parametername>
</parameternamelist>
<parameterdescription>
<para>The index of the iteration from which the simulation should restart. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argc</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of arguments passed to the executable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argv</parametername>
</parameternamelist>
<parameterdescription>
<para>The arguments passed to the executable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">params_yaml</parametername>
</parameternamelist>
<parameterdescription>
<para>The default parameters for the yaml file. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" line="25" column="6" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.cpp" bodystart="13" bodyend="41" declfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" declline="25" declcolumn="6"/>
      </memberdef>
      <memberdef kind="function" id="input_8hpp_1ad0798c73945ba76a41854a6e4de7584f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>PC_tree_t</type>
        <definition>PC_tree_t parse_executable_arguments</definition>
        <argsstring>(int argc, char **argv, char const *const params_yaml)</argsstring>
        <name>parse_executable_arguments</name>
        <param>
          <type>int</type>
          <declname>argc</declname>
        </param>
        <param>
          <type>char **</type>
          <declname>argv</declname>
        </param>
        <param>
          <type>char const *const</type>
          <declname>params_yaml</declname>
        </param>
        <briefdescription>
<para>Extract the paraconf configuration from the executable arguments. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">argc</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of arguments passed to the executable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">argv</parametername>
</parameternamelist>
<parameterdescription>
<para>The arguments passed to the executable. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">params_yaml</parametername>
</parameternamelist>
<parameterdescription>
<para>The default parameters for the yaml file.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The paraconf configuration describing the simulation. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" line="41" column="11" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.cpp" bodystart="43" bodyend="58" declfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" declline="41" declcolumn="11"/>
      </memberdef>
      <memberdef kind="function" id="input_8hpp_1a6537533138425084d826e0ecd867fa8e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Grid1D</type>
          </param>
          <param>
            <type>class BSplines</type>
          </param>
          <param>
            <type>class InterpPointInitMethod</type>
          </param>
        </templateparamlist>
        <type>IdxRange&lt; Grid1D &gt;</type>
        <definition>IdxRange&lt; Grid1D &gt; init_spline_dependent_idx_range</definition>
        <argsstring>(PC_tree_t const &amp;conf_gyselalibxx, std::string const &amp;mesh_identifier)</argsstring>
        <name>init_spline_dependent_idx_range</name>
        <param>
          <type>PC_tree_t const &amp;</type>
          <declname>conf_gyselalibxx</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>mesh_identifier</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialise an index range which will serve as an interpolation index range for splines.</para>
<para>The index range is initialised using information from an input yaml file. If the B-splines are uniform then the information to be read is:<itemizedlist>
<listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_min</para>
</listitem><listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_max</para>
</listitem><listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_ncells</para>
</listitem></itemizedlist>
</para>
<para>If the B-splines are non-uniform then the information to be read is:<itemizedlist>
<listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_MeshFile</para>
</listitem></itemizedlist>
</para>
<para>This string indicates the name of a file which contains the knots of the bspline.</para>
<para>This information is used to initialise the B-splines. The interpolation index range is then created using the specified method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" line="62" column="17" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" bodystart="62" bodyend="110"/>
      </memberdef>
      <memberdef kind="function" id="input_8hpp_1a094a1d67fd8cad3b6b67c1c2f447b15c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class Grid1D</type>
          </param>
          <param>
            <type>class BSplines</type>
          </param>
          <param>
            <type>class InterpPointInitMethod</type>
          </param>
        </templateparamlist>
        <type>IdxRange&lt; Grid1D &gt;</type>
        <definition>IdxRange&lt; Grid1D &gt; init_pseudo_uniform_spline_dependent_idx_range</definition>
        <argsstring>(PC_tree_t const &amp;conf_gyselalibxx, std::string const &amp;mesh_identifier)</argsstring>
        <name>init_pseudo_uniform_spline_dependent_idx_range</name>
        <param>
          <type>PC_tree_t const &amp;</type>
          <declname>conf_gyselalibxx</declname>
        </param>
        <param>
          <type>std::string const &amp;</type>
          <declname>mesh_identifier</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Initialise an index range which will serve as an interpolation index range for splines.</para>
<para>The index range is initialised using information from an input yaml file. This function should be used for non-uniform B-splines, but it initialises the break points uniformly. Such splines are referred to as pseudo-uniform as the cells on which the polynomials are defined are uniform. However they are not strictly uniform as multiple knots will be found at the same position at the boundary.</para>
<para>The information to be read from the file is:<itemizedlist>
<listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_min</para>
</listitem><listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_max</para>
</listitem><listitem><para>.SplineMesh.&lt;mesh_identifier&gt;_ncells</para>
</listitem></itemizedlist>
</para>
<para>The interpolation index range is then created using the specified method. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" line="130" column="17" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp" bodystart="130" bodyend="149"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="comment">//<sp/>SPDX-License-Identifier:<sp/>MIT</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#pragma<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sstream&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;ddc/ddc.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;paraconf.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;pdi.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;ddc_aliases.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;mesh_builder.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;non_uniform_interpolation_points.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;paraconfpp.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;pdi_helper.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>parse_executable_arguments(</highlight></codeline>
<codeline lineno="26"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PC_tree_t&amp;<sp/>conf_gyselalibxx,</highlight></codeline>
<codeline lineno="27"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&amp;<sp/>iter_start,</highlight></codeline>
<codeline lineno="28"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,</highlight></codeline>
<codeline lineno="29"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv,</highlight></codeline>
<codeline lineno="30"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>params_yaml);</highlight></codeline>
<codeline lineno="31"><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal">PC_tree_t<sp/>parse_executable_arguments(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>argc,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal">**<sp/>argv,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>params_yaml);</highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Gr</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">1D,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>BSplines,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>InterpPo</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">InitMethod&gt;</highlight></codeline>
<codeline lineno="62"><highlight class="normal"></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>IdxRange&lt;Grid1D&gt;<sp/>init_spline_dependent_idx_range(</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PC_tree_t<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>conf_gyselalibxx,</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>mesh_identifier)</highlight></codeline>
<codeline lineno="65"><highlight class="normal">{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dim<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Grid1D::continuous_dimension_type;</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Coord1D<sp/>=<sp/>ddc::Coordinate&lt;Dim&gt;;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"></highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Coord1D&gt;<sp/>breakpoints;</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(BSplines::is_uniform())<sp/>{</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>uniform<sp/>BSplines<sp/>are<sp/>used<sp/>and<sp/>interpolation<sp/>points<sp/>are<sp/>calculated<sp/>from<sp/>them</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coord1D<sp/>min(PCpp_double(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_min&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Coord1D<sp/>max(PCpp_double(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_max&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IdxStep&lt;Grid1D&gt;<sp/>ncells(</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PCpp_int(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_ncells&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;BSplines&gt;(min,<sp/>max,<sp/>ncells);</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(!ddcHelper::is_non_uniform_interpolation_points_v&lt;InterpPointInitMethod&gt;)<sp/>{</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PDI_get_arrays(</highlight><highlight class="stringliteral">&quot;read_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier,<sp/></highlight><highlight class="stringliteral">&quot;breakpoints_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier,<sp/>breakpoints);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;BSplines&gt;(breakpoints);</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="82"><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(ddcHelper::is_non_uniform_interpolation_points_v&lt;InterpPointInitMethod&gt;)<sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>If<sp/>uniform<sp/>BSplines<sp/>are<sp/>used<sp/>but<sp/>the<sp/>interpolation<sp/>points<sp/>are<sp/>provided<sp/>by<sp/>the<sp/>user</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>This<sp/>may<sp/>be<sp/>the<sp/>case<sp/>if<sp/>you<sp/>want<sp/>to<sp/>test<sp/>a<sp/>new<sp/>choice<sp/>of<sp/>interpolation<sp/>points<sp/>or</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>you<sp/>want<sp/>to<sp/>ensure<sp/>that<sp/>the<sp/>interpolation<sp/>points<sp/>used<sp/>match<sp/>exactly<sp/>the<sp/>points</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>used<sp/>to<sp/>initialise<sp/>values<sp/>passed<sp/>into<sp/>the<sp/>simulation.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;Coord1D&gt;<sp/>mesh;</highlight></codeline>
<codeline lineno="89"><highlight class="normal"></highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">constexpr</highlight><highlight class="normal"><sp/>(BSplines::is_uniform())<sp/>{</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/>grid_name<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;grid_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier;</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PDI_get_arrays(</highlight><highlight class="stringliteral">&quot;read_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier,<sp/>grid_name,<sp/>mesh);</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/>breakpoints_name<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;breakpoints_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier;</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PDI_get_arrays(</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;read_&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier,</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>breakpoints_name,</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>breakpoints,</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mesh_identifier,</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mesh);</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;BSplines&gt;(breakpoints);</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;Grid1D&gt;(</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>InterpPointInitMethod::template<sp/>get_sampling&lt;Grid1D&gt;(mesh));</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;Grid1D&gt;(InterpPointInitMethod::template<sp/>get_sampling&lt;Grid1D&gt;());</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>IdxRange&lt;Grid1D&gt;<sp/>interpolation_idx_range(InterpPointInitMethod::template<sp/>get_domain&lt;Grid1D&gt;());</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>interpolation_idx_range;</highlight></codeline>
<codeline lineno="110"><highlight class="normal">}</highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>Gr</highlight><highlight class="keywordtype">id</highlight><highlight class="normal">1D,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>BSplines,<sp/></highlight><highlight class="keyword">class</highlight><highlight class="normal"><sp/>InterpPo</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">InitMethod&gt;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"></highlight><highlight class="keyword">inline</highlight><highlight class="normal"><sp/>IdxRange&lt;Grid1D&gt;<sp/>init_pseudo_uniform_spline_dependent_idx_range(</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PC_tree_t<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>conf_gyselalibxx,</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">&amp;<sp/>mesh_identifier)</highlight></codeline>
<codeline lineno="133"><highlight class="normal">{</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static_assert</highlight><highlight class="normal">(!BSplines::is_uniform());</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Dim<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Grid1D::continuous_dimension_type;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">using<sp/></highlight><highlight class="normal">Coord1D<sp/>=<sp/>Coord&lt;Dim&gt;;</highlight></codeline>
<codeline lineno="137"><highlight class="normal"></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/>Coord1D<sp/>min(PCpp_double(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_min&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/>Coord1D<sp/>max(PCpp_double(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_max&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/>IdxStep&lt;Grid1D&gt;<sp/>ncells(</highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>PCpp_int(conf_gyselalibxx,<sp/></highlight><highlight class="stringliteral">&quot;.SplineMesh.&quot;</highlight><highlight class="normal"><sp/>+<sp/>mesh_identifier<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;_ncells&quot;</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="142"><highlight class="normal"></highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;Coord1D&gt;<sp/>break_points<sp/>=<sp/>build_uniform_break_points(min,<sp/>max,<sp/>ncells);</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;BSplines&gt;(break_points);</highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/>ddc::init_discrete_space&lt;Grid1D&gt;(InterpPointInitMethod::template<sp/>get_sampling&lt;Grid1D&gt;());</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/>IdxRange&lt;Grid1D&gt;<sp/>interpolation_idx_range(InterpPointInitMethod::template<sp/>get_domain&lt;Grid1D&gt;());</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>interpolation_idx_range;</highlight></codeline>
<codeline lineno="149"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/io/input.hpp"/>
  </compounddef>
</doxygen>
