<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classIPreallocatableInterpolator" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>IPreallocatableInterpolator</compoundname>
    <basecompoundref refid="classIInterpolator" prot="public" virt="non-virtual">IInterpolator&lt; GridInterp, Grid1D... &gt;</basecompoundref>
    <includes refid="iinterpolator_8hpp" local="no">iinterpolator.hpp</includes>
    <templateparamlist>
      <param>
        <type>class GridInterp</type>
      </param>
      <param>
        <type>class...</type>
        <declname>Grid1D</declname>
        <defname>Grid1D</defname>
      </param>
    </templateparamlist>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classIPreallocatableInterpolator_1a1cc1863346091416a12a0e3ef210748a" prot="public" static="no">
        <type>typename <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>&lt; GridInterp, Grid1D... &gt;::deriv_type</type>
        <definition>using IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::deriv_type =  typename IInterpolator&lt;GridInterp, Grid1D...&gt;::deriv_type</definition>
        <argsstring></argsstring>
        <name>deriv_type</name>
        <qualifiedname>IPreallocatableInterpolator::deriv_type</qualifiedname>
        <briefdescription>
<para>The type of the dimension representing derivatives. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="139" column="5" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="139" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" prot="public" static="no">
        <type>typename <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>&lt; GridInterp, Grid1D... &gt;::batched_derivs_idx_range_type</type>
        <definition>using IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::batched_derivs_idx_range_type =  typename IInterpolator&lt;GridInterp, Grid1D...&gt;::batched_derivs_idx_range_type</definition>
        <argsstring></argsstring>
        <name>batched_derivs_idx_range_type</name>
        <qualifiedname>IPreallocatableInterpolator::batched_derivs_idx_range_type</qualifiedname>
        <briefdescription>
<para>The type of the whole index range on which derivatives are defined. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="141" column="5" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="142" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classIPreallocatableInterpolator_1a938ecc601db6305c1cfc0290abb2f445" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::~IPreallocatableInterpolator</definition>
        <argsstring>() override=default</argsstring>
        <name>~IPreallocatableInterpolator</name>
        <qualifiedname>IPreallocatableInterpolator::~IPreallocatableInterpolator</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="136" column="5"/>
      </memberdef>
      <memberdef kind="function" id="classIPreallocatableInterpolator_1a20012bae921142b3c686f6a4a615e23a" prot="public" static="no" const="yes" explicit="no" inline="no" virt="pure-virtual">
        <type>std::unique_ptr&lt; <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>&lt; GridInterp, Grid1D... &gt; &gt;</type>
        <definition>virtual std::unique_ptr&lt; IInterpolator&lt; GridInterp, Grid1D... &gt; &gt; IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::preallocate</definition>
        <argsstring>() const =0</argsstring>
        <name>preallocate</name>
        <qualifiedname>IPreallocatableInterpolator::preallocate</qualifiedname>
        <reimplementedby refid="classPreallocatableLagrangeInterpolator_1ae427633c86b7699ce59d9db59bbf50ae">preallocate</reimplementedby>
        <reimplementedby refid="classPreallocatableSplineInterpolator_1a0f8c7088fc3a65ef39e2710549dee3b0">preallocate</reimplementedby>
        <briefdescription>
<para>Allocate an instance of an InterpolatorProxy to use as an <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para>Allocate and return an unique pointer to an instance of an <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>.</para>
<para><simplesect kind="return"><para>An allocated instance of an InterpolatorProxy.</para>
</simplesect>
<simplesect kind="see"><para>InterpolatorProxy </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classIInterpolator" kindref="compound">IInterpolator</ref> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="154" column="29"/>
      </memberdef>
      <memberdef kind="function" id="classIPreallocatableInterpolator_1a737773f79bd66f394f19a6b7d8045b52" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" kindref="member">batched_derivs_idx_range_type</ref></type>
        <definition>batched_derivs_idx_range_type IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::batched_derivs_idx_range_xmin</definition>
        <argsstring>(IdxRange&lt; Grid1D... &gt; idx_range) const override</argsstring>
        <name>batched_derivs_idx_range_xmin</name>
        <qualifiedname>IPreallocatableInterpolator::batched_derivs_idx_range_xmin</qualifiedname>
        <reimplements refid="classIInterpolator_1af664c9db9a794fb1f199ff31f8673bf8">batched_derivs_idx_range_xmin</reimplements>
        <param>
          <type>IdxRange&lt; Grid1D... &gt;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
<para>Get the batched derivs index range on lower boundaries. </para>
        </briefdescription>
        <detaileddescription>
<para>Dimension of interest IDimI is replaced with ddc::Deriv&lt;IDimI::continuous_dimensions_type&gt;. This is the index range on which derivatives on lower boundaries are defined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The index range of a single-species distribution function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>idx_range The lower boundaries of this index range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="165" column="35" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="165" bodyend="169"/>
      </memberdef>
      <memberdef kind="function" id="classIPreallocatableInterpolator_1aa5f6e697f47d2e64a7e079a7e0ac9745" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="virtual">
        <type><ref refid="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" kindref="member">batched_derivs_idx_range_type</ref></type>
        <definition>batched_derivs_idx_range_type IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::batched_derivs_idx_range_xmax</definition>
        <argsstring>(IdxRange&lt; Grid1D... &gt; idx_range) const override</argsstring>
        <name>batched_derivs_idx_range_xmax</name>
        <qualifiedname>IPreallocatableInterpolator::batched_derivs_idx_range_xmax</qualifiedname>
        <reimplements refid="classIInterpolator_1a14f07a9a9cd43939de6acd999d25c195">batched_derivs_idx_range_xmax</reimplements>
        <param>
          <type>IdxRange&lt; Grid1D... &gt;</type>
          <declname>idx_range</declname>
        </param>
        <briefdescription>
<para>Get the batched derivs index range on upper boundaries. </para>
        </briefdescription>
        <detaileddescription>
<para>Dimension of interest IDimI is replaced with ddc::Deriv&lt;IDimI::continuous_dimensions_type&gt;. This is the index range on which derivatives on upper boundaries are defined.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="in">idx_range</parametername>
</parameternamelist>
<parameterdescription>
<para>The index range of a single-species distribution function. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>idx_range The upper boundaries of this index range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="180" column="35" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="180" bodyend="184"/>
      </memberdef>
      <memberdef kind="function" id="classIPreallocatableInterpolator_1acf51b8cbb5a54ff83ee67c20f538e7e3" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>Field&lt; double, IdxRange&lt; Grid1D... &gt; &gt;</type>
        <definition>Field&lt; double, IdxRange&lt; Grid1D... &gt; &gt; IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;::operator()</definition>
        <argsstring>(Field&lt; double, IdxRange&lt; Grid1D... &gt; &gt; const inout_data, Field&lt; const Coord&lt; typename GridInterp::continuous_dimension_type &gt;, IdxRange&lt; Grid1D... &gt; &gt; const coordinates, std::optional&lt; Field&lt; double const, batched_derivs_idx_range_type &gt; &gt; derivs_xmin=std::nullopt, std::optional&lt; Field&lt; double const, batched_derivs_idx_range_type &gt; &gt; derivs_xmax=std::nullopt) const override</argsstring>
        <name>operator()</name>
        <qualifiedname>IPreallocatableInterpolator::operator()</qualifiedname>
        <param>
          <type>Field&lt; double, IdxRange&lt; Grid1D... &gt; &gt; const</type>
          <declname>inout_data</declname>
        </param>
        <param>
          <type>Field&lt; const Coord&lt; typename GridInterp::continuous_dimension_type &gt;, IdxRange&lt; Grid1D... &gt; &gt; const</type>
          <declname>coordinates</declname>
        </param>
        <param>
          <type>std::optional&lt; Field&lt; double const, <ref refid="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" kindref="member">batched_derivs_idx_range_type</ref> &gt; &gt;</type>
          <declname>derivs_xmin</declname>
          <defval>std::nullopt</defval>
        </param>
        <param>
          <type>std::optional&lt; Field&lt; double const, <ref refid="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" kindref="member">batched_derivs_idx_range_type</ref> &gt; &gt;</type>
          <declname>derivs_xmax</declname>
          <defval>std::nullopt</defval>
        </param>
        <briefdescription>
<para>Approximate the value of a function at a set of coordinates using the current values at a known set of interpolation points by temporarily preallocating an <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername direction="inout">inout_data</parametername>
</parameternamelist>
<parameterdescription>
<para>On input: an array containing the value of the function at the interpolation points. On output: an array containing the value of the function at the coordinates. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">coordinates</parametername>
</parameternamelist>
<parameterdescription>
<para>The coordinates where the function should be evaluated. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">derivs_xmin</parametername>
</parameternamelist>
<parameterdescription>
<para>The values of the derivatives at the lower boundary (used only with splines and ddc::BoundCond::HERMITE lower boundary condition). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername direction="in">derivs_xmax</parametername>
</parameternamelist>
<parameterdescription>
<para>The values of the derivatives at the upper boundary (used only with splines and ddc::BoundCond::HERMITE upper boundary condition).</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A reference to the inout_data array containing the value of the function at the coordinates. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="200" column="11" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="200" bodyend="210"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A class which provides access to an interpolating function which can be preallocated where useful. </para>
    </briefdescription>
    <detaileddescription>
<para>An abstract class which implements a preallocate function returning an unique pointer to an <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>. A pointer is used so that the returned object can be any sub-class of <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref>. The type (and thus the implementation of the operator) will be determined when the pointer is dereferenced.</para>
<para>The preallocate function should be used to allocate an instance of the <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref> before using it repeatedly. Once the preallocated object goes out of scope it will be deallocated. This means that objects of this class take up little or no space in memory.</para>
<para>An example of this is seen in <ref refid="classBslAdvectionVelocity" kindref="compound">BslAdvectionVelocity</ref>. The <ref refid="classIPreallocatableInterpolator" kindref="compound">IPreallocatableInterpolator</ref> stored in the <ref refid="classBslAdvectionVelocity" kindref="compound">BslAdvectionVelocity</ref> takes up no memory between advections, however during the execution of the BslAdvectionVelocity::operator() function the <ref refid="classIPreallocatableInterpolator_1a20012bae921142b3c686f6a4a615e23a" kindref="member">IPreallocatableInterpolator::preallocate()</ref> function is called. This leads to the creation of an <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref> instance, ensuring that all buffers necessary for the interpolation during the advection are allocated before the <ref refid="classIInterpolator" kindref="compound">IInterpolator</ref> is used for interpolation in the advection loop. This ensures that these buffers are only allocated once per advection at the start of the BslAdvectionVelocity::operator() function. At the end of this function the unique pointer goes out of scope and the buffers are deallocated. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>IInterpolator&lt; GridInterp, Grid1D... &gt;</label>
        <link refid="classIInterpolator"/>
      </node>
      <node id="1">
        <label>IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;</label>
        <link refid="classIPreallocatableInterpolator"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="2">
        <label>IInterpolator&lt; GridInterp, Grid1D... &gt;</label>
        <link refid="classIInterpolator"/>
      </node>
      <node id="1">
        <label>IPreallocatableInterpolator&lt; GridInterp, Grid1D &gt;</label>
        <link refid="classIPreallocatableInterpolator"/>
        <childnode refid="2" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" line="133" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/interpolation/iinterpolator.hpp" bodystart="134" bodyend="211"/>
    <listofallmembers>
      <member refid="classIPreallocatableInterpolator_1a84c8637a225b4aa749251fb6b7217783" prot="public" virt="non-virtual"><scope>IPreallocatableInterpolator</scope><name>batched_derivs_idx_range_type</name></member>
      <member refid="classIPreallocatableInterpolator_1aa5f6e697f47d2e64a7e079a7e0ac9745" prot="public" virt="virtual"><scope>IPreallocatableInterpolator</scope><name>batched_derivs_idx_range_xmax</name></member>
      <member refid="classIPreallocatableInterpolator_1a737773f79bd66f394f19a6b7d8045b52" prot="public" virt="virtual"><scope>IPreallocatableInterpolator</scope><name>batched_derivs_idx_range_xmin</name></member>
      <member refid="classIPreallocatableInterpolator_1a1cc1863346091416a12a0e3ef210748a" prot="public" virt="non-virtual"><scope>IPreallocatableInterpolator</scope><name>deriv_type</name></member>
      <member refid="classIPreallocatableInterpolator_1acf51b8cbb5a54ff83ee67c20f538e7e3" prot="public" virt="non-virtual"><scope>IPreallocatableInterpolator</scope><name>operator()</name></member>
      <member refid="classIInterpolator_1a83d8113fe207f0d87a240f6ae3f99498" prot="public" virt="pure-virtual" ambiguityscope="IInterpolator&lt; GridInterp, Grid1D... &gt;::"><scope>IPreallocatableInterpolator</scope><name>operator()</name></member>
      <member refid="classIPreallocatableInterpolator_1a20012bae921142b3c686f6a4a615e23a" prot="public" virt="pure-virtual"><scope>IPreallocatableInterpolator</scope><name>preallocate</name></member>
      <member refid="classIInterpolator_1a8cd2160d82f63450c0278568408fc892" prot="public" virt="virtual"><scope>IPreallocatableInterpolator</scope><name>~IInterpolator</name></member>
      <member refid="classIPreallocatableInterpolator_1a938ecc601db6305c1cfc0290abb2f445" prot="public" virt="non-virtual"><scope>IPreallocatableInterpolator</scope><name>~IPreallocatableInterpolator</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
