<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="classMultipatchType" kind="class" language="C++" prot="public">
    <compoundname>MultipatchType</compoundname>
    <includes refid="multipatch__type_8hpp" local="no">multipatch_type.hpp</includes>
    <templateparamlist>
      <param>
        <type>template&lt; typename P &gt; typename</type>
        <declname>T</declname>
        <defname>T</defname>
      </param>
      <param>
        <type>class...</type>
        <declname>Patches</declname>
        <defname>Patches</defname>
      </param>
    </templateparamlist>
    <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classMultipatchType_1ac09ed5edaf7d35c564ef78fe31620631" prot="public" static="no">
        <type>ddc::detail::TypeSeq&lt; Patches... &gt;</type>
        <definition>using MultipatchType&lt; T, Patches &gt;::PatchOrdering =  ddc::detail::TypeSeq&lt;Patches...&gt;</definition>
        <argsstring></argsstring>
        <name>PatchOrdering</name>
        <qualifiedname>MultipatchType::PatchOrdering</qualifiedname>
        <briefdescription>
<para>A tag storing the order of Patches in this <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="35" column="5" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="35" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classMultipatchType_1afba13bfc8d2a69be4c8760228c4a8414" prot="public" static="no">
        <type><ref refid="structT" kindref="compound">T</ref>&lt; ddc::type_seq_element_t&lt; 0, <ref refid="classMultipatchType_1ac09ed5edaf7d35c564ef78fe31620631" kindref="member">PatchOrdering</ref> &gt; &gt;</type>
        <definition>using MultipatchType&lt; T, Patches &gt;::example_element =  T&lt;ddc::type_seq_element_t&lt;0, PatchOrdering&gt; &gt;</definition>
        <argsstring></argsstring>
        <name>example_element</name>
        <qualifiedname>MultipatchType::example_element</qualifiedname>
        <briefdescription>
<para>The type of one of the elements of the <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>. This can be used to check that types are as expected using functions such as ddc::is_chunk_v. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="41" column="5" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="41" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classMultipatchType_1ae7480fdbb95f4018d1cd39f809001c14" prot="protected" static="no" mutable="no">
        <type>std::tuple&lt; <ref refid="structT" kindref="compound">T</ref>&lt; Patches &gt;... &gt;</type>
        <definition>std::tuple&lt;T&lt;Patches&gt;...&gt; MultipatchType&lt; T, Patches &gt;::m_tuple</definition>
        <argsstring></argsstring>
        <name>m_tuple</name>
        <qualifiedname>MultipatchType::m_tuple</qualifiedname>
        <briefdescription>
<para>The internal tuple containing the data. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="45" column="16" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="45" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="friend">
      <memberdef kind="friend" id="classMultipatchType_1a6cf24fdcb53f66e89cab44921a551e1d" prot="protected" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename P &gt; typename</type>
            <declname>OtherType</declname>
            <defname>OtherType</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>OPatches</declname>
            <defname>OPatches</defname>
          </param>
        </templateparamlist>
        <type>class</type>
        <definition>friend class MultipatchType</definition>
        <argsstring></argsstring>
        <name>MultipatchType</name>
        <qualifiedname>MultipatchType::MultipatchType</qualifiedname>
        <param>
          <type><ref refid="classMultipatchType" kindref="compound">MultipatchType</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="48" column="18" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="48" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-func">
      <memberdef kind="function" id="classMultipatchType_1ae1ab2f08d00d74b0fd692ed0269af5c6" prot="protected" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type>KOKKOS_FUNCTION</type>
        <definition>KOKKOS_FUNCTION MultipatchType&lt; T, Patches &gt;::MultipatchType</definition>
        <argsstring>(std::tuple&lt; T&lt; Patches &gt;... &gt; &amp;&amp;tuple)</argsstring>
        <name>MultipatchType</name>
        <qualifiedname>MultipatchType::MultipatchType</qualifiedname>
        <param>
          <type>std::tuple&lt; <ref refid="structT" kindref="compound">T</ref>&lt; Patches &gt;... &gt; &amp;&amp;</type>
          <declname>tuple</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A constructor for sub-classes which can build the necessary tuple directly following their own rules.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tuple</parametername>
</parameternamelist>
<parameterdescription>
<para>The internal tuple. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="55" column="30" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="55" bodyend="55"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classMultipatchType_1a7a63de3f7e30ad01b0a2634abacba57d" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type>KOKKOS_FUNCTION</type>
        <definition>KOKKOS_FUNCTION MultipatchType&lt; T, Patches &gt;::MultipatchType</definition>
        <argsstring>(T&lt; Patches &gt;... args)</argsstring>
        <name>MultipatchType</name>
        <qualifiedname>MultipatchType::MultipatchType</qualifiedname>
        <param>
          <type><ref refid="structT" kindref="compound">T</ref>&lt; Patches &gt;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Instantiate the <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> class from an arbitrary number of objects.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>The objects to be stored in the class. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="63" column="30" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="63" bodyend="66"/>
      </memberdef>
      <memberdef kind="function" id="classMultipatchType_1ac456d01f07ff6b9ae5fb08ca646f4ff7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename P &gt; typename</type>
            <declname>OtherType</declname>
            <defname>OtherType</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>OPatches</declname>
            <defname>OPatches</defname>
          </param>
        </templateparamlist>
        <type>KOKKOS_FUNCTION</type>
        <definition>KOKKOS_FUNCTION MultipatchType&lt; T, Patches &gt;::MultipatchType</definition>
        <argsstring>(MultipatchType&lt; OtherType, OPatches... &gt; const &amp;other)</argsstring>
        <name>MultipatchType</name>
        <qualifiedname>MultipatchType::MultipatchType</qualifiedname>
        <param>
          <type><ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>&lt; OtherType, OPatches... &gt; const &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> class by copying an instance of another compatible <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>.</para>
<para>A compatible <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> is one which uses all the patches used by this class. The object being copied may include more patches than this <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>. Further the original <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> must store objects of the correct type (the type template may be different but return the same type depending on how it is designed.</para>
<para>This function is not explicit as it is helpful to be able to change between equivalent multipatch definitions if the internal type is the same but the definition comes from different locations in the code.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The equivalent <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> being copied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="83" column="21" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="83" bodyend="92"/>
      </memberdef>
      <memberdef kind="function" id="classMultipatchType_1a69f9f3da2bb51cac35b2c609c9fda284" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>template&lt; typename P &gt; typename</type>
            <declname>OtherType</declname>
            <defname>OtherType</defname>
          </param>
          <param>
            <type>class...</type>
            <declname>OPatches</declname>
            <defname>OPatches</defname>
          </param>
        </templateparamlist>
        <type></type>
        <definition>MultipatchType&lt; T, Patches &gt;::MultipatchType</definition>
        <argsstring>(MultipatchType&lt; OtherType, OPatches... &gt; &amp;&amp;other)</argsstring>
        <name>MultipatchType</name>
        <qualifiedname>MultipatchType::MultipatchType</qualifiedname>
        <param>
          <type><ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>&lt; OtherType, OPatches... &gt; &amp;&amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> class from an r-value (temporary) instance of another <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> which uses the same type for the internal tuple.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>The equivalent <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref> being copied. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="101" column="5" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="101" bodyend="111"/>
      </memberdef>
      <memberdef kind="function" id="classMultipatchType_1a9b09b8b98e05fea159a80bbca8367a77" prot="public" static="no" const="no" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>KOKKOS_DEFAULTED_FUNCTION</type>
        <definition>KOKKOS_DEFAULTED_FUNCTION MultipatchType&lt; T, Patches &gt;::~MultipatchType</definition>
        <argsstring>() noexcept=default</argsstring>
        <name>~MultipatchType</name>
        <qualifiedname>MultipatchType::~MultipatchType</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="113" column="31"/>
      </memberdef>
      <memberdef kind="function" id="classMultipatchType_1a4257d5324630c6b8326d8601b5fa1d86" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>class <ref refid="structPatch" kindref="compound">Patch</ref></type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!has_data_access_methods_v&lt; <ref refid="structT" kindref="compound">T</ref>&lt; <ref refid="structPatch" kindref="compound">Patch</ref> &gt; &gt;, bool &gt;</type>
            <defval>true</defval>
          </param>
        </templateparamlist>
        <type>KOKKOS_FUNCTION <ref refid="structT" kindref="compound">T</ref>&lt; <ref refid="structPatch" kindref="compound">Patch</ref> &gt;</type>
        <definition>KOKKOS_FUNCTION T&lt; Patch &gt; MultipatchType&lt; T, Patches &gt;::get</definition>
        <argsstring>() const</argsstring>
        <name>get</name>
        <qualifiedname>MultipatchType::get</qualifiedname>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Retrieve an object from the patch that it is defined on.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="structPatch" kindref="compound">Patch</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>The patch of the object to be returned. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The object on the given patch. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="122" column="23" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="122" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="classMultipatchType_1a6a44d19ff0704be6f0b4e1d476cefbcc" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>KOKKOS_FUNCTION std::tuple&lt; <ref refid="structT" kindref="compound">T</ref>&lt; Patches &gt;... &gt; const &amp;</type>
        <definition>KOKKOS_FUNCTION std::tuple&lt; T&lt; Patches &gt;... &gt; const  &amp; MultipatchType&lt; T, Patches &gt;::get_tuple</definition>
        <argsstring>() const</argsstring>
        <name>get_tuple</name>
        <qualifiedname>MultipatchType::get_tuple</qualifiedname>
        <briefdescription>
<para>Get a constant reference to the tuple of objects stored inside this <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>A constant reference to the tuple of objects stored inside this <ref refid="classMultipatchType" kindref="compound">MultipatchType</ref>. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="141" column="38" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="141" bodyend="144"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-static-func">
      <memberdef kind="function" id="classMultipatchType_1a8bd7585483ea579822748d6100ae3edb" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr std::size_t</type>
        <definition>static constexpr std::size_t MultipatchType&lt; T, Patches &gt;::size</definition>
        <argsstring>()</argsstring>
        <name>size</name>
        <qualifiedname>MultipatchType::size</qualifiedname>
        <briefdescription>
<para>Get the number of objects stored inside the class. This is equal to the number of patches. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>Number of elements stored in the tuple of the class. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="131" column="34" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="131" bodyend="134"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>A class to store several objects that are of a type which is templated by the patch. </para>
    </briefdescription>
    <detaileddescription>
<para>On a multipatch domain when we have objects and types defined on different patches, e.g. fields. They can be stored in this class and then be accessed by the patch they are defined on.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername><ref refid="structT" kindref="compound">T</ref></parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the objects that are stored on the given patches. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Patches</parametername>
</parameternamelist>
<parameterdescription>
<para>The patches of the objects in the same order of the patches that the given objects are defined on.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="warning"><para>The objects have to be defined on different patches. Otherwise retrieving them by their patch is ill-defined. </para>
</simplesect>
</para>
    </detaileddescription>
    <location file="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" line="31" column="1" bodyfile="/home/runner/work/gyselalibxx/gyselalibxx/code_branch/src/multipatch/data_types/multipatch_type.hpp" bodystart="32" bodyend="145"/>
    <listofallmembers>
      <member refid="classMultipatchType_1afba13bfc8d2a69be4c8760228c4a8414" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>example_element</name></member>
      <member refid="classMultipatchType_1a4257d5324630c6b8326d8601b5fa1d86" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>get</name></member>
      <member refid="classMultipatchType_1a6a44d19ff0704be6f0b4e1d476cefbcc" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>get_tuple</name></member>
      <member refid="classMultipatchType_1ae7480fdbb95f4018d1cd39f809001c14" prot="protected" virt="non-virtual"><scope>MultipatchType</scope><name>m_tuple</name></member>
      <member refid="classMultipatchType_1a6cf24fdcb53f66e89cab44921a551e1d" prot="protected" virt="non-virtual"><scope>MultipatchType</scope><name>MultipatchType</name></member>
      <member refid="classMultipatchType_1ae1ab2f08d00d74b0fd692ed0269af5c6" prot="protected" virt="non-virtual"><scope>MultipatchType</scope><name>MultipatchType</name></member>
      <member refid="classMultipatchType_1a7a63de3f7e30ad01b0a2634abacba57d" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>MultipatchType</name></member>
      <member refid="classMultipatchType_1ac456d01f07ff6b9ae5fb08ca646f4ff7" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>MultipatchType</name></member>
      <member refid="classMultipatchType_1a69f9f3da2bb51cac35b2c609c9fda284" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>MultipatchType</name></member>
      <member refid="classMultipatchType_1ac09ed5edaf7d35c564ef78fe31620631" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>PatchOrdering</name></member>
      <member refid="classMultipatchType_1a8bd7585483ea579822748d6100ae3edb" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>size</name></member>
      <member refid="classMultipatchType_1a9b09b8b98e05fea159a80bbca8367a77" prot="public" virt="non-virtual"><scope>MultipatchType</scope><name>~MultipatchType</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
