<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>DDC in Gyselalib++ - GyselalibX</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "DDC in Gyselalib++";
        var mkdocs_page_input_path = "docs/first_steps/DDC_in_gyselalibxx.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> GyselalibX
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">General</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" >First Steps</a>
    <ul class="current">
                <li class="toctree-l2"><a class="reference internal" href="getting_started.html">Getting Started</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Installation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="install.html">Gyselalib++ Installation</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../toolchains/index.html">Pre-made build settings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2 current"><a class="reference internal current" href="#">DDC in Gyselalib++</a>
    <ul class="current">
    <li class="toctree-l3"><a class="reference internal" href="#contents">Contents</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#coordinates">Coordinates</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#indexing-and-associated-concepts">Indexing and associated concepts</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#grid">Grid</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index">Index</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index-step">Index Step</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#index-range">Index Range</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#data-storage">Data Storage</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#example">Example</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#continuous-vs-discrete-objects">Continuous vs. discrete objects</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#example-use-of-index-step-for-finite-differences">Example use of Index Step for Finite Differences</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#pitfalls">Pitfalls</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#synchronicity">Synchronicity</a>
    </li>
        </ul>
    </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tutorials</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="landau_damping_tutorial.html">1D-1V Landau Damping Simulation with Gyselalib++</a>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Standards</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../standards/CODING_STANDARD.html">Coding Standard</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../standards/mathematical_and_physical_conventions.html">Math & Physics</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gyselalib++</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Source</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../src/index.html">Gyselalib++ contents</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/advection/index.html">Advection methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/collisions/index.html">Collisions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/data_types/index.html">Data Storage Types</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/geometryRTheta/index.html">Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_field</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryRTheta/advection_field/index.html">Advection Field finder</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryRTheta/geometry/index.html">Geometry RTheta</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryRTheta/initialisation/index.html">Initialisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryRTheta/poisson/index.html">Polar Poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_solver</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryRTheta/time_solver/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryVparMu</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/geometryVparMu/index.html">Geometry (vpar, mu)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >collisions</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryVparMu/collisions/index.html">CollisionConfiguration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryVparMu/geometry/index.html">GeometryVparMu</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryVparMu/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/geometryXVx/index.html">Geometry (x, v_x)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >boltzmann</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/boltzmann/index.html">Boltzmann solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/geometry/index.html">Geometry X-Vx</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >rhs</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/rhs/index.html">RHS</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXVx/utils/index.html">Utils</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/geometryXY/index.html">Geometry (x, y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXY/geometry/index.html">Geometry XY</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXY/initialisation/index.html">Initialisation on (x,y) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXY/time_integration/index.html">Predictor-corrector methods</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXYVxVy</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/geometryXYVxVy/index.html">Geometry (x, y, v_x, v_y)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometry</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXYVxVy/geometry/index.html">Geometry X Y-Vx Vy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >initialisation</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXYVxVy/initialisation/index.html">Initialisation methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXYVxVy/poisson/index.html">Quasi-Neutrality Solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >time_integration</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXYVxVy/time_integration/index.html">Time integration</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vlasov</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/geometryXYVxVy/vlasov/index.html">Vlasov solver</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >interpolation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/interpolation/index.html">Interpolation Methods</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_splines</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/interpolation/polar_splines/index.html">Polar Splines</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >io</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/io/index.html">Functions used for input and output</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mapping</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/mapping/index.html">Mappings</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >math_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/math_tools/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >matrix_tools</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/matrix_tools/index.html">Matrix tools</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >mpi_parallelisation</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/mpi_parallelisation/index.html">Parallelisation</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/multipatch/index.html">Multipatch</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >connectivity</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/multipatch/connectivity/index.html">Multipatch connectivity</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >data_types</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/multipatch/data_types/index.html">Data Types for Multipatch Geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/multipatch/spline/index.html">Spline on multipatch geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../src/multipatch/utils/index.html">Multipatch utilitary functions</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >pde_solvers</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/pde_solvers/index.html">PDE Solvers</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >quadrature</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/quadrature/index.html">Quadrature Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >speciesinfo</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/speciesinfo/index.html">SpeciesInfo (x, v_x)</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >timestepper</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/timestepper/index.html">Time Stepping Methods</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >utils</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../src/utils/index.html">Utility Functions</a>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Simulations</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../simulations/index.html">Gyselalib++ simulations</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../simulations/geometryRTheta/index.html">Simulations in (r, theta) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >diocotron</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../simulations/geometryRTheta/diocotron/index.html">Diocotron instability</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >vortex_merger</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../simulations/geometryRTheta/vortex_merger/index.html">Vortex merger</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXVx</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../simulations/geometryXVx/index.html">Simulations in (x, vx) geometry</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryXY</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../simulations/geometryXY/index.html">Simulations in (x, y) geometry</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >guiding_centre</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../simulations/geometryXY/guiding_centre/index.html">Guiding centre (X,Y) simulation</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" >Tests</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" href="../../tests/index.html">Gyselalib++ tests</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" >advection</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../tests/advection/index.html">Tests on the templated advection operators</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >geometryRTheta</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../tests/geometryRTheta/index.html">Tests : Geometry (r, theta)</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >advection_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../tests/geometryRTheta/advection_rtheta/index.html">Tests on the 2D polar advection operator</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >polar_poisson</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../tests/geometryRTheta/polar_poisson/index.html">Tests on the 2D polar poisson solver</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l3"><a class="reference internal" >spline_interpolator_rtheta</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../tests/geometryRTheta/spline_interpolator_rtheta/index.html">Tests on spline interpolator in polar coordinates</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >multipatch</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../tests/multipatch/index.html">Multipatch geometry tests</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" >geometries</a>
    <ul>
                <li class="toctree-l4"><a class="reference internal" href="../../tests/multipatch/geometries/index.html">Multipatch geometries</a>
                </li>
    </ul>
                </li>
    </ul>
                </li>
    </ul>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Development</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../development/Adding_docs.html">Adding Docs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../development/Using_git.html">Using Git</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../development/developer_FAQ.html">Developer FAQ</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Troubleshooting</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../troubleshooting/Common_compilation_problems.html">Compilation Issues</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" >Gyselalib++</a>
    <ul>
                <li class="toctree-l2"><a class="reference internal" >Classes</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/annotated.html">Class List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/classes.html">Class Index</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/hierarchy.html">Class Hierarchy</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" >Namespaces</a>
    <ul>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespaces.html">Namespace List</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespace_members.html">Namespace Members</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespace_member_functions.html">Namespace Member Functions</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespace_member_variables.html">Namespace Member Variables</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespace_member_typedefs.html">Namespace Member Typedefs</a>
                </li>
                <li class="toctree-l3"><a class="reference internal" href="../../gyselalibxx/namespace_member_enums.html">Namespace Member Enumerations</a>
                </li>
    </ul>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../gyselalibxx/functions.html">Functions</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../gyselalibxx/variables.html">Variables</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../gyselalibxx/macros.html">Macros</a>
                </li>
                <li class="toctree-l2"><a class="reference internal" href="../../gyselalibxx/files.html">Files</a>
                </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">GyselalibX</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">General</li>
          <li class="breadcrumb-item">First Steps</li>
      <li class="breadcrumb-item active">DDC in Gyselalib++</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/gyselax/gyselalibxx/edit/main/docs/first_steps/DDC_in_gyselalibxx.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <div><h1 id="using-ddc-in-gyselalib">Using DDC in Gyselalib++</h1>
<p><a href="https://github.com/CExA-project/ddc">DDC</a> is a library which aims to provide types which represent mathematical/physical concepts.
Representing these concepts with types allows the compiler to enforce the mathematical validity of expressions.</p>
<p>The DDC library is based on templates. The template parameters are based on physical dimensions.</p>
<p>When using DDC the first step is therefore to create structures representing each of the physical dimensions, e.g. <code>X</code>. These objects should only contain one attribute, a static constexpr boolean called <code>PERIODIC</code> which indicates whether the dimension is periodic or not.
The DDC types are then parametrised by this structure. The dimension is in real space and is continuous.</p>
<p>The following sections describe some of the DDC types used in Gyselalib++.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#coordinates">Coordinates</a></li>
<li><a href="#indexing-and-associated-concepts">Indexing and associated concepts</a></li>
<li><a href="#grid">Grid</a></li>
<li><a href="#index">Index</a></li>
<li><a href="#index-step">Index Step</a></li>
<li><a href="#index-range">Index Range</a></li>
<li><a href="#data-storage">Data Storage</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#pitfalls">Pitfalls</a></li>
</ul>
<h2 id="coordinates">Coordinates</h2>
<p>A <code>Coord</code> in Gysela is an alias to the DDC type <code>ddc::Coordinate</code>. It is one of the only DDC types which represents a continuous data type. This means that it can take any value that can be represented by a double. It represents the position of a coordinate in the vector space.</p>
<p>Coordinates can have 1 or more dimension. E.g. the coordinate of a position on a <span class="arithmatex">\((r,\theta)\)</span> slice should have the type <code>Coord&lt;R, Theta&gt;</code>, where <code>R</code> represents the radial dimension <span class="arithmatex">\(r\)</span>, and <code>Theta</code> represents the poloidal dimension <span class="arithmatex">\(\theta\)</span>.</p>
<p>If the value of the coordinate needs to be used in a mathematical expression, the scalar (<code>double</code>) quantity stored in one of the dimensions of a coordinate can be extracted using <code>ddc::get&lt;DimOfInterest&gt;(my_coord)</code>.</p>
<p>It is also possible to extract a coordinate on a subset of the original dimensions using <code>ddc::select&lt;DimOfInterest&gt;(my_coord)</code>. For example if we want to get the position of an object on a radial slice <span class="arithmatex">\((r,\theta)\)</span>, but we are given the coordinate in the full vector space <span class="arithmatex">\((r, \theta, \varphi, v_\parallel, \mu)\)</span> then we can do:</p>
<pre><code class="language-cpp">Coord&lt;R, Theta, Phi, Vpar, Mu&gt; full_coord(...);
Coord&lt;R, Theta&gt; slice_coord = ddc::select&lt;R, Theta&gt;(full_coord);
</code></pre>
<p>Coordinates can be combined using operators. For example, let us consider three vectors <span class="arithmatex">\(P\)</span>, <span class="arithmatex">\(Q\)</span>, and <span class="arithmatex">\(R\)</span> defined on a cartesian space <span class="arithmatex">\((x,y)\)</span>:</p>
<p><img alt="Vector Image" src="../images/Coordinate_operations.jpg"></p>
<p>The vector <span class="arithmatex">\(Q\)</span> can be written as <span class="arithmatex">\(Q=R-P\)</span>. Similarly in the code, we would have:</p>
<pre><code class="language-cpp">Coord&lt;X, Y&gt; P(5.0, 2.0);
Coord&lt;X, Y&gt; R(7.0, 6.0);
Coord&lt;X, Y&gt; Q = R - P;
</code></pre>
<p>The <code>Coord</code> class also provides an addition operator, comparison operators, and an output operator for easy printing using <code>cout</code>.</p>
<p>In Gyselalib++ the alias <code>CoordX</code> is usually defined in <code>geometry.hpp</code> to describe the type <code>Coord&lt;X&gt;</code> more succinctly.</p>
<h2 id="indexing-and-associated-concepts">Indexing and associated concepts</h2>
<p>The physical problems that our simulations describe are defined on a domain. The domain on which the problem is defined is continuous (e.g. a radial domain <span class="arithmatex">\([0,1)\)</span> ). However a simulation evolves on a grid. This means that the value of the function is only known at a discrete set of points. In the case of a function <span class="arithmatex">\(f(x)\rightarrow y \in \mathbb{R}\)</span> with <span class="arithmatex">\(x \in [0,1)\)</span>, we would usually discretise the domain <span class="arithmatex">\([0,1)\)</span> as follows:
$$
x_0, x_1, ..., x_i, ..., x_N
$$</p>
<p>DDC provides multiple types to represent the concepts required to index elements of arrays defined on this grid or to get the coordinates of the grid.</p>
<h2 id="grid">Grid</h2>
<p>The points <span class="arithmatex">\(\{x_0, ..., x_N\}\)</span> form the grid on which the simulation evolves. This sampling can either be uniform or non-uniform. Accordingly DDC provides 2 classes for which Gysela provides the following type aliases:</p>
<ul>
<li><code>UniformGridBase</code> (the type alias of <code>ddc::UniformPointSampling</code>)</li>
<li><code>NonUniformGridBase</code> (the type alias of <code>NonUniformPointSampling</code>)</li>
</ul>
<p>A uniform point sampling is a collection of points which are equidistant, it is therefore defined with an origin and a step or distance between consecutive points. In contrast the points found in a non-uniform point sampling are arbitrary. This kind of sampling must therefore be initialised from a list of points.</p>
<p>It is possible to have multiple grids defined on the same dimension (e.g. the grid points used for a Gauss-Legendre quadrature, the grid points on which the simulation evolves, the grid points which split a spline into polynomials, etc). In order for each grid that is defined to have a different type DDC requires that we define structures which inherit from <code>UniformGridBase</code> and <code>NonUniformGridBase</code> (these structures are then the base structures from which we inherit). In Gyselalib++ such structures have the keyword <code>Grid</code> in the name (e.g. <code>GridX</code>) and are usually defined in <code>geometry.hpp</code>.</p>
<p>E.g.:</p>
<pre><code class="language-cpp">struct GridX : UniformGridBase&lt;X&gt;
{
};
</code></pre>
<p>Although this seems like a useful type, you should not directly create instances of this class in the code. Instead you should call <code>init_discrete_space</code> and access the points using an <code>Index</code>. For more details see the section about <code>Index</code>.</p>
<h2 id="index">Index</h2>
<p>In order to interact with most types in Gyselalib++ we need to use an <code>Idx</code> (a type alias for <code>ddc::DiscreteElement</code>). This type describes an index of a point in the grid. E.g. the point <code>x_i</code> in the grid <code>GridX</code> can be indexed using the object <code>Idx&lt;GridX&gt;(i)</code>.
An <code>Idx</code> is therefore roughly equivalent to an integer. Compared to an integer, it additionally contains information about the physical direction being examined. This allows the compiler to raise errors if typos/copy-paste errors lead to the wrong dimension being used.</p>
<p>In Gyselalib++ the alias <code>IndexX</code> is usually defined in <code>geometry.hpp</code> to describe the index of the grid along the dimension X on which the distribution function is discretised.</p>
<p>We can also create multi-dimensional indices. E.g. the point <code>(x_i, y_j)</code> can be indexed using the object <code>Idx&lt;GridX, GridY&gt;(i, j)</code></p>
<p>It is also possible to extract an index on a subset of the original dimensions using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_index)</code>.</p>
<p>Once a grid has been initialised using the function <code>ddc::init_discrete_space</code>, an <code>Idx</code> defined on that grid can be used to obtain the coordinates of the points in the grid. This is done using the function <code>ddc::coordinate</code>.</p>
<p>E.g:</p>
<pre><code class="language-cpp">Coord&lt;R&gt; r_min(0.0);
Coord&lt;R&gt; r_max(1.0);
IdxStep&lt;R&gt; r_ncells(10);
ddc::init_discrete_space&lt;GridR&gt;(r_min, r_max, r_ncells);
Idx&lt;GridR&gt; i(0); // The first point in the grid
std::cout &lt;&lt; ddc::coordinate(i) &lt;&lt; std::endl;
</code></pre>
<p>will output:</p>
<pre><code class="language-none">(0.0)
</code></pre>
<h2 id="index-step">Index Step</h2>
<p>An <code>IdxStep</code> (type alias for <code>ddc::DiscreteVector</code>) describes the number of steps to get from one point in a grid to another. E.g. <code>x_3</code> and <code>x_6</code> are separated by <code>IdxStep&lt;GridX&gt;(3)</code>.</p>
<p>This type is useful when we have the index of a point and we need to get the next point. An <code>IdxStep</code> can be added or subtracted from an <code>Idx</code> as long as both objects are templated by the same dimension. Similarly an <code>IdxStep</code> is the result of subtracting 2 <code>Idx</code>s.</p>
<p>E.g:</p>
<pre><code class="language-cpp">Idx&lt;GridX&gt; i(4);
Idx&lt;GridX&gt; j(6);
IdxStep&lt;GridX&gt; k = j-i;
i += k;
</code></pre>
<p>In Gyselalib++ the alias <code>IdxStepX</code> is usually defined in <code>geometry.hpp</code> to describe the step from one element of a grid along the dimension X to another.</p>
<p>As with <code>Idx</code>s, an <code>IdxStep</code> can be multi-dimensional and lower dimension <code>IdxStep</code> objects can be extracted using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_vector)</code>.</p>
<p>For a more concrete example of how this type is useful see <a href="#example">Example</a>.</p>
<h2 id="index-range">Index Range</h2>
<p>The last concept necessary to define the grid on which a simulation evolves is the concept of index ranges. The class <code>IdxRange</code> is designed to describe the indices on which a field is defined. This may be all or only a subset of the indices comprising the grid.</p>
<p>Each index range is described by:</p>
<ul>
<li>An origin : This is the <code>Idx</code> which indicates the first point in the domain.</li>
<li>A size : This is a <code>IdxStep</code> indicating the number of elements in each dimension.</li>
</ul>
<p>For example if we consider the 2D grid: <span class="arithmatex">\([x_0, ..., x_N] \times [y_0, ... y_M]\)</span>, the index range would be described as:</p>
<pre><code class="language-cpp">Idx&lt;GridX, GridY&gt; origin(0, 0);
IdxStep&lt;GridX, GridY&gt; size(N, M);
IdxRange&lt;GridX, GridY&gt; idx_range(origin, size);
</code></pre>
<p>Similarly the section of the grid: <span class="arithmatex">\([x_i, ..., x_j] \times [y_k, ... y_l]\)</span> would be described as:</p>
<pre><code class="language-cpp">Idx&lt;GridX&gt; i_index(i);
Idx&lt;GridX&gt; j_index(j);
Idx&lt;GridY&gt; k_index(k);
Idx&lt;GridY&gt; l_index(l);
Idx&lt;GridX, GridY&gt; origin(i_index, k_index);
IdxStep&lt;GridX, GridY&gt; size((j_index-i_index), (l_index-k_index));
IdxRange&lt;GridX, GridY&gt; idx_range(origin, size);
</code></pre>
<p>When working with index ranges we do not usually know if we have access to all of the grid or just a subset. It is therefore important to use the <code>get_index_range</code> function to traverse fields rather than initialising elements manually as we don't know the index of the first element of a <code>IdxRange</code> at compile time.</p>
<p>There are multiple functions available for traversing an index range. Most of the time we will traverse the entire index range. This can be done simply as <code>IdxRange</code> implements the functions <code>begin()</code> and <code>end()</code>. These functions are called automatically using the modern C++ syntax for a for element in list, or using the <code>ddc::for_each</code> function. The latter is to be preferred as it will allow us to add parallelism later. The syntax is:</p>
<pre><code class="language-cpp">for (Idx&lt;GridX&gt; index : idx_range) {
}
</code></pre>
<p>or:</p>
<pre><code class="language-cpp">ddc::for_each(idx_range, [&amp;](Idx&lt;GridX&gt; index) {
});
</code></pre>
<p>In the case of a <code>ddc::for_each</code> the second argument is a lambda function. The <code>[&amp;]</code> ensures that any variable defined outside the loop are captured by reference so they can be used inside the lambda function.</p>
<p>It is also common to need to iterate over a subset of grid points. Such a subset can be created using the syntax described above, however <code>IdxRange</code> also contains several helper functions which are designed to facilitate the creation of these sets:</p>
<ul>
<li><code>take_first(IdxStep&lt;..&gt; n)</code> : Returns an index range containing only the first n indices of the original range.</li>
<li><code>take_last(IdxStep&lt;..&gt; n)</code> : Returns an index range containing only the last n indices of the original range.</li>
<li><code>remove_first(IdxStep&lt;..&gt; n)</code> : Returns an index range containing all but the first n indices of the original range.</li>
<li><code>remove_last(IdxStep&lt;..&gt; n)</code> : Returns an index range containing all but the last n indices of the original range.</li>
<li><code>remove(IdxStep&lt;..&gt; n_first, IdxStep&lt;..&gt; n_last)</code> : Returns an index range containing all indices of the original range except the first n_first indices and the last n_last indices.</li>
</ul>
<p>It is also possible to extract a lower-dimensional index range from an ND index range using <code>ddc::select&lt;GridOfInterest&gt;(my_nd_idx_range)</code>.</p>
<p>Finally it may not be possible to express the elements you want to iterate over as an index range. This is notably the case if you want to iterate over every j-th element. In this case it is necessary to fall back on <code>IdxRangeIterator</code>. The syntax in this case is:</p>
<pre><code class="language-cpp">for (IdxRangeIterator&lt;GridX&gt; it=idx_range.begin(); it &lt; idx_range.end(); it += j) {
    Idx&lt;GridX&gt; index = *it;
}
</code></pre>
<p>In addition to the iteration functionalities, <code>IdxRange</code> also has other useful functions. The following is a non-exhaustive list of useful functions:</p>
<ul>
<li><code>front()</code> : Returns the first <code>Idx</code> in the domain.</li>
<li><code>back()</code> : Returns the last <code>Idx</code> in the domain.</li>
<li><code>size()</code> : Returns the total number of points in the domain (the product of the number of points in each dimension).</li>
<li><code>extents()</code> : Returns the number of points in each dimension stored in an <code>IdxStep</code>.</li>
</ul>
<p>In Gyselalib++ the alias <code>IdxRangeX</code> is usually defined in <code>geometry.hpp</code> to describe the index range containing points from <code>GridX</code>.</p>
<h2 id="data-storage">Data Storage</h2>
<p>Data is allocated at the instantiation of a <code>FieldMem</code> (type alias for <code>ddc::Chunk</code>). This type is parametrised by the underlying data type (e.g. <code>double</code>), and the <code>IdxRange</code> on which the values are defined. By default in Gysela memory is allocated on the device (GPU).</p>
<p>In order to initialise the data storage to the correct size, a <code>FieldMem</code> is initialised by providing the <code>IdxRange</code> on which the values are defined.</p>
<p>In Gyselalib++ the alias <code>FieldMemX</code> is usually defined in <code>geometry.hpp</code> to describe the memory block for a field defined on the all or part of <code>GridX</code>.. E.g:</p>
<pre><code class="language-cpp">FieldMemXVx&lt;double&gt; distribution_function_2d_alloc(idx_range_x_vx);
</code></pre>
<p>In Gyselalib++ the functions are almost all defined using real numbers. The additional alias <code>DFieldMemX</code> is therefore defined to represent a real function defined on all or part of <code>GridX</code>. E.g:</p>
<pre><code class="language-cpp">DFieldMemRThetaPhiVparMu distribution_function_2d_alloc(idx_range_radial_poloidal_toroidal_velocity_mu);
</code></pre>
<p>As instantiating a <code>FieldMem</code> leads to data allocation using this type always has an associated cost. In order to avoid accidental copying DDC is structured such that the only way to copy data from one <code>FieldMem</code> to another is using the function <code>ddc::deepcopy</code>. Using an assignment or initialising from another <code>FieldMem</code> will result in a compiler error.</p>
<p>To avoid copying data unnecessarily, DDC provides the type <code>Field</code> (type alias for <code>ddc::ChunkSpan</code>). This can be thought of as a reference to a <code>FieldMem</code>. It may at first seem surprising that a new type is required for this as a more typical approach would be to use <code>const&amp;</code>. However when code runs on a GPU a new instance of each variable must be created on the GPU. This is necessary to avoid race conditions and to ensure locality. We do not want all the data in the <code>FieldMem</code> to be copied to/from the GPU every time a kernel is started, so instead we use <code>Field</code> which only copies a pointer to the GPU memory to the new variable instance.</p>
<p>Unless you need to allocate data, you should always use <code>Field</code> rather than <code>FieldMem</code>. A <code>Field</code> can be obtained from a <code>FieldMem</code> using the constructor of <code>Field</code> or the global function <code>get_field</code>.</p>
<p>In Gyselalib++ the alias <code>FieldX</code> is usually defined in <code>geometry.hpp</code> to describe a reference to a function defined on the domain or sub-domain containing points from the point sampling <code>GridX</code>. E.g:</p>
<pre><code class="language-cpp">FieldMemXVx&lt;double&gt; distribution_function_2d_alloc(idx_range_x_vx);
FieldXVx&lt;double&gt; distribution_function_2d(distribution_function_2d_alloc);
</code></pre>
<p>As for <code>FieldMem</code> an additional alias <code>DFieldX</code> is defined to simplify the notation for doubles.</p>
<p>Finally we also define the aliases <code>ConstFieldX</code> and <code>DConstFieldX</code> to represent constant versions of <code>FieldX</code> and <code>DFieldX</code>. These objects are used for function arguments when the contents of the array must not be altered. As they are aliases, not new objects, all the same functions that work for <code>Field</code> can also be used for <code>ConstField</code>. A <code>ConstField</code> can be obtained from a field using the function <code>get_const_field</code>.</p>
<p>:warning: Beware a <code>DConstFieldX</code> is not equivalent to a <code>DFieldX const</code>. The latter indicates only that the field will always be associated with the same <code>FieldMem</code> object. Its contents can still be modified.</p>
<p>A <code>Field</code> is indexed using either multiple 1D <code>Idx</code>s, or one ND <code>Idx</code>. As the <code>Idx</code>s contain information about the dimension on which they act it is not necessary to pass these arguments in a specific order. Thus the following two functions are equivalent:</p>
<pre><code class="language-cpp">double get_element_1(DFieldXVx my_chunk, IdxX i, IdxY j) {
    return my_chunk(i, j);
}

double get_element_2(DFieldXVx my_chunk, IdxX i, IdxY j) {
    return my_chunk(j, i);
}
</code></pre>
<p>This is particularly useful if we don't know the layout order of the data and will allow us to reorder this data without changing the way we interact with the chunk.</p>
<p>Finally a <code>Field</code> also implements a <code>[]</code> operator. A <code>Field</code> does not have to reference the entire memory block stored in the associated <code>FieldMem</code>. The <code>[]</code> operator can be passed an <code>IdxRange</code> to create a <code>Field</code> which only references part of the <code>FieldMem</code>. This is especially useful for accessing slices. In this case a simpler syntax exists, where we only need to pass the index of the slice. For example, if we wish to get a <span class="arithmatex">\((r, \theta)\)</span> slice from a distribution function defined in <span class="arithmatex">\((r, \theta, \varphi, v_\parallel, \mu)\)</span> we would do the following:</p>
<pre><code class="language-cpp">DFieldMem&lt;IdxRange&lt;GridR, GridTheta, GridPhi, GridVpar, GridMu&gt;&gt; distribution_function_alloc(idx_range);
DField&lt;IdxRange&lt;GridR, GridTheta, GridPhi, GridVpar, GridMu&gt;&gt; distribution_function(distribution_function_alloc);
Idx&lt;GridPhi, GridVpar, GridMu&gt; index;
DField&lt;IdxRange&lt;GridR, GridTheta&gt;&gt; distribution_function_slice = distribution_function[index];
</code></pre>
<h2 id="example">Example</h2>
<p>Let us consider the following system of equations (a simple Vlasov-Poisson system):
$$
\left[\partial_t + \frac{1}{\sqrt{m_s}} \left(v\partial_x - q_s \partial_x \phi(t,x)\partial_v\right)\right] f_s(t,x,v) = 0\
\partial_x^2\phi(t,x) = - \sum_s q_s \int f_s(t,x,v) dv\
f_s(0,x,v) = \frac{n_0}{2\pi T_0}\exp\left(-\frac{v^2}{T_0}\right)\cos(k_xx)
$$</p>
<p>which evolves over a 2 dimensional domain defined by the dimensions <span class="arithmatex">\((x,v)\)</span>. The domain is <span class="arithmatex">\([0, 700]\times[-6,6]\)</span>.
We can also consider the species s as a discrete dimension which is defined as [i, e].</p>
<p>The first thing which is necessary to define our system are types describing the continuous dimensions:</p>
<pre><code class="language-cpp">// Tag to represent the x-dimension
struct X {
    static bool constexpr PERIODIC = true;
}

// Tag to represent the v-dimension
struct Vx {
    static bool constexpr PERIODIC = false;
}
</code></pre>
<p>We also need types to define the grid on which the simulation will evolve. The domain is discretised on the following grid: <span class="arithmatex">\([i, e]\times[x_0,...,x_N]\times[v_0,...,v_{N_v}]\)</span>. Grid types are required to define the positions of the grid points in each of the three dimensions:</p>
<ul>
<li>The object <span class="arithmatex">\([x_0,...,x_N]\)</span> is defined with a grid and will be denoted <span class="arithmatex">\(GridX\)</span>.</li>
<li>The object <span class="arithmatex">\([v_0,...,v_{N_v}]\)</span> is defined with a grid and will be denoted <span class="arithmatex">\(GridVx\)</span>.</li>
<li>The object <span class="arithmatex">\(['i', 'e']\)</span> is defined as a <code>SpeciesInformation</code> collection and will be denoted <span class="arithmatex">\(Species\)</span>.</li>
</ul>
<p>With these objects defined, the index range(s) can then be created. The index range for the distribution function has the type: <code>IdxRange&lt;Species, GridX, GridVx&gt;</code> however for simplicity it is denoted <code>IdxRangeSpXVx</code>. The electric potential <span class="arithmatex">\(\phi\)</span> has a smaller domain with the type <code>IdxRange&lt;GridX&gt;</code> denoted <code>IdxRangeX</code>.</p>
<p>Other index ranges may be useful to work on slices of data or on subdomains (e.g. if we distribute our function using MPI).</p>
<p>The data itself will be stored in <code>FieldMem</code>s and accessed with <code>Field</code>s. For example the distribution function will be stored in a <code>DFieldMem&lt;IdxRange&lt;Species, GridX, GridVx&gt;&gt;</code>. To improve readability this type is denoted <code>DFieldMemSpXVx</code>. Similarly the electric potential will be stored in a <code>DFieldMemX</code>.</p>
<p>The other types will be useful when interacting with the data. For example, in order to initialise the distribution function we need to loop over the grid using the coordinates and an <code>Idx&lt;Species, GridX, GridVx&gt;</code> (denoted <code>IdxSpXVx</code> for simplicity) to fill the array:</p>
<pre><code class="language-cpp">IdxRangeSpXVx idx_range(..);
DFieldMemSpXVx distribution_function_alloc(idx_range);
DFieldSpXVx distribution_function(distribution_function_alloc);

ddc::for_each(idx_range, [&amp;](IdxSpXVx index) {
    CoordXVx coord = ddc::coordinate(ddc::select&lt;GridX, GridVx&gt;(index));
    double v_pos = ddc::get&lt;Vx&gt;(coord);
    double x_pos = ddc::get&lt;X&gt;(coord);
    distribution_function(index) = n0 / (2 * M_PI * T0) * exp(-v_pos * v_pos / T0) * cos(kx * x_pos);
});
</code></pre>
<h3 id="continuous-vs-discrete-objects">Continuous vs. discrete objects</h3>
<p>The majority of the DDC types represent objects in or on a discrete vector space. It may not be immediately obvious why continuous objects are also needed given that simulations are necessarily discrete. Backward semi-Lagrangian advection is a good example of where this is required. In backward semi-Lagrangian advection we work on a discrete grid (accessed via an <code>IdxRange</code>), for each point of the grid we trace the characteristic to find where a particle positioned at this grid point would have been located at the previous time step. This location, known as the foot of the characteristic can be located anywhere in the vector space, unlike the grid points, the foot of the characteristic is not restricted to a subset of valid positions. It must therefore be represented with a continuous object. In this case a <code>Coord</code> perfectly describes the position of the foot of the characteristic while also providing all pertinent information about the dimensions.</p>
<h3 id="example-use-of-index-step-for-finite-differences">Example use of Index Step for Finite Differences</h3>
<p>The class <code>IdxStep</code> is particularly useful in cases where we wish to express a stencil. Let us consider the case of a 2D finite differences scheme on uniform meshes expressed as follows:
$$
\nabla^2 f(x,y) = \frac{f(x-h_x, y) + f(x+h_x, y) + f(x, y-h_y) + f(x, y+h_y) - 4f(x,y)}{h_x h_y}
$$</p>
<p>This code can be written simply using <code>Idx</code> and <code>IdxStep</code>:</p>
<pre><code class="language-cpp">double get_laplacian_at_position(DFieldXY function_values, IndexXY position)
{
    IdxStepX x_step(1);
    IdxStepY y_step(1);

    // Get the uniform grid in the appropriate direction and use it to
    // extract the distance h.
    double h_x = ddc::discrete_space&lt;X&gt;().step();
    double h_y = ddc::discrete_space&lt;Y&gt;().step();

    return (function_values(position - x_step) + function_values(position + x_step)
            + function_values(position - y_step) function_values(position + y_step)
            - 4 * function_values(position))
           / (h_x * h_y);
}
</code></pre>
<p>As you can see DDC takes care of combining elements and vectors to ensure that the resulting <code>IdxXY</code> is in the correct position. This makes it simpler to write such stencils and easier to spot errors, especially in cases involving lots of dimensions.</p>
<h2 id="pitfalls">Pitfalls</h2>
<p>When using DDC there are some things that you should be careful about. These are listed here.</p>
<h3 id="synchronicity">Synchronicity</h3>
<p>In DDC and Kokkos the code runs asynchronously when an execution space is provided. When no execution space is provided the code runs synchronously surrounded by fences. In order to ensure that there is no danger coming from the asynchronicity we need to follow certain rules. In Gysela the chosen conventions are:</p>
<ul>
<li>Always provide an execution space to <code>ddc::parallel_for_each</code> or <code>ddc::parallel_transform_reduce</code> (or similar Kokkos functions).</li>
<li>Only provide an execution space to <code>create_mirror_view_and_copy</code> when this is unavoidable (i.e. when copying to the <code>DefaultExecutionSpace</code>). The <code>DefaultHostExecutionSpace</code> should never be passed to <code>create_mirror_view_and_copy</code>.</li>
</ul></div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../../toolchains/index.html" class="btn btn-neutral float-left" title="Pre-made build settings"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="landau_damping_tutorial.html" class="btn btn-neutral float-right" title="1D-1V Landau Damping Simulation with Gyselalib++">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/gyselax/gyselalibxx/" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../../toolchains/index.html" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="landau_damping_tutorial.html" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../jscript/mathjax.js"></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
